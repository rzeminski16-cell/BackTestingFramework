# Vulnerability Score Modeler & Optimizer
## Technical Specification

---

## 1. Executive Summary

The Vulnerability Score Modeler is a post-backtest analysis tool that:
- Takes completed backtest results (trades with entry/exit data)
- Re-evaluates each trade's lifetime with a modular, parameterizable vulnerability scoring function
- Simulates daily buy signals and tests whether trades would be replaced
- Measures the P/L impact of vulnerability-based exits vs. natural exits
- Provides interactive visualization and parameter tuning to optimize the scoring logic

**Key Insight:** The backtest runs *once*. All analysis is computational (no additional data downloads or re-backtesting).

---

## 2. System Architecture

### 2.1 Data Flow

```
[Completed Backtest]
        ↓
[Extract Trade Records]
    (entry_date, entry_price, exit_date, exit_price, exit_reason)
        ↓
[For Each Parameter Set]:
    ├─ Calculate Daily Vulnerability Scores
    ├─ Simulate Daily Buy Signals
    ├─ Determine Swaps (if score < threshold)
    ├─ Calculate Alternative Exit P/L
    ├─ Measure Deviation from Natural Exit
        ↓
[GUI / Analysis Layer]
    ├─ Visualize Trade Lifecycles
    ├─ Compare Metrics
    ├─ Tune Parameters
    └─ Export Reports
```

### 2.2 Module Organization

```
your_backtesting_framework/
├── core/
│   ├── backtest_engine.py       # (existing)
│   ├── optimization.py          # (existing)
│   └── strategy_logic.py        # (existing)
│
├── vulnerability_scorer/
│   ├── __init__.py
│   ├── features.py              # Feature calculation engine
│   ├── scoring.py               # Core vulnerability score logic
│   ├── simulator.py             # Signal injection & swap simulation
│   └── analyzer.py              # P/L impact analysis
│
├── gui/
│   ├── main_window.py           # (existing)
│   └── vulnerability_gui.py     # NEW: Vulnerability modeler UI
│
└── visualizations/
    └── vulnerability_plots.py   # Charts & heatmaps
```

---

## 3. Feature Definitions

### 3.1 Available Features

Each feature is a daily calculation for an open position. All are optional and can be enabled/disabled.

| Feature Name | Definition | Calculation | Units | Range | Importance |
|---|---|---|---|---|---|
| **days_held** | Days since entry | `(current_date - entry_date).days` | Days | 0–N | ⭐⭐⭐ HIGH |
| **current_pl_pct** | Current P/L as % of entry | `(current_price - entry_price) / entry_price * 100` | % | -100 to +∞ | ⭐⭐⭐ HIGH |
| **pl_momentum_7d** | P/L change in last 7 days | `current_pl_pct - pl_pct_7days_ago` | % | -∞ to +∞ | ⭐⭐⭐ HIGH |
| **pl_momentum_14d** | P/L change in last 14 days | `current_pl_pct - pl_pct_14days_ago` | % | -∞ to +∞ | ⭐⭐ MEDIUM |
| **volatility_7d** | 7-day rolling volatility | `std(daily_returns[-7:])` | % | 0–100 | ⭐⭐ MEDIUM |
| **distance_from_high** | % below 52-week high | `(current_price - high_52w) / high_52w * 100` | % | -100 to 0 | ⭐⭐ MEDIUM |
| **distance_from_entry** | % from entry price | `(current_price - entry_price) / entry_price * 100` | % | -100 to +∞ | ⭐⭐ MEDIUM |
| **max_favorable_excursion** | Best price since entry vs current | `(max_price - current_price) / max_price * 100` | % | 0–100 | ⭐ LOW |
| **entropy_7d** | Price action noise (volatility w/o direction) | `std(close[-7:]) / mean(close[-7:])` | % | 0–100 | ⭐ LOW |

### 3.2 Feature Selection UI

```
[Feature Selection Panel]
☑ days_held              [Weight: ___] 
☑ current_pl_pct         [Weight: ___]
☑ pl_momentum_7d         [Weight: ___]
☑ pl_momentum_14d        [Weight: ___]
☑ volatility_7d          [Weight: ___]
☑ distance_from_high     [Weight: ___]
☐ distance_from_entry    [Weight: ___]
☐ max_favorable_excursion [Weight: ___]
☐ entropy_7d             [Weight: ___]

[Reset to Default] [Load Preset]
```

---

## 4. Vulnerability Score Calculation

### 4.1 Core Formula

The vulnerability score is a weighted, multi-component function that produces a score from 0–100.

```
Vulnerability_Score(position, current_day) = 
    Immunity_Check() 
    OR 
    Composite_Score()

Where:

Immunity_Check():
    IF days_held <= immunity_days_param:
        RETURN 100  // Cannot be swapped
    
Composite_Score():
    score = base_score_param  (default: 100)
    
    FOR each enabled_feature:
        raw_value = feature.calculate()
        normalized_value = feature.normalize(raw_value)
        weighted_contribution = normalized_value * feature.weight
        score += weighted_contribution
    
    RETURN clamp(score, 0, 100)
```

### 4.2 Parameterizable Components

Each scoring run has these parameters:

```python
class VulnerabilityScoreParams:
    # Immunity Period
    immunity_days: int = 7                    # Trades < this age get score 100
    
    # Base & Thresholds
    base_score: float = 100.0
    swap_threshold: float = 50.0              # If score < this, vulnerable to swap
    
    # Feature Weights (additive modifiers to score)
    features: Dict[str, FeatureWeight] = {
        'days_held': FeatureWeight(
            enabled=True,
            weight=-5.0,                      # Negative = loses points per day
            decay_point=14,                   # After 14 days, penalty increases
            fast_decay_rate=-5.0,             # If stagnant (low PL)
            slow_decay_rate=-1.0              # If performing (high PL)
        ),
        'current_pl_pct': FeatureWeight(
            enabled=True,
            weight=1.0,
            stagnation_threshold=2.0,         # Below 2% = stagnant
        ),
        'pl_momentum_7d': FeatureWeight(
            enabled=True,
            weight=3.0,                       # Recent momentum = high weight
        ),
        # ... other features
    }
    
    # Tie-Breaker Rules (if multiple positions have same low score)
    tiebreaker_order: List[str] = [
        'current_pl_pct',                     # Sell losers first
        'days_held',                          # Then oldest
    ]
```

### 4.3 Score Calculation Example

```
Position: AAPL, Held 25 days, +3% P/L, +0.5% in last 7 days

Parameters:
  immunity_days: 7
  base_score: 100
  
Calculation:
  Step 1: days_held (25) > immunity_days (7) → NOT IMMUNE
  Step 2: base_score = 100
  
  Step 3: Apply Features
    - days_held: 25 days * (-1.0 slow decay) = -25 → Score = 75
    - current_pl_pct: +3% (above 2% threshold) → +1.0 = 76
    - pl_momentum_7d: +0.5% is weak → -2.0 = 74
  
  Step 4: CLAMP(74, 0, 100) = 74
  
Result: Score = 74 (Above threshold of 50, so NOT vulnerable)
```

---

## 5. Signal Injection & Swap Simulation

### 5.1 Signal Injection Strategy

For a **single-security backtest** (since you're modeling one stock at a time):

```python
def inject_daily_signals(backtest_trades, date_range):
    """
    For every day in the backtest period, simulate a 'buy signal' 
    for a new security appearing.
    
    This allows us to ask: "On this day, would we have swapped an 
    open position for a new signal?"
    """
    signals = []
    for current_date in date_range:
        if current_date >= backtest_trades[0].entry_date:
            signals.append({
                'date': current_date,
                'type': 'BUY',
                'strength': 1.0,  # Default uniform strength
                'source': 'SIMULATED_DAILY'
            })
    return signals
```

For **portfolio backtests** (multiple stocks):

```python
def use_actual_strategy_signals(backtest_records):
    """
    Use the real buy signals from the strategy.
    backtest_records.strategy_signals contains actual entry points.
    """
    return backtest_records.strategy_signals
```

### 5.2 Swap Logic (Daily Simulation)

For each day in the backtest:

```python
def simulate_swaps(open_positions, signal, 
                   vulnerability_scores, swap_threshold):
    """
    On a given day, if a new signal appears:
    1. Calculate vulnerability scores for all open positions
    2. Find the weakest position
    3. If weakest < threshold, simulate a swap
    4. Record the swap event
    """
    
    if len(open_positions) == 0:
        return None  # No positions to swap
    
    if signal is None:
        return None  # No new signal
    
    # Get scores for all open positions on this day
    scores = {
        pos.id: calculate_daily_score(pos, signal.date, params)
        for pos in open_positions
    }
    
    # Find weakest
    weakest_id = min(scores, key=scores.get)
    weakest_score = scores[weakest_id]
    
    if weakest_score < swap_threshold:
        return {
            'date': signal.date,
            'swapped_position_id': weakest_id,
            'weakest_score': weakest_score,
            'new_signal': signal.type,
            'reason': 'VULNERABILITY_SCORE'
        }
    
    return None
```

### 5.3 Swap Event Log

After simulation, produce a log:

```
Swap Events (Vulnerability-Based Exits):
─────────────────────────────────────────
Date       | Position | Score | Reason           | Actual Exit | Days Held | Natural P/L | Swapped P/L
2024-01-15 | AAPL     | 38    | STAGNANT         | 2024-01-30  | 15        | +4.2%       | +2.1%
2024-02-20 | TSLA     | 42    | LOSING + STALE   | 2024-02-25  | 20        | -2.3%       | -3.5%
2024-03-10 | MSFT     | 48    | MOMENTUM LOSS    | 2024-04-02  | 23        | +6.1%       | +4.8%

Total Swaps: 3
Total P/L Difference: -1.7%
```

---

## 6. P/L Impact Analysis

### 6.1 Core Metrics

For each trade, calculate:

```python
class TradeAnalysis:
    trade_id: str
    symbol: str
    entry_date: date
    exit_date_natural: date         # When the strategy exited
    exit_price_natural: float
    pl_natural: float               # P/L from natural exit
    
    # Vulnerability-based analysis
    days_before_vulnerability_exit: int
    vulnerability_exit_price: float  # Price when score < threshold
    pl_vulnerability: float          # P/L if we exited at vulnerability point
    pl_difference: float             # pl_vulnerability - pl_natural
    
    swap_occurred: bool              # Was this position actually swapped?
    swap_date: Optional[date]
    
    # Quality metrics
    outcome_category: str            # 'BENEFITED', 'HURT', 'NEUTRAL'
    impact_severity: str             # 'AVOIDED_LOSS', 'KILLED_WINNER', etc.
```

### 6.2 Portfolio-Level Metrics

```python
class VulnerabilityAnalysisReport:
    total_trades: int
    trades_affected_by_vulnerability: int      # Would have been swapped
    
    # P/L Analysis
    total_pl_natural: float                    # Sum of all natural exits
    total_pl_if_vulnerability: float           # Sum if we used vulnerability score
    total_pl_difference: float                 # The "cost" of the scoring function
    
    # Trade Categorization
    benefited_count: int                       # Trades where vul. score was better
    hurt_count: int                            # Trades where vul. score was worse
    neutral_count: int                         # Negligible difference
    
    # Quality Metrics
    false_positive_rate: float                 # % of trades that would be closed but recovered
    accuracy: float                            # % of trades where vul. score decision was good
    
    # Charts / Distributions
    pl_difference_histogram: List[float]       # Distribution of individual trade impacts
    timing_accuracy: List[float]               # How early/late were swaps?
```

---

## 7. GUI Specification

### 7.1 Main Window Layout

```
┌─────────────────────────────────────────────────────────────┐
│  VULNERABILITY SCORE MODELER & OPTIMIZER                    │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  [Load Backtest] [SELECT SECURITY] [RUN ANALYSIS] [EXPORT]  │
│                                                               │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  LEFT PANEL (Feature Config)     │ CENTER (Charts)  │ R PANEL│
│  ─────────────────────────────   │                  │        │
│  Features:                        │ [Trade Timeline] │ Report │
│  ☑ days_held [weight: -1.5]      │                  │        │
│  ☑ current_pl_pct [weight: 1.0]  │ [Metric Heatmap] │ Stats: │
│  ☑ pl_momentum_7d [weight: 3.0]  │                  │        │
│  ☑ volatility_7d [weight: 0.5]   │ [Comparison]     │ Total  │
│                                  │                  │ P/L    │
│  Parameters:                     │                  │ Diff:  │
│  Immunity Days: [7]              │                  │ -1.7%  │
│  Base Score: [100]               │                  │        │
│  Swap Threshold: [50]            │                  │        │
│                                  │                  │        │
│  [RUN SIMULATION] [RESET] [SAVE] │                  │        │
│                                  │                  │        │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 Interaction Flow

```
1. USER LOADS BACKTEST
   [Button: "Load Backtest JSON/CSV"]
   → System extracts all completed trades

2. USER SELECTS SECURITY / MODE
   - Single Security: [Dropdown: Select Stock]
   - Portfolio Mode: [Radio: "Use All Stocks"]
   → System displays available securities & date ranges

3. USER CONFIGURES FEATURES
   [Feature Checklist + Weight Sliders]
   → Real-time preview of feature importance

4. USER ADJUSTS PARAMETERS
   [Immunity Days: 7] [Base Score: 100] [Threshold: 50]
   → Live preview updates

5. USER RUNS SIMULATION
   [RUN SIMULATION Button]
   → System calculates vulnerability scores for all days
   → Simulates swaps
   → Calculates P/L impact

6. USER REVIEWS RESULTS
   [Interactive Charts]
   - Trade timeline with vulnerability overlay
   - P/L impact distribution
   - Before/After comparison
   
7. USER TUNES & RE-RUNS
   Adjust parameters → RUN SIMULATION again (fast, no data reload)

8. USER EXPORTS
   [Export Button] → JSON / CSV with all analysis
```

### 7.3 Detailed UI Sections

#### 7.3.1 Feature Configuration Panel

```python
class FeatureConfigPanel:
    """Left sidebar with feature toggles and weights."""
    
    def __init__(self, parent):
        self.feature_toggles = {}           # Dict[str, Checkbox]
        self.feature_weights = {}           # Dict[str, Slider]
        self.feature_descriptions = {}      # Dict[str, Label]
        
        # For each available feature:
        for feature_name in AVAILABLE_FEATURES:
            checkbox = Checkbox(feature_name)
            slider = Slider(min=-10, max=10, step=0.1)
            label = Label(feature_description[feature_name])
            
            checkbox.on_change(self.on_feature_toggled)
            slider.on_change(self.on_weight_changed)
            
            self.add_widget(checkbox, slider, label)
    
    def get_current_params(self) -> VulnerabilityScoreParams:
        """Returns the current parameter state."""
        params = VulnerabilityScoreParams()
        params.features = {
            name: FeatureWeight(
                enabled=self.feature_toggles[name].is_checked(),
                weight=self.feature_weights[name].value()
            )
            for name in AVAILABLE_FEATURES
        }
        return params
```

#### 7.3.2 Parameter Panel

```python
class ParameterPanel:
    """Configure thresholds and immunity periods."""
    
    widgets = {
        'immunity_days': Spinner(min=0, max=30, value=7),
        'base_score': Spinner(min=0, max=200, value=100),
        'swap_threshold': Slider(min=0, max=100, step=5, value=50),
        'stagnation_threshold': Spinner(min=0.0, max=5.0, step=0.1, value=2.0),
    }
    
    def get_params(self) -> VulnerabilityScoreParams:
        """Return current parameter values."""
        return VulnerabilityScoreParams(
            immunity_days=self.widgets['immunity_days'].value(),
            base_score=self.widgets['base_score'].value(),
            swap_threshold=self.widgets['swap_threshold'].value(),
            # ... etc
        )
```

#### 7.3.3 Chart Panel (Center)

Three main visualizations:

**Chart 1: Trade Timeline with Vulnerability Overlay**
```
Trade: AAPL (Entry: Jan 5, Natural Exit: Jan 30)
Price:     │     ╱╲
           │    ╱  ╲     Entry  Vulnerability  Natural
           │   ╱    ╲    Point  Exit Point     Exit
           │  ╱      ╲    │       │             │
───────────┼─────────────┴───────┴─────────────┴──
Vuln Score │ ┌─────╲
100        │ │      ╲──┐
50         │ │         └──┐
0          │ └────────────┘
───────────┴─────────────────────────────────────
Date       Jan5   Jan10  Jan15  Jan20  Jan25  Jan30
           ├─── 7-day immunity ───┤
           
Status: Would be SWAPPED on Jan 22 (Score: 38 < Threshold: 50)
P/L Natural: +4.2% | P/L If Swapped: +2.1% | Difference: -2.1%
```

**Chart 2: Vulnerability Score vs P/L Scatter**
```
Scatter plot: X-axis = Days Held, Y-axis = Vulnerability Score
Color = P/L Direction (Green/Red)
Size = Impact Severity

Goal: Identify patterns in when trades become vulnerable.
```

**Chart 3: Before/After Comparison**
```
Bar Chart: 
  Natural P/L Total:      [████████████] $50,000
  Vulnerability P/L:      [██████████░░] $48,300
  Difference:             [██░░░░░░░░░░] -$1,700

Breakdown:
  Trades Benefited:  3  (+$2,100 total)
  Trades Hurt:       5  (-$3,800 total)
  Neutral:           12
```

### 7.4 Analysis Report Panel (Right Sidebar)

```
┌─ ANALYSIS REPORT ─────┐
│                       │
│ Backtest Period:      │
│ 2020-01-01 to 2024-12-31 │
│                       │
│ Total Trades:         │ 42
│ Security: AAPL        │
│ Mode: Single Stock    │
│                       │
│ ─ RESULTS ────────   │
│ Trades Affected:      │ 8 (19%)
│ Swapped Early:        │ 5
│ Natural Exit Better:   │ 3
│                       │
│ ─ P/L IMPACT ──────  │
│ Natural Total:        │ +$4,200
│ Vuln Score Total:     │ +$3,100
│ Difference:           │ -$1,100 (-26%)
│                       │
│ ─ QUALITY ────────   │
│ False Positives:      │ 3 (37.5%)
│ True Positives:       │ 5 (62.5%)
│                       │
│ ─ KEY INSIGHT ─────  │
│ Vuln score is too    │
│ aggressive; closing  │
│ winners too early.   │
│                       │
│ Recommendation:      │
│ ↑ Swap threshold to 60│
│ OR                   │
│ ↑ Momentum weight    │
│                       │
└───────────────────────┘
```

---

## 8. Implementation Order

### Phase 1: Core Engine (No UI)
1. Implement `features.py` — All feature calculations
2. Implement `scoring.py` — Vulnerability score logic
3. Implement `simulator.py` — Signal injection + swap simulation
4. Implement `analyzer.py` — P/L analysis
5. Write unit tests for each module

**Deliverable:** Python library that can run in-memory without GUI

### Phase 2: Integration with Backtest Engine
6. Modify backtest output format to export trade records in a standardized format
7. Create a `loader.py` that reads backtest output and creates `Trade` objects
8. Test with sample backtest data

**Deliverable:** Standalone CLI tool: `python vulnerability_scorer.py --backtest results.json --params config.json`

### Phase 3: GUI
9. Design and implement GUI windows (using PyQt5 or PySimpleGUI)
10. Wire feature/parameter panels to core engine
11. Implement chart visualization (Matplotlib / Plotly embedded in GUI)
12. Add report generation panel

**Deliverable:** Full GUI application

### Phase 4: Refinement
13. Add preset configurations (e.g., "Conservative", "Aggressive")
14. Add export/import of parameter configurations
15. Performance optimization (caching, parallel calculation if needed)

---

## 9. Data Structures

### 9.1 Input: Trade Record

```python
@dataclass
class Trade:
    id: str                          # Unique identifier
    symbol: str                      # Stock ticker
    entry_date: date
    entry_price: float
    exit_date: date                  # Natural exit (from backtest)
    exit_price: float
    exit_reason: str                 # 'STOP_LOSS' | 'EXIT_RULE' | etc.
    pl_pct: float                    # P/L %
    pl_dollars: float                # P/L in $
    daily_closes: Dict[date, float]  # For volatility / momentum calc
    daily_highs: Dict[date, float]   # For distance_from_high
    daily_lows: Dict[date, float]
```

### 9.2 Intermediate: Vulnerability Score Record

```python
@dataclass
class DailyVulnerabilityRecord:
    trade_id: str
    date: date
    current_price: float
    current_pl_pct: float
    vulnerability_score: float       # 0-100
    feature_contributions: Dict[str, float]  # Debug: contribution from each feature
    is_immune: bool
    would_be_swapped: bool
```

### 9.3 Output: Analysis Result

```python
@dataclass
class TradeVulnerabilityAnalysis:
    trade_id: str
    symbol: str
    entry_date: date
    exit_date_natural: date
    exit_price_natural: float
    pl_natural_pct: float
    pl_natural_dollars: float
    
    # Vulnerability analysis
    first_vulnerable_date: Optional[date]    # When score first < threshold
    first_vulnerable_score: float
    first_vulnerable_pl_pct: float
    
    # Counterfactual
    pl_if_exited_at_vulnerability_pct: float
    pl_difference_pct: float                 # Negative = hurt by scoring
    
    # Quality
    was_loser: bool
    would_have_been_swapped: bool
    benefit_category: str                    # 'AVOIDED_LOSS' | 'KILLED_WINNER' | 'NEUTRAL'
    
    # Daily timeline (for charting)
    daily_timeline: List[DailyVulnerabilityRecord]

@dataclass
class VulnerabilityAnalysisReport:
    symbol: str
    date_range: Tuple[date, date]
    parameter_set: VulnerabilityScoreParams
    
    trades: List[TradeVulnerabilityAnalysis]
    
    # Summary statistics
    summary: Dict[str, Any] = field(default_factory=dict)
    # {
    #   'total_trades': 42,
    #   'affected_trades': 8,
    #   'total_pl_natural': 4200.0,
    #   'total_pl_vulnerability': 3100.0,
    #   'total_pl_difference': -1100.0,
    #   'benefited_count': 3,
    #   'hurt_count': 5,
    #   ...
    # }
```

---

## 10. Configuration File Format

### 10.1 Parameter Configuration (JSON)

```json
{
  "name": "Conservative_Momentum",
  "description": "Protects losers, closes stagnant trades",
  "parameters": {
    "immunity_days": 7,
    "base_score": 100,
    "swap_threshold": 50,
    "stagnation_threshold_pct": 2.0
  },
  "features": {
    "days_held": {
      "enabled": true,
      "weight": -1.5,
      "decay_point": 14,
      "fast_decay_rate": -5.0,
      "slow_decay_rate": -1.0
    },
    "current_pl_pct": {
      "enabled": true,
      "weight": 1.0,
      "stagnation_threshold": 2.0
    },
    "pl_momentum_7d": {
      "enabled": true,
      "weight": 3.0
    },
    "pl_momentum_14d": {
      "enabled": false,
      "weight": 0.0
    },
    "volatility_7d": {
      "enabled": true,
      "weight": 0.5
    },
    "distance_from_high": {
      "enabled": false,
      "weight": 0.0
    },
    "distance_from_entry": {
      "enabled": false,
      "weight": 0.0
    },
    "max_favorable_excursion": {
      "enabled": false,
      "weight": 0.0
    },
    "entropy_7d": {
      "enabled": false,
      "weight": 0.0
    }
  }
}
```

### 10.2 Preset Configurations

Pre-built JSON files (bundled with application):
- `preset_conservative.json` — Protects losers, unlikely to swap
- `preset_aggressive.json` — Swaps quickly if no progress
- `preset_momentum_focused.json` — Emphasizes recent momentum
- `preset_time_decay.json` — Strongly penalizes old trades

---

## 11. Testing Strategy

### 11.1 Unit Tests

```python
# tests/test_features.py
def test_days_held_calculation():
    """Verify days_held is calculated correctly."""
    
def test_current_pl_pct_calculation():
    """Verify P/L % calculation is correct."""
    
def test_pl_momentum_7d():
    """Verify momentum calculation uses correct time window."""

# tests/test_scoring.py
def test_immunity_period():
    """Trades < 7 days should get score 100."""
    
def test_stagnant_trade_scoring():
    """Stagnant profitable trade should lose points rapidly."""
    
def test_losing_trade_protection():
    """Losing trade should have higher protection."""

# tests/test_simulator.py
def test_swap_logic():
    """If score < threshold, trade should be marked for swap."""
    
def test_no_swap_if_immune():
    """Positions in immunity period should never be swapped."""

# tests/test_analyzer.py
def test_pl_difference_calculation():
    """P/L difference should be pl_vulnerability - pl_natural."""
    
def test_report_generation():
    """Report should contain all expected fields."""
```

### 11.2 Integration Tests

- Load actual backtest output
- Run full simulation pipeline
- Verify output matches expected structure
- Check numerical accuracy against manual calculation

### 11.3 Acceptance Tests

- Run on a sample backtest
- Verify visual output (charts display correctly)
- Verify export output (CSV/JSON valid)

---

## 12. Performance Considerations

### 12.1 Complexity

For a backtest with:
- N trades
- D days in backtest period
- F enabled features

**Time Complexity:** O(N × D × F)
- For each trade's daily lifetime, calculate each feature
- Typical: 50 trades × 1000 days × 5 features = 250K calculations
- Should complete in < 1 second on modern hardware

### 12.2 Optimization

- **Caching:** Pre-calculate rolling volatility once (not per trade)
- **Vectorization:** Use NumPy/Pandas for feature calculations
- **Lazy Evaluation:** Only calculate enabled features

---

## 13. Future Enhancements

1. **Machine Learning:** Use historical trade outcomes to learn optimal weights
2. **Multivariate Analysis:** PCA to reduce feature dimensionality
3. **Sensitivity Analysis:** "Spider" plots showing impact of each parameter
4. **Backtesting Integration:** Run full backtests with vulnerability scoring enabled natively
5. **Multi-security Comparison:** Compare vulnerability score performance across different stocks
6. **Walk-forward Optimization:** Optimize vulnerability parameters over rolling windows

---

## 14. Glossary

| Term | Definition |
|---|---|
| **Vulnerability Score** | Daily 0–100 metric indicating how "expendable" a position is |
| **Swap** | Closing one position to open another when new signal appears |
| **Immunity Period** | Time window after entry when position cannot be swapped |
| **Stagnation** | Position with low P/L and no momentum |
| **Signal Injection** | Simulating daily buy signals to test swap decisions |
| **Counterfactual** | "What-if" P/L if vulnerability scoring had been used |
| **Feature Weight** | Coefficient controlling how much a feature affects the score |
| **Threshold** | Score below which a position is vulnerable to swapping |

---

## 15. Success Criteria

✅ System successfully loads completed backtests  
✅ Vulnerability score calculation matches documented formula  
✅ Swap simulation logic correctly identifies vulnerable positions  
✅ P/L impact analysis accurately quantifies costs of swapping  
✅ GUI allows intuitive parameter tuning  
✅ Charts clearly visualize trade lifecycles and vulnerability evolution  
✅ User can answer: "How much did I lose/gain from vulnerability-based exits?"  
✅ Parameter configurations are reproducible and shareable  
✅ System runs efficiently (< 1 second for typical backtest)

---

## End of Specification

