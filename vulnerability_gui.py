"""
Vulnerability Score Modeler & Optimizer GUI.

A graphical user interface for analyzing and optimizing vulnerability score parameters.

This tool allows users to:
1. Load completed backtest results (single or multiple)
2. Configure vulnerability score parameters
3. Run simulations to see swap impact
4. Visualize results and optimize parameters
5. Export/import configurations and presets
6. Run advanced analysis (sensitivity, walk-forward, Monte Carlo, etc.)

Usage:
    python vulnerability_gui.py
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional, Callable
import json
import traceback
import threading
import queue


class ProgressDialog:
    """
    A progress dialog for long-running operations.

    Usage:
        progress = ProgressDialog(root, "Running Analysis", "Processing trades...")
        progress.show()

        # Update progress as you go
        for i, item in enumerate(items):
            progress.update(i / len(items) * 100, f"Processing {i+1}/{len(items)}")
            if progress.cancelled:
                break
            # Do work...

        progress.close()
    """

    def __init__(
        self,
        parent: tk.Tk,
        title: str = "Please Wait",
        message: str = "Processing...",
        determinate: bool = True,
        cancellable: bool = True
    ):
        """
        Initialize progress dialog.

        Args:
            parent: Parent window
            title: Dialog title
            message: Initial message
            determinate: If True, show percentage. If False, show indeterminate progress.
            cancellable: If True, show cancel button
        """
        self.parent = parent
        self.cancelled = False
        self.dialog = None
        self.progress_var = tk.DoubleVar(value=0)
        self.message_var = tk.StringVar(value=message)
        self.determinate = determinate
        self.cancellable = cancellable
        self.title = title

    def show(self):
        """Display the progress dialog."""
        self.dialog = tk.Toplevel(self.parent)
        self.dialog.title(self.title)
        self.dialog.geometry("400x120")
        self.dialog.transient(self.parent)
        self.dialog.resizable(False, False)

        # Center on parent
        self.dialog.update_idletasks()
        x = self.parent.winfo_x() + (self.parent.winfo_width() - 400) // 2
        y = self.parent.winfo_y() + (self.parent.winfo_height() - 120) // 2
        self.dialog.geometry(f"+{x}+{y}")

        # Message
        ttk.Label(self.dialog, textvariable=self.message_var, wraplength=380).pack(pady=(15, 5))

        # Progress bar
        mode = 'determinate' if self.determinate else 'indeterminate'
        self.progress_bar = ttk.Progressbar(
            self.dialog,
            variable=self.progress_var,
            maximum=100,
            mode=mode,
            length=350
        )
        self.progress_bar.pack(pady=10)

        if not self.determinate:
            self.progress_bar.start(10)

        # Cancel button
        if self.cancellable:
            ttk.Button(self.dialog, text="Cancel", command=self._on_cancel).pack(pady=5)

        # Prevent closing via X button
        self.dialog.protocol("WM_DELETE_WINDOW", self._on_cancel if self.cancellable else lambda: None)

        # Make modal
        self.dialog.grab_set()
        self.dialog.update()

    def update(self, progress: float = None, message: str = None):
        """Update progress and/or message."""
        if self.dialog is None:
            return

        if progress is not None:
            self.progress_var.set(min(100, max(0, progress)))

        if message is not None:
            self.message_var.set(message)

        self.dialog.update()

    def close(self):
        """Close the dialog."""
        if self.dialog:
            if not self.determinate:
                self.progress_bar.stop()
            self.dialog.grab_release()
            self.dialog.destroy()
            self.dialog = None

    def _on_cancel(self):
        """Handle cancel button click."""
        self.cancelled = True
        self.close()


def run_with_progress(
    parent: tk.Tk,
    title: str,
    message: str,
    task_func: Callable,
    on_complete: Callable[[Any], None] = None,
    on_error: Callable[[Exception], None] = None,
    determinate: bool = False
):
    """
    Run a function in a background thread with a progress dialog.

    Args:
        parent: Parent window
        title: Progress dialog title
        message: Progress dialog message
        task_func: Function to run (should accept progress_callback(pct, msg) as kwarg)
        on_complete: Called with result when task completes
        on_error: Called with exception if task fails
        determinate: Whether to show determinate progress bar
    """
    progress = ProgressDialog(parent, title, message, determinate=determinate)
    progress.show()

    result_queue = queue.Queue()

    def worker():
        try:
            def progress_callback(pct=None, msg=None):
                if progress.cancelled:
                    raise InterruptedError("Operation cancelled")
                parent.after(0, lambda: progress.update(pct, msg))

            result = task_func(progress_callback=progress_callback)
            result_queue.put(('success', result))
        except InterruptedError:
            result_queue.put(('cancelled', None))
        except Exception as e:
            result_queue.put(('error', e))

    def check_result():
        try:
            status, data = result_queue.get_nowait()
            progress.close()

            if status == 'success' and on_complete:
                on_complete(data)
            elif status == 'error' and on_error:
                on_error(data)
        except queue.Empty:
            parent.after(100, check_result)

    thread = threading.Thread(target=worker, daemon=True)
    thread.start()
    parent.after(100, check_result)

from Classes.VulnerabilityScorer.loader import BacktestTradeLoader, DataAvailabilityReport
from Classes.VulnerabilityScorer.scoring import (
    VulnerabilityScoreParams,
    VulnerabilityScoringEngine,
    VULNERABILITY_SCORE_PRESETS,
    PresetManager
)
from Classes.VulnerabilityScorer.analyzer import (
    VulnerabilityAnalyzer,
    VulnerabilityAnalysisReport,
    OptimizationObjective,
    CustomObjective,
    OBJECTIVE_PRESETS
)
from Classes.VulnerabilityScorer.features import AVAILABLE_FEATURES, FeatureWeight, FeatureError
from Classes.Config.capital_contention import (
    EnhancedVulnerabilityConfig,
    ENHANCED_FEATURE_DEFINITIONS
)
from Classes.GUI.vulnerability_plots import (
    VulnerabilityChartFrame,
    plot_vulnerability_timeline,
    plot_pl_comparison,
    plot_trade_categorization,
    plot_feature_contributions,
    plot_swap_events_timeline,
    plot_cumulative_pl_impact
)
from Classes.Data.data_loader import DataLoader


class VulnerabilityModelerGUI:
    """Main GUI application for Vulnerability Score Modeler."""

    def __init__(self, root: tk.Tk):
        """Initialize the GUI."""
        self.root = root
        self.root.title("Vulnerability Score Modeler & Optimizer")
        self.root.geometry("1400x900")
        self.root.minsize(1200, 700)

        # Initialize data
        self.data_directory = Path('raw_data')
        self.data_loader: Optional[BacktestTradeLoader] = None
        self.trades: List[Dict[str, Any]] = []
        self.price_data: Dict[str, Any] = {}
        self.current_report: Optional[VulnerabilityAnalysisReport] = None
        self.loaded_backtests: List[str] = []  # Labels for multi-backtest support

        # Parameters
        self.params = VulnerabilityScoreParams()
        self.feature_vars: Dict[str, Dict[str, tk.Variable]] = {}

        # Preset Manager for custom presets
        self.preset_manager = PresetManager()

        # Analysis results
        self.sensitivity_results: Dict[str, Any] = {}
        self.monte_carlo_results: Dict[str, Any] = {}
        self.walk_forward_results: Dict[str, Any] = {}
        self.feature_importance_results: Dict[str, Any] = {}
        self.grouping_results: Dict[str, Any] = {}

        # Create UI
        self._create_menu()
        self._create_main_layout()
        self._load_presets()

    def _create_menu(self):
        """Create menu bar."""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Load Trade Log...", command=self._load_trade_log)
        file_menu.add_command(label="Load Multiple Trade Logs...", command=self._load_multiple_trade_logs)
        file_menu.add_command(label="Set Data Directory...", command=self._set_data_directory)
        file_menu.add_separator()
        file_menu.add_command(label="Export Report...", command=self._export_report)
        file_menu.add_command(label="Export Parameters...", command=self._export_params)
        file_menu.add_command(label="Import Parameters...", command=self._import_params)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)

        # Presets menu
        presets_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Presets", menu=presets_menu)
        presets_menu.add_command(label="Save Current as Preset...", command=self._save_current_preset)
        presets_menu.add_command(label="Manage Presets...", command=self._manage_presets)
        presets_menu.add_separator()
        presets_menu.add_command(label="Import Preset...", command=self._import_preset)
        presets_menu.add_command(label="Export Preset...", command=self._export_preset)

        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="Find Optimal Parameters...", command=self._find_optimal)
        tools_menu.add_command(label="Compare Presets", command=self._compare_presets)
        tools_menu.add_separator()

        # Advanced Analysis submenu
        advanced_menu = tk.Menu(tools_menu, tearoff=0)
        tools_menu.add_cascade(label="Advanced Analysis", menu=advanced_menu)
        advanced_menu.add_command(label="Sensitivity Analysis...", command=self._run_sensitivity_analysis)
        advanced_menu.add_command(label="Walk-Forward Validation...", command=self._run_walk_forward)
        advanced_menu.add_command(label="Feature Importance...", command=self._run_feature_importance)
        advanced_menu.add_command(label="Monte Carlo Simulation...", command=self._run_monte_carlo)
        advanced_menu.add_command(label="Trade Grouping Analysis...", command=self._run_trade_grouping)

        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About", command=self._show_about)

    def _create_main_layout(self):
        """Create main layout with panels."""
        # Main paned window
        main_pane = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_pane.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Left panel - Configuration
        left_frame = ttk.Frame(main_pane)
        main_pane.add(left_frame, weight=1)
        self._create_config_panel(left_frame)

        # Right panel - Results and Charts
        right_frame = ttk.Frame(main_pane)
        main_pane.add(right_frame, weight=2)
        self._create_results_panel(right_frame)

    def _create_config_panel(self, parent: ttk.Frame):
        """Create the configuration panel."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(2, weight=1)

        # Data Loading Section
        data_frame = ttk.LabelFrame(parent, text="Data", padding="10")
        data_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=5)

        ttk.Button(data_frame, text="Load Trade Log", command=self._load_trade_log).pack(fill=tk.X, pady=2)

        self.data_status_var = tk.StringVar(value="No data loaded")
        ttk.Label(data_frame, textvariable=self.data_status_var,
                 font=('TkDefaultFont', 9, 'italic')).pack(fill=tk.X, pady=5)

        # Preset Selection
        preset_frame = ttk.LabelFrame(parent, text="Preset", padding="10")
        preset_frame.grid(row=1, column=0, sticky='ew', padx=5, pady=5)

        self.preset_var = tk.StringVar(value="default")
        preset_combo = ttk.Combobox(preset_frame, textvariable=self.preset_var, state='readonly', width=25)
        preset_combo.pack(fill=tk.X, pady=2)
        preset_combo.bind('<<ComboboxSelected>>', self._on_preset_selected)

        # Parameters Section (scrollable)
        params_frame = ttk.LabelFrame(parent, text="Parameters", padding="5")
        params_frame.grid(row=2, column=0, sticky='nsew', padx=5, pady=5)
        params_frame.columnconfigure(0, weight=1)
        params_frame.rowconfigure(0, weight=1)

        # Canvas for scrolling
        canvas = tk.Canvas(params_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(params_frame, orient="vertical", command=canvas.yview)
        self.params_inner_frame = ttk.Frame(canvas)

        self.params_inner_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=self.params_inner_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.grid(row=0, column=0, sticky='nsew')
        scrollbar.grid(row=0, column=1, sticky='ns')

        self._create_parameter_widgets()

        # Run Button
        run_frame = ttk.Frame(parent, padding="10")
        run_frame.grid(row=3, column=0, sticky='ew', padx=5, pady=5)

        ttk.Button(run_frame, text="Run Analysis", command=self._run_analysis,
                  style='Accent.TButton').pack(fill=tk.X, pady=5)

    def _create_parameter_widgets(self):
        """Create parameter input widgets."""
        frame = self.params_inner_frame

        # Clear existing widgets
        for widget in frame.winfo_children():
            widget.destroy()

        row = 0

        # Core Parameters
        ttk.Label(frame, text="Core Parameters", font=('TkDefaultFont', 10, 'bold')).grid(
            row=row, column=0, columnspan=2, sticky='w', padx=5, pady=(10, 5)
        )
        row += 1

        # Immunity Days
        ttk.Label(frame, text="Immunity Days:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.immunity_var = tk.IntVar(value=self.params.immunity_days)
        ttk.Spinbox(frame, from_=1, to=30, textvariable=self.immunity_var, width=10).grid(
            row=row, column=1, sticky='w', padx=5, pady=2
        )
        row += 1

        # Swap Threshold
        ttk.Label(frame, text="Swap Threshold:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.threshold_var = tk.DoubleVar(value=self.params.swap_threshold)
        ttk.Spinbox(frame, from_=10, to=90, textvariable=self.threshold_var, width=10).grid(
            row=row, column=1, sticky='w', padx=5, pady=2
        )
        row += 1

        # Base Score
        ttk.Label(frame, text="Base Score:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.base_score_var = tk.DoubleVar(value=self.params.base_score)
        ttk.Entry(frame, textvariable=self.base_score_var, width=10, state='readonly').grid(
            row=row, column=1, sticky='w', padx=5, pady=2
        )
        row += 1

        # Feature Weights Section
        ttk.Separator(frame, orient='horizontal').grid(row=row, column=0, columnspan=2, sticky='ew', pady=10)
        row += 1

        ttk.Label(frame, text="Feature Weights", font=('TkDefaultFont', 10, 'bold')).grid(
            row=row, column=0, columnspan=2, sticky='w', padx=5, pady=(5, 5)
        )
        row += 1

        # Create widgets for each feature
        self.feature_vars = {}

        for feature_name, definition in ENHANCED_FEATURE_DEFINITIONS.items():
            self.feature_vars[feature_name] = {}

            # Feature enable checkbox
            enabled_var = tk.BooleanVar(value=False)
            self.feature_vars[feature_name]['enabled'] = enabled_var

            chk = ttk.Checkbutton(frame, text=definition['name'], variable=enabled_var,
                                 command=lambda fn=feature_name: self._on_feature_toggle(fn))
            chk.grid(row=row, column=0, sticky='w', padx=5, pady=2)

            # Weight entry
            weight_var = tk.DoubleVar(value=definition['recommended_weight'])
            self.feature_vars[feature_name]['weight'] = weight_var

            weight_entry = ttk.Entry(frame, textvariable=weight_var, width=8)
            weight_entry.grid(row=row, column=1, sticky='w', padx=5, pady=2)

            row += 1

        # Initialize feature values from current params
        self._load_feature_values()

    def _load_feature_values(self):
        """Load feature values from current params."""
        for feature_name, weight in self.params.features.items():
            if feature_name in self.feature_vars:
                self.feature_vars[feature_name]['enabled'].set(weight.enabled)
                self.feature_vars[feature_name]['weight'].set(weight.weight)

    def _on_feature_toggle(self, feature_name: str):
        """Handle feature enable/disable toggle."""
        pass  # Widget state is tracked by variable

    def _create_results_panel(self, parent: ttk.Frame):
        """Create the results panel with tabs."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Notebook for tabs
        self.notebook = ttk.Notebook(parent)
        self.notebook.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)

        # Summary Tab
        summary_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(summary_frame, text="Summary")
        self._create_summary_tab(summary_frame)

        # Trade Analysis Tab
        trades_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(trades_frame, text="Trade Analysis")
        self._create_trades_tab(trades_frame)

        # Charts Tab
        charts_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(charts_frame, text="Charts")
        self._create_charts_tab(charts_frame)

        # Swap Events Tab
        swaps_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(swaps_frame, text="Swap Events")
        self._create_swaps_tab(swaps_frame)

    def _create_summary_tab(self, parent: ttk.Frame):
        """Create the summary tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Summary text
        self.summary_text = tk.Text(parent, wrap=tk.WORD, font=('Consolas', 10))
        self.summary_text.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=self.summary_text.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.summary_text.configure(yscrollcommand=scrollbar.set)

        self.summary_text.insert('1.0', "No analysis run yet. Load data and click 'Run Analysis'.")
        self.summary_text.configure(state='disabled')

    def _create_trades_tab(self, parent: ttk.Frame):
        """Create the trade analysis tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Treeview for trade analysis
        columns = ('trade_id', 'symbol', 'natural_pl', 'vuln_pl', 'difference', 'category')
        self.trades_tree = ttk.Treeview(parent, columns=columns, show='headings')

        self.trades_tree.heading('trade_id', text='Trade ID')
        self.trades_tree.heading('symbol', text='Symbol')
        self.trades_tree.heading('natural_pl', text='Natural P/L')
        self.trades_tree.heading('vuln_pl', text='Vuln P/L')
        self.trades_tree.heading('difference', text='Difference')
        self.trades_tree.heading('category', text='Category')

        self.trades_tree.column('trade_id', width=80)
        self.trades_tree.column('symbol', width=80)
        self.trades_tree.column('natural_pl', width=100)
        self.trades_tree.column('vuln_pl', width=100)
        self.trades_tree.column('difference', width=100)
        self.trades_tree.column('category', width=120)

        self.trades_tree.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=self.trades_tree.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.trades_tree.configure(yscrollcommand=scrollbar.set)

        # Bind selection to show trade details
        self.trades_tree.bind('<<TreeviewSelect>>', self._on_trade_selected)

    def _create_charts_tab(self, parent: ttk.Frame):
        """Create the charts tab."""
        parent.columnconfigure(0, weight=1)
        parent.columnconfigure(1, weight=1)
        parent.rowconfigure(0, weight=1)
        parent.rowconfigure(1, weight=1)

        # Create chart frames
        self.chart_categorization = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_categorization.grid(row=0, column=0, sticky='nsew', padx=2, pady=2)

        self.chart_cumulative = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_cumulative.grid(row=0, column=1, sticky='nsew', padx=2, pady=2)

        self.chart_pl_comparison = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_pl_comparison.grid(row=1, column=0, sticky='nsew', padx=2, pady=2)

        self.chart_timeline = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_timeline.grid(row=1, column=1, sticky='nsew', padx=2, pady=2)

    def _create_swaps_tab(self, parent: ttk.Frame):
        """Create the swap events tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Treeview for swap events
        columns = ('date', 'symbol', 'score', 'reason', 'days_held', 'pl_diff', 'outcome')
        self.swaps_tree = ttk.Treeview(parent, columns=columns, show='headings')

        self.swaps_tree.heading('date', text='Date')
        self.swaps_tree.heading('symbol', text='Symbol')
        self.swaps_tree.heading('score', text='Score')
        self.swaps_tree.heading('reason', text='Reason')
        self.swaps_tree.heading('days_held', text='Days Early')
        self.swaps_tree.heading('pl_diff', text='P/L Diff')
        self.swaps_tree.heading('outcome', text='Outcome')

        self.swaps_tree.column('date', width=100)
        self.swaps_tree.column('symbol', width=80)
        self.swaps_tree.column('score', width=60)
        self.swaps_tree.column('reason', width=100)
        self.swaps_tree.column('days_held', width=80)
        self.swaps_tree.column('pl_diff', width=80)
        self.swaps_tree.column('outcome', width=100)

        self.swaps_tree.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=self.swaps_tree.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.swaps_tree.configure(yscrollcommand=scrollbar.set)

    def _load_presets(self):
        """Load available presets into combo box."""
        # Get all presets (built-in + custom)
        presets = self.preset_manager.get_preset_names()

        # Find the preset combo in config panel
        for child in self.root.winfo_children():
            self._find_and_update_preset_combo(child, presets)

    def _find_and_update_preset_combo(self, widget, presets):
        """Recursively find and update preset combo."""
        if isinstance(widget, ttk.Combobox):
            if widget.cget('textvariable') == str(self.preset_var):
                widget['values'] = presets
                return
        for child in widget.winfo_children():
            self._find_and_update_preset_combo(child, presets)

    def _on_preset_selected(self, event):
        """Handle preset selection."""
        preset_name = self.preset_var.get()
        preset = self.preset_manager.load_preset(preset_name)
        if preset:
            self.params = preset
            self.immunity_var.set(self.params.immunity_days)
            self.threshold_var.set(self.params.swap_threshold)
            self.base_score_var.set(self.params.base_score)
            self._load_feature_values()

    def _set_data_directory(self):
        """Set the data directory."""
        directory = filedialog.askdirectory(
            title="Select Data Directory",
            initialdir=str(self.data_directory)
        )
        if directory:
            self.data_directory = Path(directory)
            self.data_status_var.set(f"Data dir: {self.data_directory}")

    def _load_trade_log(self):
        """Load a trade log file."""
        filepath = filedialog.askopenfilename(
            title="Select Trade Log",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=str(Path('logs'))
        )

        if not filepath:
            return

        try:
            self.data_loader = BacktestTradeLoader(self.data_directory)
            self.trades, self.price_data, report = self.data_loader.load_from_trade_log(
                Path(filepath)
            )

            if not report.is_valid:
                messagebox.showwarning("Data Warning", report.get_summary())

            self.data_status_var.set(f"Loaded {len(self.trades)} trades")
            messagebox.showinfo("Success", f"Loaded {len(self.trades)} trades from {len(self.price_data)} symbols")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load trade log:\n{str(e)}")
            traceback.print_exc()

    def _get_current_params(self) -> VulnerabilityScoreParams:
        """Get current parameters from UI."""
        features = {}

        for feature_name, vars_dict in self.feature_vars.items():
            features[feature_name] = FeatureWeight(
                enabled=vars_dict['enabled'].get(),
                weight=vars_dict['weight'].get()
            )

        return VulnerabilityScoreParams(
            name="Custom",
            description="User-defined parameters",
            immunity_days=self.immunity_var.get(),
            base_score=self.base_score_var.get(),
            swap_threshold=self.threshold_var.get(),
            features=features
        )

    def _run_analysis(self):
        """Run the vulnerability analysis."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Get current parameters
        params = self._get_current_params()

        # Create progress dialog
        progress = ProgressDialog(
            self.root,
            "Running Analysis",
            "Analyzing trades...",
            determinate=True,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(10, "Initializing analyzer...")

            # Run analysis
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(30, f"Processing {len(self.trades)} trades...")
            self.current_report = analyzer.analyze_backtest(self.trades, self.price_data)

            progress.update(70, "Updating summary...")
            self._update_summary()

            progress.update(80, "Updating tables...")
            self._update_trades_table()
            self._update_swaps_table()

            progress.update(90, "Generating charts...")
            self._update_charts()

            progress.close()

            self.notebook.select(0)  # Switch to summary tab

            messagebox.showinfo("Analysis Complete",
                              f"Analysis complete!\n\n"
                              f"Trades affected: {self.current_report.trades_affected_by_vulnerability}\n"
                              f"P/L difference: ${self.current_report.total_pl_difference:,.2f}")

        except FeatureError as e:
            progress.close()
            messagebox.showerror("Feature Error", str(e))
        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed:\n{str(e)}")
            traceback.print_exc()

    def _update_summary(self):
        """Update the summary tab."""
        if not self.current_report:
            return

        self.summary_text.configure(state='normal')
        self.summary_text.delete('1.0', tk.END)

        # Add summary text
        self.summary_text.insert('1.0', self.current_report.get_summary_text())
        self.summary_text.insert(tk.END, "\n\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, "KEY INSIGHT\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, self.current_report.get_key_insight())
        self.summary_text.insert(tk.END, "\n\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, "RECOMMENDATION\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, self.current_report.get_recommendation())

        self.summary_text.configure(state='disabled')

    def _update_trades_table(self):
        """Update the trades table."""
        # Clear existing items
        for item in self.trades_tree.get_children():
            self.trades_tree.delete(item)

        if not self.current_report:
            return

        for trade in self.current_report.trades:
            self.trades_tree.insert('', 'end', values=(
                trade.trade_id,
                trade.symbol,
                f"${trade.pl_natural_dollars:,.2f}",
                f"${trade.pl_if_exited_at_vulnerability_dollars:,.2f}",
                f"${trade.pl_difference_dollars:+,.2f}",
                trade.benefit_category
            ))

    def _update_charts(self):
        """Update all charts."""
        if not self.current_report:
            return

        # Categorization pie chart
        not_affected = self.current_report.total_trades - self.current_report.trades_affected_by_vulnerability
        plot_trade_categorization(
            self.chart_categorization,
            self.current_report.benefited_count,
            self.current_report.hurt_count,
            self.current_report.neutral_count,
            not_affected
        )

        # Cumulative P/L chart
        trades_dicts = [t.to_dict() for t in self.current_report.trades]
        plot_cumulative_pl_impact(self.chart_cumulative, trades_dicts)

        # P/L comparison chart
        plot_pl_comparison(self.chart_pl_comparison, trades_dicts)

        # Timeline chart for first affected trade
        affected = [t for t in self.current_report.trades if t.would_have_been_swapped]
        if affected and affected[0].daily_timeline:
            timeline_dicts = [r.to_dict() for r in affected[0].daily_timeline]
            params = self._get_current_params()
            plot_vulnerability_timeline(
                self.chart_timeline,
                timeline_dicts,
                params.swap_threshold,
                params.immunity_days,
                f"Timeline: {affected[0].trade_id}"
            )

    def _update_swaps_table(self):
        """Update the swap events table."""
        # Clear existing items
        for item in self.swaps_tree.get_children():
            self.swaps_tree.delete(item)

        if not self.current_report:
            return

        for trade in self.current_report.trades:
            if trade.would_have_been_swapped and trade.first_vulnerable_date:
                self.swaps_tree.insert('', 'end', values=(
                    trade.first_vulnerable_date.strftime('%Y-%m-%d') if hasattr(trade.first_vulnerable_date, 'strftime') else str(trade.first_vulnerable_date),
                    trade.symbol,
                    f"{trade.first_vulnerable_score:.1f}",
                    trade.benefit_category,
                    trade.days_before_vulnerability_exit,
                    f"{trade.pl_difference_pct:+.2f}%",
                    trade.benefit_category
                ))

    def _on_trade_selected(self, event):
        """Handle trade selection in treeview."""
        selection = self.trades_tree.selection()
        if not selection or not self.current_report:
            return

        # Get selected trade
        item = self.trades_tree.item(selection[0])
        trade_id = item['values'][0]

        # Find the trade analysis
        trade = next((t for t in self.current_report.trades if t.trade_id == trade_id), None)
        if trade and trade.daily_timeline:
            # Update timeline chart for selected trade
            timeline_dicts = [r.to_dict() for r in trade.daily_timeline]
            params = self._get_current_params()
            plot_vulnerability_timeline(
                self.chart_timeline,
                timeline_dicts,
                params.swap_threshold,
                params.immunity_days,
                f"Timeline: {trade_id}"
            )

    def _export_report(self):
        """Export the analysis report."""
        if not self.current_report:
            messagebox.showwarning("No Report", "Please run an analysis first.")
            return

        filepath = filedialog.asksaveasfilename(
            title="Export Report",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("CSV files", "*.csv"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            if filepath.endswith('.csv'):
                self.current_report.to_csv(Path(filepath))
            else:
                self.current_report.to_json(Path(filepath))
            messagebox.showinfo("Success", f"Report exported to {filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def _export_params(self):
        """Export current parameters to JSON."""
        filepath = filedialog.asksaveasfilename(
            title="Export Parameters",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            params = self._get_current_params()
            params.to_json(Path(filepath))
            messagebox.showinfo("Success", f"Parameters exported to {filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def _import_params(self):
        """Import parameters from JSON."""
        filepath = filedialog.askopenfilename(
            title="Import Parameters",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            self.params = VulnerabilityScoreParams.from_json(Path(filepath))
            self.immunity_var.set(self.params.immunity_days)
            self.threshold_var.set(self.params.swap_threshold)
            self.base_score_var.set(self.params.base_score)
            self._load_feature_values()
            messagebox.showinfo("Success", "Parameters imported successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Import failed: {str(e)}")

    def _find_optimal(self):
        """Find optimal parameters using grid search."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Show optimization objective dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Find Optimal Parameters")
        dialog.geometry("450x400")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Optimization Settings", font=('TkDefaultFont', 12, 'bold')).pack(pady=10)

        # Objective selection
        obj_frame = ttk.LabelFrame(dialog, text="Optimization Objective", padding=10)
        obj_frame.pack(fill=tk.X, padx=10, pady=5)

        objective_var = tk.StringVar(value="BALANCED")
        objectives = [
            ("BALANCED", "Balance P/L improvement with accuracy"),
            ("MAXIMIZE_PL_DIFF", "Maximize P/L difference"),
            ("MAXIMIZE_ACCURACY", "Maximize decision accuracy"),
            ("CONSERVATIVE", "Prioritize avoiding harm"),
            ("AGGRESSIVE", "Prioritize capturing gains"),
            ("MINIMIZE_FALSE_POSITIVES", "Minimize false positive rate"),
        ]

        for value, desc in objectives:
            ttk.Radiobutton(obj_frame, text=f"{value}: {desc}",
                           variable=objective_var, value=value).pack(anchor='w', pady=2)

        # Parameter ranges
        range_frame = ttk.LabelFrame(dialog, text="Parameter Ranges", padding=10)
        range_frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(range_frame, text="Immunity Days:").grid(row=0, column=0, sticky='w', pady=2)
        imm_min_var = tk.IntVar(value=3)
        imm_max_var = tk.IntVar(value=14)
        ttk.Spinbox(range_frame, from_=1, to=30, textvariable=imm_min_var, width=5).grid(row=0, column=1, padx=2)
        ttk.Label(range_frame, text="to").grid(row=0, column=2)
        ttk.Spinbox(range_frame, from_=1, to=30, textvariable=imm_max_var, width=5).grid(row=0, column=3, padx=2)

        ttk.Label(range_frame, text="Swap Threshold:").grid(row=1, column=0, sticky='w', pady=2)
        thr_min_var = tk.IntVar(value=30)
        thr_max_var = tk.IntVar(value=70)
        ttk.Spinbox(range_frame, from_=10, to=95, textvariable=thr_min_var, width=5).grid(row=1, column=1, padx=2)
        ttk.Label(range_frame, text="to").grid(row=1, column=2)
        ttk.Spinbox(range_frame, from_=10, to=95, textvariable=thr_max_var, width=5).grid(row=1, column=3, padx=2)

        result_var = tk.BooleanVar(value=False)

        def run_optimization():
            result_var.set(True)
            dialog.destroy()

        ttk.Button(dialog, text="Run Optimization", command=run_optimization).pack(pady=20)
        ttk.Button(dialog, text="Cancel", command=dialog.destroy).pack()

        self.root.wait_window(dialog)

        if not result_var.get():
            return

        # Get selected objective
        obj_name = objective_var.get()
        objective = OptimizationObjective[obj_name]

        # Calculate number of configurations
        immunity_range = (imm_min_var.get(), imm_max_var.get())
        threshold_range = (thr_min_var.get(), thr_max_var.get())
        n_immunity = (immunity_range[1] - immunity_range[0]) // 2 + 1
        n_threshold = int((threshold_range[1] - threshold_range[0]) // 10) + 1
        total_configs = n_immunity * n_threshold

        # Create progress dialog
        progress = ProgressDialog(
            self.root,
            "Finding Optimal Parameters",
            f"Testing {total_configs} configurations...",
            determinate=True,
            cancellable=True
        )
        progress.show()

        try:
            progress.update(5, "Initializing optimizer...")
            analyzer = VulnerabilityAnalyzer()

            # Run optimization with progress tracking
            config_count = [0]  # Use list for closure

            def run_optimization():
                best_params = None
                best_report = None
                best_score = float('-inf')
                all_results = []

                from Classes.VulnerabilityScorer.analyzer import get_objective_scorer

                scorer = get_objective_scorer(objective)

                for immunity in range(immunity_range[0], immunity_range[1] + 1, 2):
                    threshold = threshold_range[0]
                    while threshold <= threshold_range[1]:
                        if progress.cancelled:
                            return None, None, {'search_space_size': config_count[0]}

                        config_count[0] += 1
                        pct = 5 + (config_count[0] / total_configs) * 85
                        progress.update(pct, f"Testing config {config_count[0]}/{total_configs}: immunity={immunity}, threshold={threshold}")

                        params = VulnerabilityScoreParams(
                            name=f"Grid_{immunity}d_{threshold:.0f}t",
                            immunity_days=immunity,
                            swap_threshold=threshold
                        )

                        try:
                            analyzer.update_params(params)
                            report = analyzer.analyze_backtest(self.trades, self.price_data)
                            score, passes = scorer(report)
                            all_results.append({'params': params, 'report': report, 'score': score, 'passes_constraints': passes})

                            if passes and score > best_score:
                                best_score = score
                                best_params = params
                                best_report = report
                        except Exception:
                            pass

                        threshold += 10

                if best_params is None and all_results:
                    valid = [r for r in all_results if r['report'] is not None]
                    if valid:
                        best_result = max(valid, key=lambda r: r['score'])
                        best_params = best_result['params']
                        best_report = best_result['report']

                return best_params, best_report, {'search_space_size': len(all_results), 'best_score': best_score}

            best_params, best_report, details = run_optimization()

            if progress.cancelled:
                progress.close()
                return

            progress.update(95, "Updating UI...")

            # Update UI with best params
            if best_params:
                self.params = best_params
                self.immunity_var.set(best_params.immunity_days)
                self.threshold_var.set(best_params.swap_threshold)
                self._load_feature_values()

            if best_report:
                self.current_report = best_report
                self._update_summary()
                self._update_trades_table()
                self._update_charts()
                self._update_swaps_table()

            progress.close()

            if best_params and best_report:
                messagebox.showinfo(
                    "Optimization Complete",
                    f"Optimal parameters found:\n\n"
                    f"Objective: {obj_name}\n"
                    f"Configurations Tested: {details['search_space_size']}\n"
                    f"Immunity Days: {best_params.immunity_days}\n"
                    f"Swap Threshold: {best_params.swap_threshold}\n"
                    f"P/L Improvement: ${best_report.total_pl_difference:,.2f}\n"
                    f"Accuracy: {best_report.accuracy*100:.1f}%"
                )
            else:
                messagebox.showwarning("Optimization", "No valid configuration found.")

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Optimization failed: {str(e)}")
            traceback.print_exc()

    def _compare_presets(self):
        """Compare all presets."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        n_presets = len(VULNERABILITY_SCORE_PRESETS)
        progress = ProgressDialog(
            self.root,
            "Comparing Presets",
            f"Testing {n_presets} presets...",
            determinate=True,
            cancellable=False
        )
        progress.show()

        try:
            results = []
            for i, (name, params) in enumerate(VULNERABILITY_SCORE_PRESETS.items()):
                pct = (i / n_presets) * 100
                progress.update(pct, f"Testing preset: {name}...")

                analyzer = VulnerabilityAnalyzer(params)
                report = analyzer.analyze_backtest(self.trades, self.price_data)
                results.append({
                    'name': name,
                    'affected': report.trades_affected_by_vulnerability,
                    'pl_diff': report.total_pl_difference,
                    'accuracy': report.accuracy
                })

            progress.close()

            # Show comparison
            comparison_text = "Preset Comparison:\n\n"
            comparison_text += f"{'Preset':<20} {'Affected':<10} {'P/L Diff':<15} {'Accuracy':<10}\n"
            comparison_text += "-" * 55 + "\n"

            for r in results:
                comparison_text += f"{r['name']:<20} {r['affected']:<10} ${r['pl_diff']:<14,.2f} {r['accuracy']*100:.1f}%\n"

            # Show in a dialog
            dialog = tk.Toplevel(self.root)
            dialog.title("Preset Comparison")
            dialog.geometry("500x300")

            text = tk.Text(dialog, font=('Consolas', 10))
            text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            text.insert('1.0', comparison_text)
            text.configure(state='disabled')

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Comparison failed: {str(e)}")
            traceback.print_exc()

    def _show_about(self):
        """Show about dialog."""
        messagebox.showinfo(
            "About",
            "Vulnerability Score Modeler & Optimizer\n\n"
            "A tool for analyzing and optimizing vulnerability score parameters "
            "for portfolio backtesting.\n\n"
            "Features:\n"
            "- Multi-backtest loading\n"
            "- Custom optimization objectives\n"
            "- Custom presets\n"
            "- Sensitivity analysis\n"
            "- Walk-forward validation\n"
            "- Feature importance\n"
            "- Monte Carlo simulation\n"
            "- Trade grouping analysis\n\n"
            "Part of the BackTesting Framework"
        )

    # =========================================================================
    # NEW FEATURES
    # =========================================================================

    def _load_multiple_trade_logs(self):
        """Load multiple trade log files."""
        filepaths = filedialog.askopenfilenames(
            title="Select Trade Logs (multiple)",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=str(Path('logs'))
        )

        if not filepaths:
            return

        try:
            self.data_loader = BacktestTradeLoader(self.data_directory)
            paths = [Path(fp) for fp in filepaths]
            labels = [p.stem for p in paths]

            self.trades, self.price_data, report = self.data_loader.load_multiple_trade_logs(
                paths, labels
            )
            self.loaded_backtests = labels

            if report.warnings:
                messagebox.showwarning("Data Warning", report.get_summary())

            self.data_status_var.set(f"Loaded {len(self.trades)} trades from {len(labels)} backtests")
            messagebox.showinfo(
                "Success",
                f"Loaded {len(self.trades)} trades from {len(labels)} backtests:\n"
                + "\n".join(f"- {l}" for l in labels)
            )

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load trade logs:\n{str(e)}")
            traceback.print_exc()

    def _save_current_preset(self):
        """Save current parameters as a custom preset."""
        name = simpledialog.askstring(
            "Save Preset",
            "Enter a name for this preset:",
            parent=self.root
        )

        if not name:
            return

        description = simpledialog.askstring(
            "Save Preset",
            "Enter a description (optional):",
            parent=self.root
        ) or ""

        try:
            params = self._get_current_params()
            params.name = name
            params.description = description

            filepath = self.preset_manager.save_preset(params, overwrite=False)
            self._load_presets()  # Refresh preset list

            messagebox.showinfo("Success", f"Preset '{name}' saved to {filepath}")

        except ValueError as e:
            if "already exists" in str(e):
                if messagebox.askyesno("Overwrite?", f"Preset '{name}' exists. Overwrite?"):
                    filepath = self.preset_manager.save_preset(params, overwrite=True)
                    self._load_presets()
                    messagebox.showinfo("Success", f"Preset '{name}' updated.")
            else:
                messagebox.showerror("Error", str(e))
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save preset: {str(e)}")

    def _manage_presets(self):
        """Open preset management dialog."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Manage Presets")
        dialog.geometry("500x400")
        dialog.transient(self.root)

        # Preset list
        list_frame = ttk.LabelFrame(dialog, text="Custom Presets", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        preset_listbox = tk.Listbox(list_frame, height=15)
        preset_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=preset_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        preset_listbox.configure(yscrollcommand=scrollbar.set)

        # Populate list
        custom_presets = self.preset_manager.get_custom_presets()
        for name in custom_presets.keys():
            preset_listbox.insert(tk.END, name)

        # Buttons
        btn_frame = ttk.Frame(dialog, padding=10)
        btn_frame.pack(fill=tk.X)

        def delete_selected():
            selection = preset_listbox.curselection()
            if not selection:
                return
            name = preset_listbox.get(selection[0])
            if messagebox.askyesno("Delete?", f"Delete preset '{name}'?"):
                try:
                    self.preset_manager.delete_preset(name)
                    preset_listbox.delete(selection[0])
                    self._load_presets()
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        def rename_selected():
            selection = preset_listbox.curselection()
            if not selection:
                return
            old_name = preset_listbox.get(selection[0])
            new_name = simpledialog.askstring("Rename", f"New name for '{old_name}':")
            if new_name:
                try:
                    self.preset_manager.rename_preset(old_name, new_name)
                    preset_listbox.delete(selection[0])
                    preset_listbox.insert(selection[0], new_name)
                    self._load_presets()
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        def duplicate_selected():
            selection = preset_listbox.curselection()
            if not selection:
                return
            source_name = preset_listbox.get(selection[0])
            new_name = simpledialog.askstring("Duplicate", f"Name for copy of '{source_name}':")
            if new_name:
                try:
                    self.preset_manager.duplicate_preset(source_name, new_name)
                    preset_listbox.insert(tk.END, new_name)
                    self._load_presets()
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        ttk.Button(btn_frame, text="Delete", command=delete_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Rename", command=rename_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Duplicate", command=duplicate_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Close", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)

    def _import_preset(self):
        """Import a preset from a JSON file."""
        filepath = filedialog.askopenfilename(
            title="Import Preset",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            preset = self.preset_manager.import_preset(Path(filepath))
            self._load_presets()
            messagebox.showinfo("Success", f"Imported preset '{preset.name}'")
        except Exception as e:
            messagebox.showerror("Error", f"Import failed: {str(e)}")

    def _export_preset(self):
        """Export a preset to a JSON file."""
        # Select preset to export
        presets = self.preset_manager.get_preset_names()
        dialog = tk.Toplevel(self.root)
        dialog.title("Export Preset")
        dialog.geometry("300x150")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Select preset to export:").pack(pady=10)

        preset_var = tk.StringVar(value=presets[0] if presets else "")
        combo = ttk.Combobox(dialog, textvariable=preset_var, values=presets, state='readonly', width=30)
        combo.pack(pady=5)

        def do_export():
            name = preset_var.get()
            dialog.destroy()

            filepath = filedialog.asksaveasfilename(
                title=f"Export {name}",
                defaultextension=".json",
                initialfile=f"{name.replace(' ', '_')}.json",
                filetypes=[("JSON files", "*.json")]
            )
            if filepath:
                try:
                    self.preset_manager.export_preset(name, Path(filepath))
                    messagebox.showinfo("Success", f"Exported to {filepath}")
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        ttk.Button(dialog, text="Export", command=do_export).pack(pady=10)

    def _run_sensitivity_analysis(self):
        """Run sensitivity analysis on parameters."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Dialog for sensitivity settings
        dialog = tk.Toplevel(self.root)
        dialog.title("Sensitivity Analysis")
        dialog.geometry("400x300")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Parameter to Analyze:").pack(pady=10)

        param_var = tk.StringVar(value="immunity_days")
        for param in ["immunity_days", "swap_threshold"]:
            ttk.Radiobutton(dialog, text=param, variable=param_var, value=param).pack(anchor='w', padx=20)

        ttk.Label(dialog, text="Metric to Track:").pack(pady=10)

        metric_var = tk.StringVar(value="total_pl_difference")
        for metric in ["total_pl_difference", "accuracy", "false_positive_rate"]:
            ttk.Radiobutton(dialog, text=metric, variable=metric_var, value=metric).pack(anchor='w', padx=20)

        result_var = tk.BooleanVar(value=False)

        def run():
            result_var.set(True)
            dialog.destroy()

        ttk.Button(dialog, text="Run Analysis", command=run).pack(pady=20)

        self.root.wait_window(dialog)

        if not result_var.get():
            return

        progress = ProgressDialog(
            self.root,
            "Sensitivity Analysis",
            "Running sensitivity analysis...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Analyzing {param_var.get()} sensitivity...")
            results = analyzer.run_sensitivity_analysis(
                self.trades, self.price_data,
                base_params=params,
                param_name=param_var.get(),
                metric=metric_var.get()
            )

            self.sensitivity_results = results
            progress.close()

            # Show results
            self._show_sensitivity_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")
            traceback.print_exc()

    def _show_sensitivity_results(self, results: Dict[str, Any]):
        """Display sensitivity analysis results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Sensitivity Analysis Results")
        dialog.geometry("600x500")

        # Summary
        summary = f"""
Sensitivity Analysis Results
{'='*40}

Parameter: {results.get('param_name', 'N/A')}
Metric: {results.get('metric_name', 'N/A')}

Best Value: {results.get('best_value', 'N/A')}
Best Metric: {results.get('best_metric', 'N/A'):.4f}

Sensitivity Score: {results.get('sensitivity_score', 0):.4f}
(Higher = more sensitive to parameter changes)

Values Tested: {len(results.get('param_values', []))}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        # Add table of results
        if 'param_values' in results and 'metric_values' in results:
            text.insert(tk.END, f"\n{'Value':<15} {'Metric':<20}\n")
            text.insert(tk.END, "-" * 35 + "\n")
            for pv, mv in zip(results['param_values'], results['metric_values']):
                text.insert(tk.END, f"{pv:<15} {mv:<20.4f}\n")

        text.configure(state='disabled')

    def _run_walk_forward(self):
        """Run walk-forward validation."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        if len(self.trades) < 25:
            messagebox.showwarning("Insufficient Data",
                                  f"Need at least 25 trades for walk-forward validation.\nYou have {len(self.trades)}.")
            return

        n_folds = simpledialog.askinteger(
            "Walk-Forward Validation",
            "Number of folds (3-10):",
            initialvalue=5, minvalue=3, maxvalue=10,
            parent=self.root
        )

        if not n_folds:
            return

        progress = ProgressDialog(
            self.root,
            "Walk-Forward Validation",
            f"Running {n_folds}-fold validation...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Processing {n_folds} folds (this may take a while)...")
            results = analyzer.run_walk_forward_validation(
                self.trades, self.price_data,
                n_folds=n_folds
            )

            self.walk_forward_results = results
            progress.close()

            # Show results
            self._show_walk_forward_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Validation failed: {str(e)}")
            traceback.print_exc()

    def _show_walk_forward_results(self, results: Dict[str, Any]):
        """Display walk-forward validation results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Walk-Forward Validation Results")
        dialog.geometry("700x500")

        overall = results.get('overall_metrics', {})
        summary = f"""
Walk-Forward Validation Results
{'='*50}

Number of Folds: {results.get('n_folds', 0)}
Parameter Stability: {results.get('parameter_stability', 0):.2%}

Out-of-Sample Performance:
  Average P/L: ${overall.get('avg_out_of_sample_pl', 0):,.2f}
  Average Accuracy: {overall.get('avg_out_of_sample_accuracy', 0):.2%}
  Overfitting Rate: {overall.get('overfitting_rate', 0):.2%}

Recommendation: {results.get('recommendation', 'N/A')}

Per-Fold Results:
{'='*50}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        for fold in results.get('fold_results', []):
            if 'error' in fold:
                text.insert(tk.END, f"\nFold {fold['fold']}: Error - {fold['error']}\n")
            else:
                text.insert(tk.END, f"\nFold {fold['fold']}:\n")
                text.insert(tk.END, f"  Train: {fold['train_trades']} trades, P/L: ${fold['train_pl_diff']:,.2f}\n")
                text.insert(tk.END, f"  Test: {fold['test_trades']} trades, P/L: ${fold['test_pl_diff']:,.2f}\n")
                text.insert(tk.END, f"  Overfitting: {'Yes' if fold.get('is_overfitting') else 'No'}\n")

        text.configure(state='disabled')

    def _run_feature_importance(self):
        """Run feature importance analysis."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        progress = ProgressDialog(
            self.root,
            "Feature Importance",
            "Calculating feature importance...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message="Running ablation analysis for each feature...")
            results = analyzer.calculate_feature_importance(
                self.trades, self.price_data,
                method='ablation'
            )

            self.feature_importance_results = results
            progress.close()

            # Show results
            self._show_feature_importance_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")
            traceback.print_exc()

    def _show_feature_importance_results(self, results: Dict[str, Any]):
        """Display feature importance results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Feature Importance Results")
        dialog.geometry("500x400")

        summary = f"""
Feature Importance Analysis
{'='*40}

Method: {results.get('method', 'ablation')}
Baseline P/L: ${results.get('baseline_pl', 0):,.2f}

Most Important: {results.get('most_important', 'N/A')}
Least Important: {results.get('least_important', 'N/A')}

Feature Rankings:
{'='*40}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        for feature, score in results.get('ranking', []):
            bar = '' * int(score / 10) + '' * (10 - int(score / 10))
            text.insert(tk.END, f"{feature:<25} {bar} {score:.1f}%\n")

        text.configure(state='disabled')

    def _run_monte_carlo(self):
        """Run Monte Carlo simulation."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        if len(self.trades) < 5:
            messagebox.showwarning("Insufficient Data", "Need at least 5 trades for Monte Carlo.")
            return

        n_sims = simpledialog.askinteger(
            "Monte Carlo Simulation",
            "Number of simulations (100-10000):",
            initialvalue=1000, minvalue=100, maxvalue=10000,
            parent=self.root
        )

        if not n_sims:
            return

        progress = ProgressDialog(
            self.root,
            "Monte Carlo Simulation",
            f"Running {n_sims} simulations...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Running {n_sims} simulations (this may take a while)...")
            results = analyzer.run_monte_carlo_analysis(
                self.trades, self.price_data,
                n_simulations=n_sims
            )

            self.monte_carlo_results = results
            progress.close()

            # Show results
            self._show_monte_carlo_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Simulation failed: {str(e)}")
            traceback.print_exc()

    def _show_monte_carlo_results(self, results: Dict[str, Any]):
        """Display Monte Carlo simulation results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Monte Carlo Simulation Results")
        dialog.geometry("500x450")

        stats = results.get('statistics', {})
        ci = results.get('confidence_intervals', {})

        summary = f"""
Monte Carlo Simulation Results
{'='*40}

Simulations Run: {results.get('n_simulations', 0)}

P/L Distribution Statistics:
  Mean: ${stats.get('mean', 0):,.2f}
  Median: ${stats.get('median', 0):,.2f}
  Std Dev: ${stats.get('std', 0):,.2f}
  Min: ${stats.get('min', 0):,.2f}
  Max: ${stats.get('max', 0):,.2f}

Confidence Intervals:
  5th percentile: ${ci.get('5%', 0):,.2f}
  25th percentile: ${ci.get('25%', 0):,.2f}
  50th percentile: ${ci.get('50%', 0):,.2f}
  75th percentile: ${ci.get('75%', 0):,.2f}
  95th percentile: ${ci.get('95%', 0):,.2f}

Probabilities:
  Positive P/L Impact: {results.get('probability_positive', 0):.1%}
  Significant Gain (>$100): {results.get('probability_significant_gain', 0):.1%}
  Significant Loss (<-$100): {results.get('probability_significant_loss', 0):.1%}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)
        text.configure(state='disabled')

    def _run_trade_grouping(self):
        """Run trade grouping analysis."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Dialog for grouping criteria
        dialog = tk.Toplevel(self.root)
        dialog.title("Trade Grouping Analysis")
        dialog.geometry("350x250")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Group Trades By:", font=('TkDefaultFont', 10, 'bold')).pack(pady=10)

        criteria_var = tk.StringVar(value="symbol")
        criteria_options = [
            ("symbol", "By Security Symbol"),
            ("month", "By Entry Month"),
            ("quarter", "By Entry Quarter"),
            ("year", "By Entry Year"),
            ("duration", "By Trade Duration"),
            ("pl_bucket", "By P/L Range"),
        ]

        for value, label in criteria_options:
            ttk.Radiobutton(dialog, text=label, variable=criteria_var, value=value).pack(anchor='w', padx=20)

        result_var = tk.BooleanVar(value=False)

        def run():
            result_var.set(True)
            dialog.destroy()

        ttk.Button(dialog, text="Run Analysis", command=run).pack(pady=15)

        self.root.wait_window(dialog)

        if not result_var.get():
            return

        progress = ProgressDialog(
            self.root,
            "Trade Grouping Analysis",
            f"Analyzing trades by {criteria_var.get()}...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Grouping and analyzing trades by {criteria_var.get()}...")
            results = analyzer.run_trade_grouping_analysis(
                self.trades, self.price_data,
                grouping_criteria=criteria_var.get()
            )

            self.grouping_results = results
            progress.close()

            # Show results
            self._show_grouping_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")
            traceback.print_exc()

    def _show_grouping_results(self, results: Dict[str, Any]):
        """Display trade grouping analysis results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Trade Grouping Analysis Results")
        dialog.geometry("700x500")

        best = results.get('best_group', {})
        worst = results.get('worst_group', {})

        summary = f"""
Trade Grouping Analysis Results
{'='*50}

Grouping Criteria: {results.get('grouping_criteria', 'N/A')}
Number of Groups: {results.get('n_groups', 0)}

Best Group: {best.get('group', 'N/A')}
  Trades: {best.get('n_trades', 0)}
  P/L Difference: ${best.get('pl_difference', 0):,.2f}

Worst Group: {worst.get('group', 'N/A')}
  Trades: {worst.get('n_trades', 0)}
  P/L Difference: ${worst.get('pl_difference', 0):,.2f}

Recommendation: {results.get('recommendation', 'N/A')}

Group Summary:
{'='*50}
{'Group':<20} {'Trades':<8} {'P/L Diff':<15} {'Accuracy':<10}
{'-'*53}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        for group in results.get('summary', []):
            if 'error' not in group:
                text.insert(tk.END,
                    f"{group['group']:<20} {group['n_trades']:<8} "
                    f"${group['pl_difference']:<14,.2f} {group['accuracy']:.1%}\n"
                )

        text.configure(state='disabled')


def main():
    """Main entry point."""
    root = tk.Tk()
    style = ttk.Style()
    style.theme_use('clam')

    app = VulnerabilityModelerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
