"""
Vulnerability Score Modeler & Optimizer GUI.

A graphical user interface for analyzing and optimizing vulnerability score parameters.

This tool allows users to:
1. Load completed backtest results (single or multiple)
2. Configure vulnerability score parameters
3. Run simulations to see swap impact
4. Visualize results and optimize parameters
5. Export/import configurations and presets
6. Run advanced analysis (sensitivity, walk-forward, Monte Carlo, etc.)

Usage:
    python vulnerability_gui.py
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any, Optional, Callable
import json
import traceback
import threading
import queue


class ProgressDialog:
    """
    A progress dialog for long-running operations.

    Usage:
        progress = ProgressDialog(root, "Running Analysis", "Processing trades...")
        progress.show()

        # Update progress as you go
        for i, item in enumerate(items):
            progress.update(i / len(items) * 100, f"Processing {i+1}/{len(items)}")
            if progress.cancelled:
                break
            # Do work...

        progress.close()
    """

    def __init__(
        self,
        parent: tk.Tk,
        title: str = "Please Wait",
        message: str = "Processing...",
        determinate: bool = True,
        cancellable: bool = True
    ):
        """
        Initialize progress dialog.

        Args:
            parent: Parent window
            title: Dialog title
            message: Initial message
            determinate: If True, show percentage. If False, show indeterminate progress.
            cancellable: If True, show cancel button
        """
        self.parent = parent
        self.cancelled = False
        self.dialog = None
        self.progress_var = tk.DoubleVar(value=0)
        self.message_var = tk.StringVar(value=message)
        self.determinate = determinate
        self.cancellable = cancellable
        self.title = title

    def show(self):
        """Display the progress dialog."""
        self.dialog = tk.Toplevel(self.parent)
        self.dialog.title(self.title)
        self.dialog.geometry("400x120")
        self.dialog.transient(self.parent)
        self.dialog.resizable(False, False)

        # Center on parent
        self.dialog.update_idletasks()
        x = self.parent.winfo_x() + (self.parent.winfo_width() - 400) // 2
        y = self.parent.winfo_y() + (self.parent.winfo_height() - 120) // 2
        self.dialog.geometry(f"+{x}+{y}")

        # Message
        ttk.Label(self.dialog, textvariable=self.message_var, wraplength=380).pack(pady=(15, 5))

        # Progress bar
        mode = 'determinate' if self.determinate else 'indeterminate'
        self.progress_bar = ttk.Progressbar(
            self.dialog,
            variable=self.progress_var,
            maximum=100,
            mode=mode,
            length=350
        )
        self.progress_bar.pack(pady=10)

        if not self.determinate:
            self.progress_bar.start(10)

        # Cancel button
        if self.cancellable:
            ttk.Button(self.dialog, text="Cancel", command=self._on_cancel).pack(pady=5)

        # Prevent closing via X button
        self.dialog.protocol("WM_DELETE_WINDOW", self._on_cancel if self.cancellable else lambda: None)

        # Make modal
        self.dialog.grab_set()
        self.dialog.update()

    def update(self, progress: float = None, message: str = None):
        """Update progress and/or message."""
        if self.dialog is None:
            return

        if progress is not None:
            self.progress_var.set(min(100, max(0, progress)))

        if message is not None:
            self.message_var.set(message)

        self.dialog.update()

    def close(self):
        """Close the dialog."""
        if self.dialog:
            if not self.determinate:
                self.progress_bar.stop()
            self.dialog.grab_release()
            self.dialog.destroy()
            self.dialog = None

    def _on_cancel(self):
        """Handle cancel button click."""
        self.cancelled = True
        self.close()


def run_with_progress(
    parent: tk.Tk,
    title: str,
    message: str,
    task_func: Callable,
    on_complete: Callable[[Any], None] = None,
    on_error: Callable[[Exception], None] = None,
    determinate: bool = False
):
    """
    Run a function in a background thread with a progress dialog.

    Args:
        parent: Parent window
        title: Progress dialog title
        message: Progress dialog message
        task_func: Function to run (should accept progress_callback(pct, msg) as kwarg)
        on_complete: Called with result when task completes
        on_error: Called with exception if task fails
        determinate: Whether to show determinate progress bar
    """
    progress = ProgressDialog(parent, title, message, determinate=determinate)
    progress.show()

    result_queue = queue.Queue()

    def worker():
        try:
            def progress_callback(pct=None, msg=None):
                if progress.cancelled:
                    raise InterruptedError("Operation cancelled")
                parent.after(0, lambda: progress.update(pct, msg))

            result = task_func(progress_callback=progress_callback)
            result_queue.put(('success', result))
        except InterruptedError:
            result_queue.put(('cancelled', None))
        except Exception as e:
            result_queue.put(('error', e))

    def check_result():
        try:
            status, data = result_queue.get_nowait()
            progress.close()

            if status == 'success' and on_complete:
                on_complete(data)
            elif status == 'error' and on_error:
                on_error(data)
        except queue.Empty:
            parent.after(100, check_result)

    thread = threading.Thread(target=worker, daemon=True)
    thread.start()
    parent.after(100, check_result)

from Classes.VulnerabilityScorer.loader import BacktestTradeLoader, DataAvailabilityReport
from Classes.VulnerabilityScorer.scoring import (
    VulnerabilityScoreParams,
    VulnerabilityScoringEngine,
    VULNERABILITY_SCORE_PRESETS,
    PresetManager
)
from Classes.VulnerabilityScorer.analyzer import (
    VulnerabilityAnalyzer,
    VulnerabilityAnalysisReport,
    OptimizationObjective,
    CustomObjective,
    OBJECTIVE_PRESETS
)
from Classes.VulnerabilityScorer.features import AVAILABLE_FEATURES, FeatureWeight, FeatureError
from Classes.Config.capital_contention import (
    EnhancedVulnerabilityConfig,
    ENHANCED_FEATURE_DEFINITIONS,
    FEATURE_PARAMETER_DEFINITIONS,
    VULNERABILITY_CORE_PARAM_DEFINITIONS
)
from Classes.GUI.vulnerability_plots import (
    VulnerabilityChartFrame,
    plot_vulnerability_timeline,
    plot_pl_comparison,
    plot_trade_categorization,
    plot_feature_contributions,
    plot_swap_events_timeline,
    plot_cumulative_pl_impact
)
from Classes.Data.data_loader import DataLoader


class VulnerabilityModelerGUI:
    """Main GUI application for Vulnerability Score Modeler."""

    def __init__(self, root: tk.Tk):
        """Initialize the GUI."""
        self.root = root
        self.root.title("Vulnerability Score Modeler & Optimizer")
        self.root.geometry("1400x900")
        self.root.minsize(1200, 700)

        # Initialize data
        self.data_directory = Path('raw_data')
        self.data_loader: Optional[BacktestTradeLoader] = None
        self.trades: List[Dict[str, Any]] = []
        self.price_data: Dict[str, Any] = {}
        self.current_report: Optional[VulnerabilityAnalysisReport] = None
        self.loaded_backtests: List[str] = []  # Labels for multi-backtest support

        # Parameters
        self.params = VulnerabilityScoreParams()
        self.feature_vars: Dict[str, Dict[str, tk.Variable]] = {}

        # Preset Manager for custom presets
        self.preset_manager = PresetManager()

        # Analysis results
        self.sensitivity_results: Dict[str, Any] = {}
        self.monte_carlo_results: Dict[str, Any] = {}
        self.walk_forward_results: Dict[str, Any] = {}
        self.feature_importance_results: Dict[str, Any] = {}
        self.grouping_results: Dict[str, Any] = {}

        # Portfolio simulation results
        self.portfolio_fifo_result = None
        self.portfolio_vuln_result = None

        # Create UI
        self._create_menu()
        self._create_main_layout()
        self._load_presets()

    def _create_menu(self):
        """Create menu bar."""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="Load Trade Log...", command=self._load_trade_log)
        file_menu.add_command(label="Load Multiple Trade Logs...", command=self._load_multiple_trade_logs)
        file_menu.add_command(label="Set Data Directory...", command=self._set_data_directory)
        file_menu.add_separator()
        file_menu.add_command(label="Export Report...", command=self._export_report)
        file_menu.add_command(label="Export Parameters...", command=self._export_params)
        file_menu.add_command(label="Import Parameters...", command=self._import_params)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)

        # Presets menu
        presets_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Presets", menu=presets_menu)
        presets_menu.add_command(label="Save Current as Preset...", command=self._save_current_preset)
        presets_menu.add_command(label="Manage Presets...", command=self._manage_presets)
        presets_menu.add_separator()
        presets_menu.add_command(label="Import Preset...", command=self._import_preset)
        presets_menu.add_command(label="Export Preset...", command=self._export_preset)

        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="Find Optimal Parameters...", command=self._find_optimal)
        tools_menu.add_command(label="Compare Presets", command=self._compare_presets)
        tools_menu.add_separator()

        # Advanced Analysis submenu
        advanced_menu = tk.Menu(tools_menu, tearoff=0)
        tools_menu.add_cascade(label="Advanced Analysis", menu=advanced_menu)
        advanced_menu.add_command(label="Sensitivity Analysis...", command=self._run_sensitivity_analysis)
        advanced_menu.add_command(label="Walk-Forward Validation...", command=self._run_walk_forward)
        advanced_menu.add_command(label="Feature Importance...", command=self._run_feature_importance)
        advanced_menu.add_command(label="Monte Carlo Simulation...", command=self._run_monte_carlo)
        advanced_menu.add_command(label="Trade Grouping Analysis...", command=self._run_trade_grouping)

        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About", command=self._show_about)

    def _create_main_layout(self):
        """Create main layout with panels."""
        # Main paned window
        main_pane = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_pane.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Left panel - Configuration
        left_frame = ttk.Frame(main_pane)
        main_pane.add(left_frame, weight=1)
        self._create_config_panel(left_frame)

        # Right panel - Results and Charts
        right_frame = ttk.Frame(main_pane)
        main_pane.add(right_frame, weight=2)
        self._create_results_panel(right_frame)

    def _create_config_panel(self, parent: ttk.Frame):
        """Create the configuration panel."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(2, weight=1)

        # Data Loading Section
        data_frame = ttk.LabelFrame(parent, text="Data", padding="10")
        data_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=5)

        ttk.Button(data_frame, text="Load Trade Log", command=self._load_trade_log).pack(fill=tk.X, pady=2)

        self.data_status_var = tk.StringVar(value="No data loaded")
        ttk.Label(data_frame, textvariable=self.data_status_var,
                 font=('TkDefaultFont', 9, 'italic')).pack(fill=tk.X, pady=5)

        # Preset Selection
        preset_frame = ttk.LabelFrame(parent, text="Preset", padding="10")
        preset_frame.grid(row=1, column=0, sticky='ew', padx=5, pady=5)

        self.preset_var = tk.StringVar(value="default")
        preset_combo = ttk.Combobox(preset_frame, textvariable=self.preset_var, state='readonly', width=25)
        preset_combo.pack(fill=tk.X, pady=2)
        preset_combo.bind('<<ComboboxSelected>>', self._on_preset_selected)

        # Parameters Section (scrollable)
        params_frame = ttk.LabelFrame(parent, text="Parameters", padding="5")
        params_frame.grid(row=2, column=0, sticky='nsew', padx=5, pady=5)
        params_frame.columnconfigure(0, weight=1)
        params_frame.rowconfigure(0, weight=1)

        # Canvas for scrolling
        canvas = tk.Canvas(params_frame, highlightthickness=0)
        scrollbar = ttk.Scrollbar(params_frame, orient="vertical", command=canvas.yview)
        self.params_inner_frame = ttk.Frame(canvas)

        self.params_inner_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=self.params_inner_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.grid(row=0, column=0, sticky='nsew')
        scrollbar.grid(row=0, column=1, sticky='ns')

        self._create_parameter_widgets()

        # Run Button
        run_frame = ttk.Frame(parent, padding="10")
        run_frame.grid(row=3, column=0, sticky='ew', padx=5, pady=5)

        ttk.Button(run_frame, text="Run Analysis", command=self._run_analysis,
                  style='Accent.TButton').pack(fill=tk.X, pady=5)

    def _create_parameter_widgets(self):
        """Create parameter input widgets."""
        frame = self.params_inner_frame

        # Clear existing widgets
        for widget in frame.winfo_children():
            widget.destroy()

        row = 0

        # Core Parameters
        ttk.Label(frame, text="Core Parameters", font=('TkDefaultFont', 10, 'bold')).grid(
            row=row, column=0, columnspan=3, sticky='w', padx=5, pady=(10, 5)
        )
        row += 1

        # Get parameter definitions for hints
        imm_def = VULNERABILITY_CORE_PARAM_DEFINITIONS['immunity_days']
        thresh_def = VULNERABILITY_CORE_PARAM_DEFINITIONS['swap_threshold']
        base_def = VULNERABILITY_CORE_PARAM_DEFINITIONS['base_score']

        # Immunity Days
        ttk.Label(frame, text="Immunity Days:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.immunity_var = tk.IntVar(value=self.params.immunity_days)
        ttk.Spinbox(frame, from_=imm_def['min'], to=imm_def['max'],
                   textvariable=self.immunity_var, width=8).grid(row=row, column=1, sticky='w', padx=5, pady=2)
        ttk.Label(frame, text=f"[{imm_def['min']}-{imm_def['max']}] {imm_def['hint']}",
                 font=('TkDefaultFont', 7), foreground='gray').grid(row=row, column=2, sticky='w', padx=5, pady=2)
        row += 1

        # Base Score
        ttk.Label(frame, text="Base Score:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.base_score_var = tk.DoubleVar(value=self.params.base_score)
        ttk.Spinbox(frame, from_=base_def['min'], to=base_def['max'],
                   textvariable=self.base_score_var, width=8, increment=10).grid(row=row, column=1, sticky='w', padx=5, pady=2)
        ttk.Label(frame, text=f"[{int(base_def['min'])}-{int(base_def['max'])}] {base_def['hint']}",
                 font=('TkDefaultFont', 7), foreground='gray').grid(row=row, column=2, sticky='w', padx=5, pady=2)
        row += 1

        # Swap Threshold
        ttk.Label(frame, text="Swap Threshold:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.threshold_var = tk.DoubleVar(value=self.params.swap_threshold)
        ttk.Spinbox(frame, from_=thresh_def['min'], to=thresh_def['max'],
                   textvariable=self.threshold_var, width=8, increment=5).grid(row=row, column=1, sticky='w', padx=5, pady=2)
        ttk.Label(frame, text=f"[{int(thresh_def['min'])}-{int(thresh_def['max'])}] {thresh_def['hint']}",
                 font=('TkDefaultFont', 7), foreground='gray').grid(row=row, column=2, sticky='w', padx=5, pady=2)
        row += 1

        # Portfolio Configuration Section
        ttk.Separator(frame, orient='horizontal').grid(row=row, column=0, columnspan=3, sticky='ew', pady=10)
        row += 1

        ttk.Label(frame, text="Portfolio Simulation", font=('TkDefaultFont', 10, 'bold')).grid(
            row=row, column=0, columnspan=3, sticky='w', padx=5, pady=(5, 2)
        )
        row += 1

        # Max Simultaneous Positions
        ttk.Label(frame, text="Max Positions:").grid(row=row, column=0, sticky='w', padx=5, pady=2)
        self.max_positions_var = tk.IntVar(value=3)
        ttk.Spinbox(frame, from_=1, to=20,
                   textvariable=self.max_positions_var, width=8).grid(row=row, column=1, sticky='w', padx=5, pady=2)
        ttk.Label(frame, text="[1-20] Max concurrent open trades",
                 font=('TkDefaultFont', 7), foreground='gray').grid(row=row, column=2, sticky='w', padx=5, pady=2)
        row += 1

        # Feature Weights Section
        ttk.Separator(frame, orient='horizontal').grid(row=row, column=0, columnspan=3, sticky='ew', pady=10)
        row += 1

        ttk.Label(frame, text="Feature Configuration", font=('TkDefaultFont', 10, 'bold')).grid(
            row=row, column=0, columnspan=3, sticky='w', padx=5, pady=(5, 2)
        )
        row += 1

        # Scrollable frame for feature configuration
        feature_container = ttk.Frame(frame)
        feature_container.grid(row=row, column=0, columnspan=3, sticky='nsew', padx=5, pady=5)
        frame.rowconfigure(row, weight=1)

        canvas = tk.Canvas(feature_container, highlightthickness=0, height=350)
        scrollbar = ttk.Scrollbar(feature_container, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Mousewheel scrolling
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
        canvas.bind_all("<MouseWheel>", _on_mousewheel)

        # Create widgets for each feature
        self.feature_vars = {}

        for feature_name, definition in ENHANCED_FEATURE_DEFINITIONS.items():
            self.feature_vars[feature_name] = {}
            self._create_feature_widget(scrollable_frame, feature_name, definition)

        # Initialize feature values from current params
        self._load_feature_values()

    def _create_feature_widget(self, parent: ttk.Frame, feature_name: str, definition: dict):
        """Create a widget section for a single feature with all parameters."""
        # Feature frame with border
        frame = ttk.LabelFrame(parent, text=f"{definition['name']} [{definition.get('importance', 'MEDIUM')}]", padding="5")
        frame.pack(fill=tk.X, pady=3, padx=2)

        # Row 0: Enable checkbox and description
        row0 = ttk.Frame(frame)
        row0.pack(fill=tk.X)

        enabled_var = tk.BooleanVar(value=False)
        self.feature_vars[feature_name]['enabled'] = enabled_var
        ttk.Checkbutton(row0, text="Enabled", variable=enabled_var,
                       command=lambda fn=feature_name: self._on_feature_toggle(fn)).pack(side=tk.LEFT)

        desc_text = definition.get('description', '')
        ttk.Label(row0, text=f"  {desc_text}",
                 font=('TkDefaultFont', 8), foreground='gray').pack(side=tk.LEFT, padx=5)

        # Row 1: Weight with range hint
        row1 = ttk.Frame(frame)
        row1.pack(fill=tk.X, pady=(3, 0))

        ttk.Label(row1, text="Weight:", width=12).pack(side=tk.LEFT)
        weight_var = tk.DoubleVar(value=definition['recommended_weight'])
        self.feature_vars[feature_name]['weight'] = weight_var

        weight_range = definition.get('weight_range', (-10.0, 10.0))
        weight_spin = ttk.Spinbox(row1, from_=weight_range[0], to=weight_range[1],
                                 textvariable=weight_var, width=8, increment=0.5)
        weight_spin.pack(side=tk.LEFT)

        hint_text = definition.get('weight_hint', f'Range: {weight_range[0]} to {weight_range[1]}')
        ttk.Label(row1, text=f"  {hint_text}",
                 font=('TkDefaultFont', 7), foreground='#888').pack(side=tk.LEFT, padx=5)

        # Row 1b: Use Advanced Parameters checkbox
        row1b = ttk.Frame(frame)
        row1b.pack(fill=tk.X, pady=(3, 0))

        use_adv_var = tk.BooleanVar(value=False)
        self.feature_vars[feature_name]['use_advanced_params'] = use_adv_var
        ttk.Checkbutton(row1b, text="Use Advanced Parameters (decay/stagnation logic)",
                       variable=use_adv_var,
                       command=lambda fn=feature_name: self._on_advanced_toggle(fn)).pack(side=tk.LEFT)
        ttk.Label(row1b, text="  If disabled: simple constant weight. If enabled: dynamic weight.",
                 font=('TkDefaultFont', 7), foreground='#888').pack(side=tk.LEFT, padx=5)

        # Row 2: Decay parameters
        row2 = ttk.Frame(frame)
        row2.pack(fill=tk.X, pady=(2, 0))

        # Decay Point
        dp_def = FEATURE_PARAMETER_DEFINITIONS['decay_point']
        dp_label = ttk.Label(row2, text="Decay Point:", width=12)
        dp_label.pack(side=tk.LEFT)
        decay_point_var = tk.IntVar(value=dp_def['default'])
        self.feature_vars[feature_name]['decay_point'] = decay_point_var
        dp_spin = ttk.Spinbox(row2, from_=dp_def['min'], to=dp_def['max'],
                   textvariable=decay_point_var, width=5)
        dp_spin.pack(side=tk.LEFT)
        dp_hint = ttk.Label(row2, text=f" days [{dp_def['min']}-{dp_def['max']}]",
                 font=('TkDefaultFont', 7), foreground='#666')
        dp_hint.pack(side=tk.LEFT)

        # Stagnation Threshold
        stag_def = FEATURE_PARAMETER_DEFINITIONS['stagnation_threshold']
        stag_label = ttk.Label(row2, text="  Stagnation:", width=10)
        stag_label.pack(side=tk.LEFT)
        stag_var = tk.DoubleVar(value=stag_def['default'])
        self.feature_vars[feature_name]['stagnation_threshold'] = stag_var
        stag_spin = ttk.Spinbox(row2, from_=stag_def['min'], to=stag_def['max'],
                   textvariable=stag_var, width=5, increment=0.5)
        stag_spin.pack(side=tk.LEFT)
        stag_hint = ttk.Label(row2, text=f" % [{stag_def['min']}-{stag_def['max']}]",
                 font=('TkDefaultFont', 7), foreground='#666')
        stag_hint.pack(side=tk.LEFT)

        # Row 3: Decay rates
        row3 = ttk.Frame(frame)
        row3.pack(fill=tk.X, pady=(2, 0))

        # Fast Decay
        fast_def = FEATURE_PARAMETER_DEFINITIONS['fast_decay_rate']
        fast_label = ttk.Label(row3, text="Fast Decay:", width=12)
        fast_label.pack(side=tk.LEFT)
        fast_var = tk.DoubleVar(value=fast_def['default'])
        self.feature_vars[feature_name]['fast_decay_rate'] = fast_var
        fast_spin = ttk.Spinbox(row3, from_=fast_def['min'], to=fast_def['max'],
                   textvariable=fast_var, width=5, increment=0.5)
        fast_spin.pack(side=tk.LEFT)
        fast_hint = ttk.Label(row3, text=f" pts/day",
                 font=('TkDefaultFont', 7), foreground='#666')
        fast_hint.pack(side=tk.LEFT)

        # Slow Decay
        slow_def = FEATURE_PARAMETER_DEFINITIONS['slow_decay_rate']
        slow_label = ttk.Label(row3, text="  Slow Decay:", width=10)
        slow_label.pack(side=tk.LEFT)
        slow_var = tk.DoubleVar(value=slow_def['default'])
        self.feature_vars[feature_name]['slow_decay_rate'] = slow_var
        slow_spin = ttk.Spinbox(row3, from_=slow_def['min'], to=slow_def['max'],
                   textvariable=slow_var, width=5, increment=0.1)
        slow_spin.pack(side=tk.LEFT)
        slow_hint = ttk.Label(row3, text=f" pts/day",
                 font=('TkDefaultFont', 7), foreground='#666')
        slow_hint.pack(side=tk.LEFT)

        # Store widget references for enabling/disabling advanced parameters
        self.feature_vars[feature_name]['advanced_widgets'] = [
            row2, row3,  # The entire rows
            dp_label, dp_spin, dp_hint,
            stag_label, stag_spin, stag_hint,
            fast_label, fast_spin, fast_hint,
            slow_label, slow_spin, slow_hint
        ]

        # Initially disable advanced parameters (they're enabled when checkbox is checked)
        self._set_advanced_params_state(feature_name, False)

    def _on_advanced_toggle(self, feature_name: str):
        """Handle toggling of advanced parameters."""
        use_advanced = self.feature_vars[feature_name]['use_advanced_params'].get()
        self._set_advanced_params_state(feature_name, use_advanced)

    def _set_advanced_params_state(self, feature_name: str, enabled: bool):
        """Enable or disable advanced parameter widgets."""
        if 'advanced_widgets' in self.feature_vars[feature_name]:
            state = 'normal' if enabled else 'disabled'
            for widget in self.feature_vars[feature_name]['advanced_widgets']:
                if hasattr(widget, 'configure'):
                    try:
                        widget.configure(state=state)
                    except:
                        pass  # Some widgets don't support state

    def _load_feature_values(self):
        """Load feature values from current params."""
        for feature_name, weight in self.params.features.items():
            if feature_name in self.feature_vars:
                fv = self.feature_vars[feature_name]
                fv['enabled'].set(weight.enabled)
                fv['weight'].set(weight.weight)

                # Load use_advanced_params flag
                use_advanced = getattr(weight, 'use_advanced_params', False)
                if 'use_advanced_params' in fv:
                    fv['use_advanced_params'].set(use_advanced)
                    # Update widget states based on the flag
                    self._set_advanced_params_state(feature_name, use_advanced)

                # Load advanced parameters if present
                if 'decay_point' in fv:
                    fv['decay_point'].set(getattr(weight, 'decay_point', 14))
                if 'stagnation_threshold' in fv:
                    fv['stagnation_threshold'].set(getattr(weight, 'stagnation_threshold', 2.0))
                if 'fast_decay_rate' in fv:
                    fv['fast_decay_rate'].set(getattr(weight, 'fast_decay_rate', 5.0))
                if 'slow_decay_rate' in fv:
                    fv['slow_decay_rate'].set(getattr(weight, 'slow_decay_rate', 1.0))

    def _on_feature_toggle(self, feature_name: str):
        """Handle feature enable/disable toggle."""
        pass  # Widget state is tracked by variable

    def _create_results_panel(self, parent: ttk.Frame):
        """Create the results panel with tabs."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Notebook for tabs
        self.notebook = ttk.Notebook(parent)
        self.notebook.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)

        # Summary Tab
        summary_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(summary_frame, text="Summary")
        self._create_summary_tab(summary_frame)

        # Trade Analysis Tab
        trades_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(trades_frame, text="Trade Analysis")
        self._create_trades_tab(trades_frame)

        # Charts Tab
        charts_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(charts_frame, text="Charts")
        self._create_charts_tab(charts_frame)

        # Swap Events Tab
        swaps_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(swaps_frame, text="Swap Events")
        self._create_swaps_tab(swaps_frame)

        # Portfolio Comparison Tab
        portfolio_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(portfolio_frame, text="Portfolio Analysis")
        self._create_portfolio_tab(portfolio_frame)

        # Rejected Signals Tab
        rejected_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(rejected_frame, text="Rejected Signals")
        self._create_rejected_signals_tab(rejected_frame)

        # Threshold Sensitivity Tab
        sensitivity_frame = ttk.Frame(self.notebook, padding="10")
        self.notebook.add(sensitivity_frame, text="Threshold Sensitivity")
        self._create_threshold_sensitivity_tab(sensitivity_frame)

    def _create_summary_tab(self, parent: ttk.Frame):
        """Create the summary tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Summary text
        self.summary_text = tk.Text(parent, wrap=tk.WORD, font=('Consolas', 10))
        self.summary_text.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=self.summary_text.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.summary_text.configure(yscrollcommand=scrollbar.set)

        self.summary_text.insert('1.0', "No analysis run yet. Load data and click 'Run Analysis'.")
        self.summary_text.configure(state='disabled')

    def _create_trades_tab(self, parent: ttk.Frame):
        """Create the trade analysis tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)
        parent.rowconfigure(1, weight=0)

        # Treeview for trade analysis
        columns = ('trade_id', 'symbol', 'natural_pl', 'vuln_pl', 'difference', 'category')
        self.trades_tree = ttk.Treeview(parent, columns=columns, show='headings')

        self.trades_tree.heading('trade_id', text='Trade ID')
        self.trades_tree.heading('symbol', text='Symbol')
        self.trades_tree.heading('natural_pl', text='Natural P/L')
        self.trades_tree.heading('vuln_pl', text='Vuln P/L')
        self.trades_tree.heading('difference', text='Difference')
        self.trades_tree.heading('category', text='Category')

        self.trades_tree.column('trade_id', width=80)
        self.trades_tree.column('symbol', width=80)
        self.trades_tree.column('natural_pl', width=100)
        self.trades_tree.column('vuln_pl', width=100)
        self.trades_tree.column('difference', width=100)
        self.trades_tree.column('category', width=120)

        self.trades_tree.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=self.trades_tree.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.trades_tree.configure(yscrollcommand=scrollbar.set)

        # Bind selection to show trade details
        self.trades_tree.bind('<<TreeviewSelect>>', self._on_trade_selected)

        # Button frame for export
        button_frame = ttk.Frame(parent)
        button_frame.grid(row=1, column=0, columnspan=2, sticky='ew', pady=5)

        ttk.Button(button_frame, text="Export to CSV", command=self._export_trade_analysis).pack(side=tk.LEFT, padx=5)

    def _create_charts_tab(self, parent: ttk.Frame):
        """Create the charts tab."""
        parent.columnconfigure(0, weight=1)
        parent.columnconfigure(1, weight=1)
        parent.rowconfigure(0, weight=1)
        parent.rowconfigure(1, weight=1)

        # Create chart frames
        self.chart_categorization = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_categorization.grid(row=0, column=0, sticky='nsew', padx=2, pady=2)

        self.chart_cumulative = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_cumulative.grid(row=0, column=1, sticky='nsew', padx=2, pady=2)

        self.chart_pl_comparison = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_pl_comparison.grid(row=1, column=0, sticky='nsew', padx=2, pady=2)

        self.chart_timeline = VulnerabilityChartFrame(parent, figsize=(5, 4))
        self.chart_timeline.grid(row=1, column=1, sticky='nsew', padx=2, pady=2)

    def _create_swaps_tab(self, parent: ttk.Frame):
        """Create the swap events tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=1)

        # Treeview for swap events
        columns = ('date', 'symbol', 'score', 'reason', 'days_held', 'pl_diff', 'outcome')
        self.swaps_tree = ttk.Treeview(parent, columns=columns, show='headings')

        self.swaps_tree.heading('date', text='Date')
        self.swaps_tree.heading('symbol', text='Symbol')
        self.swaps_tree.heading('score', text='Score')
        self.swaps_tree.heading('reason', text='Reason')
        self.swaps_tree.heading('days_held', text='Days Early')
        self.swaps_tree.heading('pl_diff', text='P/L Diff')
        self.swaps_tree.heading('outcome', text='Outcome')

        self.swaps_tree.column('date', width=100)
        self.swaps_tree.column('symbol', width=80)
        self.swaps_tree.column('score', width=60)
        self.swaps_tree.column('reason', width=100)
        self.swaps_tree.column('days_held', width=80)
        self.swaps_tree.column('pl_diff', width=80)
        self.swaps_tree.column('outcome', width=100)

        self.swaps_tree.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=self.swaps_tree.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.swaps_tree.configure(yscrollcommand=scrollbar.set)

    def _create_portfolio_tab(self, parent: ttk.Frame):
        """Create the portfolio analysis tab."""
        parent.columnconfigure(0, weight=1)
        parent.columnconfigure(1, weight=1)
        parent.rowconfigure(0, weight=1)

        # Left side - FIFO results
        fifo_frame = ttk.LabelFrame(parent, text="Natural Portfolio (FIFO)", padding="10")
        fifo_frame.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)
        fifo_frame.columnconfigure(0, weight=1)
        fifo_frame.rowconfigure(0, weight=1)

        self.portfolio_fifo_text = tk.Text(fifo_frame, wrap=tk.WORD, font=('Consolas', 9))
        self.portfolio_fifo_text.grid(row=0, column=0, sticky='nsew')

        fifo_scrollbar = ttk.Scrollbar(fifo_frame, orient='vertical', command=self.portfolio_fifo_text.yview)
        fifo_scrollbar.grid(row=0, column=1, sticky='ns')
        self.portfolio_fifo_text.configure(yscrollcommand=fifo_scrollbar.set)

        self.portfolio_fifo_text.insert('1.0', "Run portfolio analysis to see FIFO results...")
        self.portfolio_fifo_text.configure(state='disabled')

        # Right side - Vulnerability results
        vuln_frame = ttk.LabelFrame(parent, text="Vulnerability-Optimized Portfolio", padding="10")
        vuln_frame.grid(row=0, column=1, sticky='nsew', padx=5, pady=5)
        vuln_frame.columnconfigure(0, weight=1)
        vuln_frame.rowconfigure(0, weight=1)

        self.portfolio_vuln_text = tk.Text(vuln_frame, wrap=tk.WORD, font=('Consolas', 9))
        self.portfolio_vuln_text.grid(row=0, column=0, sticky='nsew')

        vuln_scrollbar = ttk.Scrollbar(vuln_frame, orient='vertical', command=self.portfolio_vuln_text.yview)
        vuln_scrollbar.grid(row=0, column=1, sticky='ns')
        self.portfolio_vuln_text.configure(yscrollcommand=vuln_scrollbar.set)

        self.portfolio_vuln_text.insert('1.0', "Run portfolio analysis to see vulnerability-optimized results...")
        self.portfolio_vuln_text.configure(state='disabled')

        # Bottom - Comparison
        comparison_frame = ttk.LabelFrame(parent, text="Comparison", padding="10")
        comparison_frame.grid(row=1, column=0, columnspan=2, sticky='ew', padx=5, pady=5)
        comparison_frame.columnconfigure(0, weight=1)

        self.portfolio_comparison_text = tk.Text(comparison_frame, wrap=tk.WORD, font=('Consolas', 10, 'bold'), height=8)
        self.portfolio_comparison_text.grid(row=0, column=0, sticky='ew')

        self.portfolio_comparison_text.insert('1.0', "Run portfolio analysis to see comparison...")
        self.portfolio_comparison_text.configure(state='disabled')

    def _create_rejected_signals_tab(self, parent: ttk.Frame):
        """Create the rejected signals analysis tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=0)  # Filter frame
        parent.rowconfigure(1, weight=1)  # Table
        parent.rowconfigure(2, weight=0)  # Summary

        # Filter Frame
        filter_frame = ttk.LabelFrame(parent, text="Filters", padding="5")
        filter_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=5)

        # Filter options
        ttk.Label(filter_frame, text="Show:").pack(side=tk.LEFT, padx=5)
        self.rejection_filter_var = tk.StringVar(value="all")
        ttk.Radiobutton(filter_frame, text="All", variable=self.rejection_filter_var,
                       value="all", command=self._filter_rejected_signals).pack(side=tk.LEFT)
        ttk.Radiobutton(filter_frame, text="Missed Opportunities (Opp Cost > 0)",
                       variable=self.rejection_filter_var, value="missed",
                       command=self._filter_rejected_signals).pack(side=tk.LEFT)
        ttk.Radiobutton(filter_frame, text="Good Rejections (Opp Cost < 0)",
                       variable=self.rejection_filter_var, value="good",
                       command=self._filter_rejected_signals).pack(side=tk.LEFT)
        ttk.Radiobutton(filter_frame, text="Close Calls (Within 5 pts of threshold)",
                       variable=self.rejection_filter_var, value="close",
                       command=self._filter_rejected_signals).pack(side=tk.LEFT)

        # Sort options
        ttk.Label(filter_frame, text="Sort by:").pack(side=tk.LEFT, padx=(20, 5))
        self.rejection_sort_var = tk.StringVar(value="date")
        sort_combo = ttk.Combobox(filter_frame, textvariable=self.rejection_sort_var, width=20, state='readonly')
        sort_combo['values'] = ["Date", "Opportunity Cost (High to Low)", "Opportunity Cost (Low to High)",
                                 "Score Gap (Closest First)"]
        sort_combo.pack(side=tk.LEFT, padx=5)
        sort_combo.bind('<<ComboboxSelected>>', lambda e: self._filter_rejected_signals())

        # Table Frame
        table_frame = ttk.Frame(parent)
        table_frame.grid(row=1, column=0, sticky='nsew', padx=5, pady=5)
        table_frame.columnconfigure(0, weight=1)
        table_frame.rowconfigure(0, weight=1)

        # Treeview for rejected signals
        columns = ('date', 'signal', 'signal_pl', 'kept_position', 'kept_pl', 'opp_cost',
                  'score', 'threshold', 'gap', 'decision')
        self.rejected_tree = ttk.Treeview(table_frame, columns=columns, show='headings', height=15)

        self.rejected_tree.heading('date', text='Date')
        self.rejected_tree.heading('signal', text='Rejected Signal')
        self.rejected_tree.heading('signal_pl', text='Signal P/L')
        self.rejected_tree.heading('kept_position', text='Kept Position')
        self.rejected_tree.heading('kept_pl', text='Kept P/L')
        self.rejected_tree.heading('opp_cost', text='Opp Cost')
        self.rejected_tree.heading('score', text='Weakest Score')
        self.rejected_tree.heading('threshold', text='Threshold')
        self.rejected_tree.heading('gap', text='Score Gap')
        self.rejected_tree.heading('decision', text='Decision Quality')

        self.rejected_tree.column('date', width=80)
        self.rejected_tree.column('signal', width=100)
        self.rejected_tree.column('signal_pl', width=80)
        self.rejected_tree.column('kept_position', width=100)
        self.rejected_tree.column('kept_pl', width=80)
        self.rejected_tree.column('opp_cost', width=90)
        self.rejected_tree.column('score', width=90)
        self.rejected_tree.column('threshold', width=80)
        self.rejected_tree.column('gap', width=70)
        self.rejected_tree.column('decision', width=120)

        self.rejected_tree.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(table_frame, orient='vertical', command=self.rejected_tree.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.rejected_tree.configure(yscrollcommand=scrollbar.set)

        # Summary Frame
        summary_frame = ttk.LabelFrame(parent, text="Rejection Summary", padding="10")
        summary_frame.grid(row=2, column=0, sticky='ew', padx=5, pady=5)

        self.rejection_summary_text = tk.Text(summary_frame, wrap=tk.WORD, font=('Consolas', 9), height=6)
        self.rejection_summary_text.pack(fill=tk.BOTH, expand=True)
        self.rejection_summary_text.insert('1.0', "Run portfolio analysis to see rejected signals...")
        self.rejection_summary_text.configure(state='disabled')

    def _create_threshold_sensitivity_tab(self, parent: ttk.Frame):
        """Create the threshold sensitivity analysis tab."""
        parent.columnconfigure(0, weight=1)
        parent.rowconfigure(0, weight=0)  # Config
        parent.rowconfigure(1, weight=1)  # Results

        # Configuration Frame
        config_frame = ttk.LabelFrame(parent, text="Threshold Range", padding="10")
        config_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=5)

        ttk.Label(config_frame, text="Test thresholds from:").pack(side=tk.LEFT, padx=5)
        self.threshold_min_var = tk.IntVar(value=10)
        ttk.Spinbox(config_frame, from_=0, to=100, textvariable=self.threshold_min_var, width=8).pack(side=tk.LEFT, padx=5)

        ttk.Label(config_frame, text="to:").pack(side=tk.LEFT, padx=5)
        self.threshold_max_var = tk.IntVar(value=60)
        ttk.Spinbox(config_frame, from_=0, to=100, textvariable=self.threshold_max_var, width=8).pack(side=tk.LEFT, padx=5)

        ttk.Label(config_frame, text="step:").pack(side=tk.LEFT, padx=5)
        self.threshold_step_var = tk.IntVar(value=5)
        ttk.Spinbox(config_frame, from_=1, to=20, textvariable=self.threshold_step_var, width=8).pack(side=tk.LEFT, padx=5)

        ttk.Button(config_frame, text="Run Sensitivity Analysis",
                  command=self._run_threshold_sensitivity).pack(side=tk.LEFT, padx=20)

        # Results Frame
        results_frame = ttk.Frame(parent)
        results_frame.grid(row=1, column=0, sticky='nsew', padx=5, pady=5)
        results_frame.columnconfigure(0, weight=1)
        results_frame.rowconfigure(0, weight=1)

        # Treeview for sensitivity results
        columns = ('threshold', 'total_pl', 'swaps', 'rejections', 'good_swaps', 'bad_swaps',
                  'good_rejections', 'missed_opps', 'net_benefit')
        self.sensitivity_tree = ttk.Treeview(results_frame, columns=columns, show='headings', height=20)

        self.sensitivity_tree.heading('threshold', text='Threshold')
        self.sensitivity_tree.heading('total_pl', text='Total P/L')
        self.sensitivity_tree.heading('swaps', text='Total Swaps')
        self.sensitivity_tree.heading('rejections', text='Rejections')
        self.sensitivity_tree.heading('good_swaps', text='Good Swaps')
        self.sensitivity_tree.heading('bad_swaps', text='Bad Swaps')
        self.sensitivity_tree.heading('good_rejections', text='Good Rejections')
        self.sensitivity_tree.heading('missed_opps', text='Missed Opps')
        self.sensitivity_tree.heading('net_benefit', text='Net Benefit')

        self.sensitivity_tree.column('threshold', width=80)
        self.sensitivity_tree.column('total_pl', width=100)
        self.sensitivity_tree.column('swaps', width=80)
        self.sensitivity_tree.column('rejections', width=80)
        self.sensitivity_tree.column('good_swaps', width=90)
        self.sensitivity_tree.column('bad_swaps', width=90)
        self.sensitivity_tree.column('good_rejections', width=120)
        self.sensitivity_tree.column('missed_opps', width=100)
        self.sensitivity_tree.column('net_benefit', width=100)

        self.sensitivity_tree.grid(row=0, column=0, sticky='nsew')

        scrollbar = ttk.Scrollbar(results_frame, orient='vertical', command=self.sensitivity_tree.yview)
        scrollbar.grid(row=0, column=1, sticky='ns')
        self.sensitivity_tree.configure(yscrollcommand=scrollbar.set)

    def _load_presets(self):
        """Load available presets into combo box."""
        # Get all presets (built-in + custom)
        presets = self.preset_manager.get_preset_names()

        # Find the preset combo in config panel
        for child in self.root.winfo_children():
            self._find_and_update_preset_combo(child, presets)

    def _find_and_update_preset_combo(self, widget, presets):
        """Recursively find and update preset combo."""
        if isinstance(widget, ttk.Combobox):
            if widget.cget('textvariable') == str(self.preset_var):
                widget['values'] = presets
                return
        for child in widget.winfo_children():
            self._find_and_update_preset_combo(child, presets)

    def _on_preset_selected(self, event):
        """Handle preset selection."""
        preset_name = self.preset_var.get()
        preset = self.preset_manager.load_preset(preset_name)
        if preset:
            self.params = preset
            self.immunity_var.set(self.params.immunity_days)
            self.threshold_var.set(self.params.swap_threshold)
            self.base_score_var.set(self.params.base_score)
            self._load_feature_values()

    def _set_data_directory(self):
        """Set the data directory."""
        directory = filedialog.askdirectory(
            title="Select Data Directory",
            initialdir=str(self.data_directory)
        )
        if directory:
            self.data_directory = Path(directory)
            self.data_status_var.set(f"Data dir: {self.data_directory}")

    def _load_trade_log(self):
        """Load a trade log file."""
        filepath = filedialog.askopenfilename(
            title="Select Trade Log",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=str(Path('logs'))
        )

        if not filepath:
            return

        try:
            self.data_loader = BacktestTradeLoader(self.data_directory)
            self.trades, self.price_data, report = self.data_loader.load_from_trade_log(
                Path(filepath)
            )

            if not report.is_valid:
                messagebox.showwarning("Data Warning", report.get_summary())

            self.data_status_var.set(f"Loaded {len(self.trades)} trades")
            messagebox.showinfo("Success", f"Loaded {len(self.trades)} trades from {len(self.price_data)} symbols")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load trade log:\n{str(e)}")
            traceback.print_exc()

    def _get_current_params(self) -> VulnerabilityScoreParams:
        """Get current parameters from UI."""
        features = {}

        for feature_name, vars_dict in self.feature_vars.items():
            features[feature_name] = FeatureWeight(
                enabled=vars_dict['enabled'].get(),
                weight=vars_dict['weight'].get(),
                use_advanced_params=vars_dict.get('use_advanced_params', tk.BooleanVar(value=False)).get(),
                decay_point=vars_dict.get('decay_point', tk.IntVar(value=14)).get(),
                fast_decay_rate=vars_dict.get('fast_decay_rate', tk.DoubleVar(value=5.0)).get(),
                slow_decay_rate=vars_dict.get('slow_decay_rate', tk.DoubleVar(value=1.0)).get(),
                stagnation_threshold=vars_dict.get('stagnation_threshold', tk.DoubleVar(value=2.0)).get()
            )

        return VulnerabilityScoreParams(
            name="Custom",
            description="User-defined parameters",
            immunity_days=self.immunity_var.get(),
            base_score=self.base_score_var.get(),
            swap_threshold=self.threshold_var.get(),
            features=features
        )

    def _run_analysis(self):
        """Run the vulnerability analysis."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Get current parameters
        params = self._get_current_params()

        # Create progress dialog
        progress = ProgressDialog(
            self.root,
            "Running Analysis",
            "Analyzing trades...",
            determinate=True,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(10, "Initializing analyzer...")

            # Run analysis
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(30, f"Processing {len(self.trades)} trades...")
            self.current_report = analyzer.analyze_backtest(self.trades, self.price_data)

            progress.update(70, "Updating summary...")
            self._update_summary()

            progress.update(80, "Updating tables...")
            self._update_trades_table()
            self._update_swaps_table()

            progress.update(90, "Generating charts...")
            self._update_charts()

            progress.update(95, "Running portfolio simulation...")
            self._run_portfolio_simulation(params)

            progress.close()

            self.notebook.select(0)  # Switch to summary tab

            # Build completion message
            completion_msg = f"Analysis complete!\n\n"
            completion_msg += f"Trades affected: {self.current_report.trades_affected_by_vulnerability}\n"
            completion_msg += f"P/L difference: ${self.current_report.total_pl_difference:,.2f}\n\n"

            if self.portfolio_fifo_result and self.portfolio_vuln_result:
                improvement = self.portfolio_vuln_result.total_pl - self.portfolio_fifo_result.total_pl
                improvement_pct = (improvement / abs(self.portfolio_fifo_result.total_pl) * 100) if self.portfolio_fifo_result.total_pl != 0 else 0
                completion_msg += f"Portfolio Improvement: ${improvement:,.2f} ({improvement_pct:+.1f}%)"

            messagebox.showinfo("Analysis Complete", completion_msg)

        except FeatureError as e:
            progress.close()
            messagebox.showerror("Feature Error", str(e))
        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed:\n{str(e)}")
            traceback.print_exc()

    def _update_summary(self):
        """Update the summary tab."""
        if not self.current_report:
            return

        self.summary_text.configure(state='normal')
        self.summary_text.delete('1.0', tk.END)

        # Add summary text
        self.summary_text.insert('1.0', self.current_report.get_summary_text())
        self.summary_text.insert(tk.END, "\n\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, "KEY INSIGHT\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, self.current_report.get_key_insight())
        self.summary_text.insert(tk.END, "\n\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, "RECOMMENDATION\n")
        self.summary_text.insert(tk.END, "=" * 50 + "\n")
        self.summary_text.insert(tk.END, self.current_report.get_recommendation())

        self.summary_text.configure(state='disabled')

    def _update_trades_table(self):
        """Update the trades table."""
        # Clear existing items
        for item in self.trades_tree.get_children():
            self.trades_tree.delete(item)

        if not self.current_report:
            return

        for trade in self.current_report.trades:
            self.trades_tree.insert('', 'end', values=(
                trade.trade_id,
                trade.symbol,
                f"${trade.pl_natural_dollars:,.2f}",
                f"${trade.pl_if_exited_at_vulnerability_dollars:,.2f}",
                f"${trade.pl_difference_dollars:+,.2f}",
                trade.benefit_category
            ))

    def _update_charts(self):
        """Update all charts."""
        if not self.current_report:
            return

        # Categorization pie chart
        not_affected = self.current_report.total_trades - self.current_report.trades_affected_by_vulnerability
        plot_trade_categorization(
            self.chart_categorization,
            self.current_report.benefited_count,
            self.current_report.hurt_count,
            self.current_report.neutral_count,
            not_affected
        )

        # Cumulative P/L chart
        trades_dicts = [t.to_dict() for t in self.current_report.trades]
        plot_cumulative_pl_impact(self.chart_cumulative, trades_dicts)

        # P/L comparison chart
        plot_pl_comparison(self.chart_pl_comparison, trades_dicts)

        # Timeline chart for first affected trade
        affected = [t for t in self.current_report.trades if t.would_have_been_swapped]
        if affected and affected[0].daily_timeline:
            timeline_dicts = [r.to_dict() for r in affected[0].daily_timeline]
            params = self._get_current_params()
            plot_vulnerability_timeline(
                self.chart_timeline,
                timeline_dicts,
                params.swap_threshold,
                params.immunity_days,
                f"Timeline: {affected[0].trade_id}"
            )

    def _update_swaps_table(self):
        """Update the swap events table."""
        # Clear existing items
        for item in self.swaps_tree.get_children():
            self.swaps_tree.delete(item)

        if not self.current_report:
            return

        for trade in self.current_report.trades:
            if trade.would_have_been_swapped and trade.first_vulnerable_date:
                self.swaps_tree.insert('', 'end', values=(
                    trade.first_vulnerable_date.strftime('%Y-%m-%d') if hasattr(trade.first_vulnerable_date, 'strftime') else str(trade.first_vulnerable_date),
                    trade.symbol,
                    f"{trade.first_vulnerable_score:.1f}",
                    trade.benefit_category,
                    trade.days_before_vulnerability_exit,
                    f"{trade.pl_difference_pct:+.2f}%",
                    trade.benefit_category
                ))

    def _run_portfolio_simulation(self, params: VulnerabilityScoreParams):
        """Run portfolio simulation with capacity constraints."""
        if not self.trades or len(self.trades) < 2:
            # Not enough trades for portfolio simulation
            return

        try:
            from Classes.VulnerabilityScorer.portfolio_simulator import (
                PortfolioSimulator,
                trades_to_signals
            )

            # Convert trades to signals
            signals = trades_to_signals(self.trades)

            if not signals:
                return

            # Get max positions from GUI
            max_positions = self.max_positions_var.get()

            # Create simulator
            simulator = PortfolioSimulator(max_positions=max_positions)

            # Run FIFO simulation
            self.portfolio_fifo_result = simulator.simulate_fifo(signals, self.price_data)

            # Run vulnerability-optimized simulation
            self.portfolio_vuln_result = simulator.simulate_vulnerability(
                signals, self.price_data, params
            )

            # Update the portfolio tab
            self._update_portfolio_results()

        except Exception as e:
            # Don't fail the whole analysis if portfolio simulation fails
            print(f"Portfolio simulation error: {e}")
            traceback.print_exc()

    def _update_portfolio_results(self):
        """Update the portfolio analysis tab."""
        if not self.portfolio_fifo_result or not self.portfolio_vuln_result:
            return

        # Update FIFO results
        self.portfolio_fifo_text.configure(state='normal')
        self.portfolio_fifo_text.delete('1.0', tk.END)
        self.portfolio_fifo_text.insert('1.0', self.portfolio_fifo_result.get_summary_text())
        self.portfolio_fifo_text.configure(state='disabled')

        # Update Vulnerability results
        self.portfolio_vuln_text.configure(state='normal')
        self.portfolio_vuln_text.delete('1.0', tk.END)
        self.portfolio_vuln_text.insert('1.0', self.portfolio_vuln_result.get_summary_text())
        self.portfolio_vuln_text.configure(state='disabled')

        # Update comparison
        self.portfolio_comparison_text.configure(state='normal')
        self.portfolio_comparison_text.delete('1.0', tk.END)

        fifo = self.portfolio_fifo_result
        vuln = self.portfolio_vuln_result

        improvement = vuln.total_pl - fifo.total_pl
        improvement_pct = (improvement / abs(fifo.total_pl) * 100) if fifo.total_pl != 0 else 0

        comparison_lines = [
            "PORTFOLIO COMPARISON SUMMARY",
            "=" * 60,
            "",
            f"Strategy Improvement:",
            f"  P/L Difference: ${improvement:+,.2f} ({improvement_pct:+.1f}%)",
            f"  {' VULNERABILITY WINS!' if improvement > 0 else ' FIFO WINS!' if improvement < 0 else '= TIE'}",
            "",
            f"Trade Execution:",
            f"  FIFO Trades: {fifo.signals_taken}/{fifo.total_signals} ({fifo.signals_taken/fifo.total_signals*100:.1f}%)",
            f"  Vuln Trades: {vuln.signals_taken}/{vuln.total_signals} ({vuln.signals_taken/vuln.total_signals*100:.1f}%)",
            "",
            f"Performance Metrics:",
            f"  FIFO Win Rate: {fifo.win_rate*100:.1f}%",
            f"  Vuln Win Rate: {vuln.win_rate*100:.1f}%",
            f"  FIFO Avg P/L: ${fifo.avg_pl_per_trade:,.2f}",
            f"  Vuln Avg P/L: ${vuln.avg_pl_per_trade:,.2f}",
            "",
        ]

        if vuln.swap_decisions:
            beneficial = sum(1 for s in vuln.swap_decisions if s.net_impact > 0)
            comparison_lines.extend([
                f"Swap Decisions:",
                f"  Total Swaps: {len(vuln.swap_decisions)}",
                f"  Beneficial: {beneficial} ({beneficial/len(vuln.swap_decisions)*100:.1f}%)",
                f"  Net Swap Impact: ${sum(s.net_impact for s in vuln.swap_decisions):,.2f}",
            ])

        self.portfolio_comparison_text.insert('1.0', '\n'.join(comparison_lines))
        self.portfolio_comparison_text.configure(state='disabled')

        # Also update rejected signals tab
        self._update_rejected_signals_tab()

    def _update_rejected_signals_tab(self):
        """Update the rejected signals analysis tab."""
        if not self.portfolio_vuln_result or not hasattr(self.portfolio_vuln_result, 'rejection_decisions'):
            return

        # Store rejection decisions for filtering
        self.all_rejection_decisions = self.portfolio_vuln_result.rejection_decisions

        # Apply current filter
        self._filter_rejected_signals()

        # Update summary
        self._update_rejection_summary()

    def _filter_rejected_signals(self):
        """Filter and display rejected signals based on current filter settings."""
        if not hasattr(self, 'all_rejection_decisions'):
            return

        # Clear existing items
        for item in self.rejected_tree.get_children():
            self.rejected_tree.delete(item)

        if not self.all_rejection_decisions:
            return

        # Apply filter
        filter_val = self.rejection_filter_var.get()
        filtered = []

        for rej in self.all_rejection_decisions:
            if filter_val == "all":
                filtered.append(rej)
            elif filter_val == "missed" and rej.opportunity_cost > 0:
                filtered.append(rej)
            elif filter_val == "good" and rej.opportunity_cost < 0:
                filtered.append(rej)
            elif filter_val == "close":
                score_gap = rej.weakest_score - rej.swap_threshold
                if 0 < score_gap <= 5:
                    filtered.append(rej)

        # Apply sort
        sort_val = self.rejection_sort_var.get()
        if sort_val == "Opportunity Cost (High to Low)":
            filtered.sort(key=lambda r: r.opportunity_cost, reverse=True)
        elif sort_val == "Opportunity Cost (Low to High)":
            filtered.sort(key=lambda r: r.opportunity_cost)
        elif sort_val == "Score Gap (Closest First)":
            filtered.sort(key=lambda r: r.weakest_score - r.swap_threshold)
        else:  # Date
            filtered.sort(key=lambda r: r.date)

        # Populate tree
        for rej in filtered:
            score_gap = rej.weakest_score - rej.swap_threshold
            decision_quality = "GOOD REJECTION" if rej.opportunity_cost < 0 else "MISSED OPPORTUNITY"

            self.rejected_tree.insert('', 'end', values=(
                rej.date.strftime('%Y-%m-%d'),
                rej.rejected_signal.symbol,
                f"${rej.rejected_signal_pl:,.2f}",
                rej.weakest_position.symbol,
                f"${rej.weakest_position_actual_pl:,.2f}",
                f"${rej.opportunity_cost:+,.2f}",
                f"{rej.weakest_score:.1f}",
                f"{rej.swap_threshold:.1f}",
                f"{score_gap:+.1f}",
                decision_quality
            ))

    def _update_rejection_summary(self):
        """Update rejection summary statistics."""
        if not self.all_rejection_decisions:
            return

        total = len(self.all_rejection_decisions)
        good_rejections = sum(1 for r in self.all_rejection_decisions if r.opportunity_cost < 0)
        missed_opps = sum(1 for r in self.all_rejection_decisions if r.opportunity_cost > 0)
        total_opp_cost = sum(r.opportunity_cost for r in self.all_rejection_decisions)
        avg_opp_cost = total_opp_cost / total if total > 0 else 0

        # Find worst miss
        worst_miss = max(self.all_rejection_decisions, key=lambda r: r.opportunity_cost) if self.all_rejection_decisions else None

        summary_lines = [
            f"REJECTED SIGNALS SUMMARY",
            f"=" * 60,
            f"",
            f"Total Rejected Signals: {total}",
            f"  Good Rejections: {good_rejections} ({good_rejections/total*100:.1f}%) - Position outperformed signal",
            f"  Missed Opportunities: {missed_opps} ({missed_opps/total*100:.1f}%) - Signal would have been better",
            f"",
            f"Opportunity Cost Analysis:",
            f"  Total Opportunity Cost: ${total_opp_cost:+,.2f}",
            f"  Average per Rejection: ${avg_opp_cost:+,.2f}",
            f"  {' Net Positive: Rejections saved money!' if total_opp_cost < 0 else ' Net Negative: Missed profitable signals'}",
        ]

        if worst_miss and worst_miss.opportunity_cost > 0:
            summary_lines.extend([
                f"",
                f"Worst Missed Opportunity:",
                f"  Date: {worst_miss.date.strftime('%Y-%m-%d')}",
                f"  Rejected: {worst_miss.rejected_signal.symbol} (would have made ${worst_miss.rejected_signal_pl:,.2f})",
                f"  Kept: {worst_miss.weakest_position.symbol} (made ${worst_miss.weakest_position_actual_pl:,.2f})",
                f"  Cost: ${worst_miss.opportunity_cost:+,.2f}",
            ])

        self.rejection_summary_text.configure(state='normal')
        self.rejection_summary_text.delete('1.0', tk.END)
        self.rejection_summary_text.insert('1.0', '\n'.join(summary_lines))
        self.rejection_summary_text.configure(state='disabled')

    def _run_threshold_sensitivity(self):
        """Run threshold sensitivity analysis."""
        if not self.trades or not self.price_data:
            messagebox.showwarning("No Data", "Please load trade logs first.")
            return

        # Clear existing results
        for item in self.sensitivity_tree.get_children():
            self.sensitivity_tree.delete(item)

        # Get threshold range
        min_threshold = self.threshold_min_var.get()
        max_threshold = self.threshold_max_var.get()
        step = self.threshold_step_var.get()

        if min_threshold >= max_threshold:
            messagebox.showerror("Invalid Range", "Min threshold must be less than max threshold.")
            return

        # Get current params as base
        base_params = self._get_current_params()

        # Import required modules
        from Classes.VulnerabilityScorer.portfolio_simulator import PortfolioSimulator, trades_to_signals

        signals = trades_to_signals(self.trades)
        max_positions = self.max_positions_var.get()
        simulator = PortfolioSimulator(max_positions=max_positions)

        # Run simulations for each threshold
        messagebox.showinfo("Running Analysis", f"Running sensitivity analysis from {min_threshold} to {max_threshold}...\nThis may take a moment.")

        results = []
        for threshold in range(min_threshold, max_threshold + 1, step):
            # Create params with this threshold
            test_params = VulnerabilityScoreParams(
                immunity_days=base_params.immunity_days,
                base_score=base_params.base_score,
                swap_threshold=threshold,
                feature_weights=base_params.feature_weights
            )

            # Run simulation
            result = simulator.simulate_vulnerability(signals, self.price_data, test_params)

            # Calculate metrics
            good_swaps = sum(1 for s in result.swap_decisions if s.net_impact > 0)
            bad_swaps = len(result.swap_decisions) - good_swaps
            good_rejections = sum(1 for r in result.rejection_decisions if r.opportunity_cost < 0)
            missed_opps = sum(1 for r in result.rejection_decisions if r.opportunity_cost > 0)
            net_benefit = sum(s.net_impact for s in result.swap_decisions) - sum(r.opportunity_cost for r in result.rejection_decisions)

            results.append({
                'threshold': threshold,
                'total_pl': result.total_pl,
                'swaps': len(result.swap_decisions),
                'rejections': len(result.rejection_decisions),
                'good_swaps': good_swaps,
                'bad_swaps': bad_swaps,
                'good_rejections': good_rejections,
                'missed_opps': missed_opps,
                'net_benefit': net_benefit
            })

        # Populate tree
        for r in results:
            self.sensitivity_tree.insert('', 'end', values=(
                r['threshold'],
                f"${r['total_pl']:,.2f}",
                r['swaps'],
                r['rejections'],
                r['good_swaps'],
                r['bad_swaps'],
                r['good_rejections'],
                r['missed_opps'],
                f"${r['net_benefit']:+,.2f}"
            ))

        # Find best threshold
        best = max(results, key=lambda r: r['total_pl'])
        messagebox.showinfo("Analysis Complete",
                          f"Sensitivity analysis complete!\n\nBest threshold: {best['threshold']}\nTotal P/L: ${best['total_pl']:,.2f}")

    def _on_trade_selected(self, event):
        """Handle trade selection in treeview."""
        selection = self.trades_tree.selection()
        if not selection or not self.current_report:
            return

        # Get selected trade
        item = self.trades_tree.item(selection[0])
        trade_id = item['values'][0]

        # Find the trade analysis
        trade = next((t for t in self.current_report.trades if t.trade_id == trade_id), None)
        if trade and trade.daily_timeline:
            # Update timeline chart for selected trade
            timeline_dicts = [r.to_dict() for r in trade.daily_timeline]
            params = self._get_current_params()
            plot_vulnerability_timeline(
                self.chart_timeline,
                timeline_dicts,
                params.swap_threshold,
                params.immunity_days,
                f"Timeline: {trade_id}"
            )

    def _export_trade_analysis(self):
        """Export trade analysis to CSV."""
        if not self.current_report:
            messagebox.showwarning("No Report", "Please run an analysis first.")
            return

        try:
            import csv
            from datetime import datetime
            from pathlib import Path

            # Create output directory
            output_dir = Path('reports/vulnerability')
            output_dir.mkdir(parents=True, exist_ok=True)

            # Generate filename with timestamp
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_file = output_dir / f'trade_analysis_{timestamp}.csv'

            # Write CSV
            with open(output_file, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)

                # Write header
                writer.writerow([
                    'Trade ID',
                    'Symbol',
                    'Natural P/L ($)',
                    'Vuln Exit P/L ($)',
                    'P/L Difference ($)',
                    'Benefit Category',
                    'Would Have Been Swapped',
                    'Entry Date',
                    'Natural Exit Date',
                    'Vuln Exit Date',
                    'Entry Price',
                    'Natural Exit Price',
                    'Vuln Exit Price'
                ])

                # Write trade data
                for trade in self.current_report.trades:
                    # Calculate vulnerability exit price if applicable
                    vuln_exit_price = ''
                    if trade.first_vulnerable_date and trade.entry_price:
                        vuln_exit_price = f"{trade.entry_price * (1 + trade.first_vulnerable_pl_pct / 100):.2f}"

                    writer.writerow([
                        trade.trade_id,
                        trade.symbol,
                        f"{trade.pl_natural_dollars:.2f}",
                        f"{trade.pl_if_exited_at_vulnerability_dollars:.2f}",
                        f"{trade.pl_difference_dollars:+.2f}",
                        trade.benefit_category,
                        'Yes' if trade.would_have_been_swapped else 'No',
                        trade.entry_date.strftime('%Y-%m-%d') if trade.entry_date else '',
                        trade.exit_date_natural.strftime('%Y-%m-%d') if trade.exit_date_natural else '',
                        trade.first_vulnerable_date.strftime('%Y-%m-%d') if trade.first_vulnerable_date else '',
                        f"{trade.entry_price:.2f}" if trade.entry_price else '',
                        f"{trade.exit_price_natural:.2f}" if trade.exit_price_natural else '',
                        vuln_exit_price
                    ])

            messagebox.showinfo(
                "Export Successful",
                f"Trade analysis exported to:\n{output_file}"
            )

        except Exception as e:
            messagebox.showerror("Export Failed", f"Error exporting trade analysis:\n{str(e)}")

    def _export_report(self):
        """Export the analysis report."""
        if not self.current_report:
            messagebox.showwarning("No Report", "Please run an analysis first.")
            return

        filepath = filedialog.asksaveasfilename(
            title="Export Report",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("CSV files", "*.csv"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            if filepath.endswith('.csv'):
                self.current_report.to_csv(Path(filepath))
            else:
                self.current_report.to_json(Path(filepath))
            messagebox.showinfo("Success", f"Report exported to {filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def _export_params(self):
        """Export current parameters to JSON."""
        filepath = filedialog.asksaveasfilename(
            title="Export Parameters",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            params = self._get_current_params()
            params.to_json(Path(filepath))
            messagebox.showinfo("Success", f"Parameters exported to {filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {str(e)}")

    def _import_params(self):
        """Import parameters from JSON."""
        filepath = filedialog.askopenfilename(
            title="Import Parameters",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            self.params = VulnerabilityScoreParams.from_json(Path(filepath))
            self.immunity_var.set(self.params.immunity_days)
            self.threshold_var.set(self.params.swap_threshold)
            self.base_score_var.set(self.params.base_score)
            self._load_feature_values()
            messagebox.showinfo("Success", "Parameters imported successfully")
        except Exception as e:
            messagebox.showerror("Error", f"Import failed: {str(e)}")

    def _find_optimal(self):
        """Find optimal parameters using grid search."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Show optimization objective dialog
        dialog = tk.Toplevel(self.root)
        dialog.title("Find Optimal Parameters")
        dialog.geometry("450x400")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Optimization Settings", font=('TkDefaultFont', 12, 'bold')).pack(pady=10)

        # Objective selection
        obj_frame = ttk.LabelFrame(dialog, text="Optimization Objective", padding=10)
        obj_frame.pack(fill=tk.X, padx=10, pady=5)

        objective_var = tk.StringVar(value="BALANCED")
        objectives = [
            ("BALANCED", "Balance P/L improvement with accuracy"),
            ("MAXIMIZE_PL_DIFF", "Maximize P/L difference"),
            ("MAXIMIZE_ACCURACY", "Maximize decision accuracy"),
            ("CONSERVATIVE", "Prioritize avoiding harm"),
            ("AGGRESSIVE", "Prioritize capturing gains"),
            ("MINIMIZE_FALSE_POSITIVES", "Minimize false positive rate"),
        ]

        for value, desc in objectives:
            ttk.Radiobutton(obj_frame, text=f"{value}: {desc}",
                           variable=objective_var, value=value).pack(anchor='w', pady=2)

        # Parameter ranges
        range_frame = ttk.LabelFrame(dialog, text="Parameter Ranges", padding=10)
        range_frame.pack(fill=tk.X, padx=10, pady=5)

        ttk.Label(range_frame, text="Immunity Days:").grid(row=0, column=0, sticky='w', pady=2)
        imm_min_var = tk.IntVar(value=3)
        imm_max_var = tk.IntVar(value=14)
        ttk.Spinbox(range_frame, from_=1, to=30, textvariable=imm_min_var, width=5).grid(row=0, column=1, padx=2)
        ttk.Label(range_frame, text="to").grid(row=0, column=2)
        ttk.Spinbox(range_frame, from_=1, to=30, textvariable=imm_max_var, width=5).grid(row=0, column=3, padx=2)

        ttk.Label(range_frame, text="Swap Threshold:").grid(row=1, column=0, sticky='w', pady=2)
        thr_min_var = tk.IntVar(value=30)
        thr_max_var = tk.IntVar(value=70)
        ttk.Spinbox(range_frame, from_=10, to=95, textvariable=thr_min_var, width=5).grid(row=1, column=1, padx=2)
        ttk.Label(range_frame, text="to").grid(row=1, column=2)
        ttk.Spinbox(range_frame, from_=10, to=95, textvariable=thr_max_var, width=5).grid(row=1, column=3, padx=2)

        result_var = tk.BooleanVar(value=False)

        def run_optimization():
            result_var.set(True)
            dialog.destroy()

        ttk.Button(dialog, text="Run Optimization", command=run_optimization).pack(pady=20)
        ttk.Button(dialog, text="Cancel", command=dialog.destroy).pack()

        self.root.wait_window(dialog)

        if not result_var.get():
            return

        # Get selected objective
        obj_name = objective_var.get()
        objective = OptimizationObjective[obj_name]

        # Calculate number of configurations
        immunity_range = (imm_min_var.get(), imm_max_var.get())
        threshold_range = (thr_min_var.get(), thr_max_var.get())
        n_immunity = (immunity_range[1] - immunity_range[0]) // 2 + 1
        n_threshold = int((threshold_range[1] - threshold_range[0]) // 10) + 1
        total_configs = n_immunity * n_threshold

        # Create progress dialog
        progress = ProgressDialog(
            self.root,
            "Finding Optimal Parameters",
            f"Testing {total_configs} configurations...",
            determinate=True,
            cancellable=True
        )
        progress.show()

        try:
            progress.update(5, "Initializing optimizer...")
            analyzer = VulnerabilityAnalyzer()

            # Run optimization with progress tracking
            config_count = [0]  # Use list for closure

            def run_optimization():
                best_params = None
                best_report = None
                best_score = float('-inf')
                all_results = []

                from Classes.VulnerabilityScorer.analyzer import get_objective_scorer

                scorer = get_objective_scorer(objective)

                for immunity in range(immunity_range[0], immunity_range[1] + 1, 2):
                    threshold = threshold_range[0]
                    while threshold <= threshold_range[1]:
                        if progress.cancelled:
                            return None, None, {'search_space_size': config_count[0]}

                        config_count[0] += 1
                        pct = 5 + (config_count[0] / total_configs) * 85
                        progress.update(pct, f"Testing config {config_count[0]}/{total_configs}: immunity={immunity}, threshold={threshold}")

                        params = VulnerabilityScoreParams(
                            name=f"Grid_{immunity}d_{threshold:.0f}t",
                            immunity_days=immunity,
                            swap_threshold=threshold
                        )

                        try:
                            analyzer.update_params(params)
                            report = analyzer.analyze_backtest(self.trades, self.price_data)
                            score, passes = scorer(report)
                            all_results.append({'params': params, 'report': report, 'score': score, 'passes_constraints': passes})

                            if passes and score > best_score:
                                best_score = score
                                best_params = params
                                best_report = report
                        except Exception:
                            pass

                        threshold += 10

                if best_params is None and all_results:
                    valid = [r for r in all_results if r['report'] is not None]
                    if valid:
                        best_result = max(valid, key=lambda r: r['score'])
                        best_params = best_result['params']
                        best_report = best_result['report']

                return best_params, best_report, {'search_space_size': len(all_results), 'best_score': best_score}

            best_params, best_report, details = run_optimization()

            if progress.cancelled:
                progress.close()
                return

            progress.update(95, "Updating UI...")

            # Update UI with best params
            if best_params:
                self.params = best_params
                self.immunity_var.set(best_params.immunity_days)
                self.threshold_var.set(best_params.swap_threshold)
                self._load_feature_values()

            if best_report:
                self.current_report = best_report
                self._update_summary()
                self._update_trades_table()
                self._update_charts()
                self._update_swaps_table()

            progress.close()

            if best_params and best_report:
                messagebox.showinfo(
                    "Optimization Complete",
                    f"Optimal parameters found:\n\n"
                    f"Objective: {obj_name}\n"
                    f"Configurations Tested: {details['search_space_size']}\n"
                    f"Immunity Days: {best_params.immunity_days}\n"
                    f"Swap Threshold: {best_params.swap_threshold}\n"
                    f"P/L Improvement: ${best_report.total_pl_difference:,.2f}\n"
                    f"Accuracy: {best_report.accuracy*100:.1f}%"
                )
            else:
                messagebox.showwarning("Optimization", "No valid configuration found.")

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Optimization failed: {str(e)}")
            traceback.print_exc()

    def _compare_presets(self):
        """Compare all presets."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        n_presets = len(VULNERABILITY_SCORE_PRESETS)
        progress = ProgressDialog(
            self.root,
            "Comparing Presets",
            f"Testing {n_presets} presets...",
            determinate=True,
            cancellable=False
        )
        progress.show()

        try:
            results = []
            for i, (name, params) in enumerate(VULNERABILITY_SCORE_PRESETS.items()):
                pct = (i / n_presets) * 100
                progress.update(pct, f"Testing preset: {name}...")

                analyzer = VulnerabilityAnalyzer(params)
                report = analyzer.analyze_backtest(self.trades, self.price_data)
                results.append({
                    'name': name,
                    'affected': report.trades_affected_by_vulnerability,
                    'pl_diff': report.total_pl_difference,
                    'accuracy': report.accuracy
                })

            progress.close()

            # Show comparison
            comparison_text = "Preset Comparison:\n\n"
            comparison_text += f"{'Preset':<20} {'Affected':<10} {'P/L Diff':<15} {'Accuracy':<10}\n"
            comparison_text += "-" * 55 + "\n"

            for r in results:
                comparison_text += f"{r['name']:<20} {r['affected']:<10} ${r['pl_diff']:<14,.2f} {r['accuracy']*100:.1f}%\n"

            # Show in a dialog
            dialog = tk.Toplevel(self.root)
            dialog.title("Preset Comparison")
            dialog.geometry("500x300")

            text = tk.Text(dialog, font=('Consolas', 10))
            text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            text.insert('1.0', comparison_text)
            text.configure(state='disabled')

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Comparison failed: {str(e)}")
            traceback.print_exc()

    def _show_about(self):
        """Show about dialog."""
        messagebox.showinfo(
            "About",
            "Vulnerability Score Modeler & Optimizer\n\n"
            "A tool for analyzing and optimizing vulnerability score parameters "
            "for portfolio backtesting.\n\n"
            "Features:\n"
            "- Multi-backtest loading\n"
            "- Custom optimization objectives\n"
            "- Custom presets\n"
            "- Sensitivity analysis\n"
            "- Walk-forward validation\n"
            "- Feature importance\n"
            "- Monte Carlo simulation\n"
            "- Trade grouping analysis\n\n"
            "Part of the BackTesting Framework"
        )

    # =========================================================================
    # NEW FEATURES
    # =========================================================================

    def _load_multiple_trade_logs(self):
        """Load multiple trade log files."""
        filepaths = filedialog.askopenfilenames(
            title="Select Trade Logs (multiple)",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=str(Path('logs'))
        )

        if not filepaths:
            return

        try:
            self.data_loader = BacktestTradeLoader(self.data_directory)
            paths = [Path(fp) for fp in filepaths]
            labels = [p.stem for p in paths]

            self.trades, self.price_data, report = self.data_loader.load_multiple_trade_logs(
                paths, labels
            )
            self.loaded_backtests = labels

            if report.warnings:
                messagebox.showwarning("Data Warning", report.get_summary())

            self.data_status_var.set(f"Loaded {len(self.trades)} trades from {len(labels)} backtests")
            messagebox.showinfo(
                "Success",
                f"Loaded {len(self.trades)} trades from {len(labels)} backtests:\n"
                + "\n".join(f"- {l}" for l in labels)
            )

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load trade logs:\n{str(e)}")
            traceback.print_exc()

    def _save_current_preset(self):
        """Save current parameters as a custom preset."""
        name = simpledialog.askstring(
            "Save Preset",
            "Enter a name for this preset:",
            parent=self.root
        )

        if not name:
            return

        description = simpledialog.askstring(
            "Save Preset",
            "Enter a description (optional):",
            parent=self.root
        ) or ""

        try:
            params = self._get_current_params()
            params.name = name
            params.description = description

            filepath = self.preset_manager.save_preset(params, overwrite=False)
            self._load_presets()  # Refresh preset list

            messagebox.showinfo("Success", f"Preset '{name}' saved to {filepath}")

        except ValueError as e:
            if "already exists" in str(e):
                if messagebox.askyesno("Overwrite?", f"Preset '{name}' exists. Overwrite?"):
                    filepath = self.preset_manager.save_preset(params, overwrite=True)
                    self._load_presets()
                    messagebox.showinfo("Success", f"Preset '{name}' updated.")
            else:
                messagebox.showerror("Error", str(e))
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save preset: {str(e)}")

    def _manage_presets(self):
        """Open preset management dialog."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Manage Presets")
        dialog.geometry("500x400")
        dialog.transient(self.root)

        # Preset list
        list_frame = ttk.LabelFrame(dialog, text="Custom Presets", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        preset_listbox = tk.Listbox(list_frame, height=15)
        preset_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(list_frame, orient='vertical', command=preset_listbox.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        preset_listbox.configure(yscrollcommand=scrollbar.set)

        # Populate list
        custom_presets = self.preset_manager.get_custom_presets()
        for name in custom_presets.keys():
            preset_listbox.insert(tk.END, name)

        # Buttons
        btn_frame = ttk.Frame(dialog, padding=10)
        btn_frame.pack(fill=tk.X)

        def delete_selected():
            selection = preset_listbox.curselection()
            if not selection:
                return
            name = preset_listbox.get(selection[0])
            if messagebox.askyesno("Delete?", f"Delete preset '{name}'?"):
                try:
                    self.preset_manager.delete_preset(name)
                    preset_listbox.delete(selection[0])
                    self._load_presets()
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        def rename_selected():
            selection = preset_listbox.curselection()
            if not selection:
                return
            old_name = preset_listbox.get(selection[0])
            new_name = simpledialog.askstring("Rename", f"New name for '{old_name}':")
            if new_name:
                try:
                    self.preset_manager.rename_preset(old_name, new_name)
                    preset_listbox.delete(selection[0])
                    preset_listbox.insert(selection[0], new_name)
                    self._load_presets()
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        def duplicate_selected():
            selection = preset_listbox.curselection()
            if not selection:
                return
            source_name = preset_listbox.get(selection[0])
            new_name = simpledialog.askstring("Duplicate", f"Name for copy of '{source_name}':")
            if new_name:
                try:
                    self.preset_manager.duplicate_preset(source_name, new_name)
                    preset_listbox.insert(tk.END, new_name)
                    self._load_presets()
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        ttk.Button(btn_frame, text="Delete", command=delete_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Rename", command=rename_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Duplicate", command=duplicate_selected).pack(side=tk.LEFT, padx=5)
        ttk.Button(btn_frame, text="Close", command=dialog.destroy).pack(side=tk.RIGHT, padx=5)

    def _import_preset(self):
        """Import a preset from a JSON file."""
        filepath = filedialog.askopenfilename(
            title="Import Preset",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if not filepath:
            return

        try:
            preset = self.preset_manager.import_preset(Path(filepath))
            self._load_presets()
            messagebox.showinfo("Success", f"Imported preset '{preset.name}'")
        except Exception as e:
            messagebox.showerror("Error", f"Import failed: {str(e)}")

    def _export_preset(self):
        """Export a preset to a JSON file."""
        # Select preset to export
        presets = self.preset_manager.get_preset_names()
        dialog = tk.Toplevel(self.root)
        dialog.title("Export Preset")
        dialog.geometry("300x150")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Select preset to export:").pack(pady=10)

        preset_var = tk.StringVar(value=presets[0] if presets else "")
        combo = ttk.Combobox(dialog, textvariable=preset_var, values=presets, state='readonly', width=30)
        combo.pack(pady=5)

        def do_export():
            name = preset_var.get()
            dialog.destroy()

            filepath = filedialog.asksaveasfilename(
                title=f"Export {name}",
                defaultextension=".json",
                initialfile=f"{name.replace(' ', '_')}.json",
                filetypes=[("JSON files", "*.json")]
            )
            if filepath:
                try:
                    self.preset_manager.export_preset(name, Path(filepath))
                    messagebox.showinfo("Success", f"Exported to {filepath}")
                except Exception as e:
                    messagebox.showerror("Error", str(e))

        ttk.Button(dialog, text="Export", command=do_export).pack(pady=10)

    def _run_sensitivity_analysis(self):
        """Run sensitivity analysis on parameters."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Dialog for sensitivity settings
        dialog = tk.Toplevel(self.root)
        dialog.title("Sensitivity Analysis")
        dialog.geometry("400x300")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Parameter to Analyze:").pack(pady=10)

        param_var = tk.StringVar(value="immunity_days")
        for param in ["immunity_days", "swap_threshold"]:
            ttk.Radiobutton(dialog, text=param, variable=param_var, value=param).pack(anchor='w', padx=20)

        ttk.Label(dialog, text="Metric to Track:").pack(pady=10)

        metric_var = tk.StringVar(value="total_pl_difference")
        for metric in ["total_pl_difference", "accuracy", "false_positive_rate"]:
            ttk.Radiobutton(dialog, text=metric, variable=metric_var, value=metric).pack(anchor='w', padx=20)

        result_var = tk.BooleanVar(value=False)

        def run():
            result_var.set(True)
            dialog.destroy()

        ttk.Button(dialog, text="Run Analysis", command=run).pack(pady=20)

        self.root.wait_window(dialog)

        if not result_var.get():
            return

        progress = ProgressDialog(
            self.root,
            "Sensitivity Analysis",
            "Running sensitivity analysis...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Analyzing {param_var.get()} sensitivity...")
            results = analyzer.run_sensitivity_analysis(
                self.trades, self.price_data,
                base_params=params,
                param_name=param_var.get(),
                metric=metric_var.get()
            )

            self.sensitivity_results = results
            progress.close()

            # Show results
            self._show_sensitivity_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")
            traceback.print_exc()

    def _show_sensitivity_results(self, results: Dict[str, Any]):
        """Display sensitivity analysis results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Sensitivity Analysis Results")
        dialog.geometry("600x500")

        # Summary
        summary = f"""
Sensitivity Analysis Results
{'='*40}

Parameter: {results.get('param_name', 'N/A')}
Metric: {results.get('metric_name', 'N/A')}

Best Value: {results.get('best_value', 'N/A')}
Best Metric: {results.get('best_metric', 'N/A'):.4f}

Sensitivity Score: {results.get('sensitivity_score', 0):.4f}
(Higher = more sensitive to parameter changes)

Values Tested: {len(results.get('param_values', []))}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        # Add table of results
        if 'param_values' in results and 'metric_values' in results:
            text.insert(tk.END, f"\n{'Value':<15} {'Metric':<20}\n")
            text.insert(tk.END, "-" * 35 + "\n")
            for pv, mv in zip(results['param_values'], results['metric_values']):
                text.insert(tk.END, f"{pv:<15} {mv:<20.4f}\n")

        text.configure(state='disabled')

    def _run_walk_forward(self):
        """Run walk-forward validation."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        if len(self.trades) < 25:
            messagebox.showwarning("Insufficient Data",
                                  f"Need at least 25 trades for walk-forward validation.\nYou have {len(self.trades)}.")
            return

        n_folds = simpledialog.askinteger(
            "Walk-Forward Validation",
            "Number of folds (3-10):",
            initialvalue=5, minvalue=3, maxvalue=10,
            parent=self.root
        )

        if not n_folds:
            return

        progress = ProgressDialog(
            self.root,
            "Walk-Forward Validation",
            f"Running {n_folds}-fold validation...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Processing {n_folds} folds (this may take a while)...")
            results = analyzer.run_walk_forward_validation(
                self.trades, self.price_data,
                n_folds=n_folds
            )

            self.walk_forward_results = results
            progress.close()

            # Show results
            self._show_walk_forward_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Validation failed: {str(e)}")
            traceback.print_exc()

    def _show_walk_forward_results(self, results: Dict[str, Any]):
        """Display walk-forward validation results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Walk-Forward Validation Results")
        dialog.geometry("700x500")

        overall = results.get('overall_metrics', {})
        summary = f"""
Walk-Forward Validation Results
{'='*50}

Number of Folds: {results.get('n_folds', 0)}
Parameter Stability: {results.get('parameter_stability', 0):.2%}

Out-of-Sample Performance:
  Average P/L: ${overall.get('avg_out_of_sample_pl', 0):,.2f}
  Average Accuracy: {overall.get('avg_out_of_sample_accuracy', 0):.2%}
  Overfitting Rate: {overall.get('overfitting_rate', 0):.2%}

Recommendation: {results.get('recommendation', 'N/A')}

Per-Fold Results:
{'='*50}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        for fold in results.get('fold_results', []):
            if 'error' in fold:
                text.insert(tk.END, f"\nFold {fold['fold']}: Error - {fold['error']}\n")
            else:
                text.insert(tk.END, f"\nFold {fold['fold']}:\n")
                text.insert(tk.END, f"  Train: {fold['train_trades']} trades, P/L: ${fold['train_pl_diff']:,.2f}\n")
                text.insert(tk.END, f"  Test: {fold['test_trades']} trades, P/L: ${fold['test_pl_diff']:,.2f}\n")
                text.insert(tk.END, f"  Overfitting: {'Yes' if fold.get('is_overfitting') else 'No'}\n")

        text.configure(state='disabled')

    def _run_feature_importance(self):
        """Run feature importance analysis."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        progress = ProgressDialog(
            self.root,
            "Feature Importance",
            "Calculating feature importance...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message="Running ablation analysis for each feature...")
            results = analyzer.calculate_feature_importance(
                self.trades, self.price_data,
                method='ablation'
            )

            self.feature_importance_results = results
            progress.close()

            # Show results
            self._show_feature_importance_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")
            traceback.print_exc()

    def _show_feature_importance_results(self, results: Dict[str, Any]):
        """Display feature importance results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Feature Importance Results")
        dialog.geometry("500x400")

        summary = f"""
Feature Importance Analysis
{'='*40}

Method: {results.get('method', 'ablation')}
Baseline P/L: ${results.get('baseline_pl', 0):,.2f}

Most Important: {results.get('most_important', 'N/A')}
Least Important: {results.get('least_important', 'N/A')}

Feature Rankings:
{'='*40}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        for feature, score in results.get('ranking', []):
            bar = '' * int(score / 10) + '' * (10 - int(score / 10))
            text.insert(tk.END, f"{feature:<25} {bar} {score:.1f}%\n")

        text.configure(state='disabled')

    def _run_monte_carlo(self):
        """Run Monte Carlo simulation."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        if len(self.trades) < 5:
            messagebox.showwarning("Insufficient Data", "Need at least 5 trades for Monte Carlo.")
            return

        n_sims = simpledialog.askinteger(
            "Monte Carlo Simulation",
            "Number of simulations (100-10000):",
            initialvalue=1000, minvalue=100, maxvalue=10000,
            parent=self.root
        )

        if not n_sims:
            return

        progress = ProgressDialog(
            self.root,
            "Monte Carlo Simulation",
            f"Running {n_sims} simulations...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Running {n_sims} simulations (this may take a while)...")
            results = analyzer.run_monte_carlo_analysis(
                self.trades, self.price_data,
                n_simulations=n_sims
            )

            self.monte_carlo_results = results
            progress.close()

            # Show results
            self._show_monte_carlo_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Simulation failed: {str(e)}")
            traceback.print_exc()

    def _show_monte_carlo_results(self, results: Dict[str, Any]):
        """Display Monte Carlo simulation results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Monte Carlo Simulation Results")
        dialog.geometry("500x450")

        stats = results.get('statistics', {})
        ci = results.get('confidence_intervals', {})

        summary = f"""
Monte Carlo Simulation Results
{'='*40}

Simulations Run: {results.get('n_simulations', 0)}

P/L Distribution Statistics:
  Mean: ${stats.get('mean', 0):,.2f}
  Median: ${stats.get('median', 0):,.2f}
  Std Dev: ${stats.get('std', 0):,.2f}
  Min: ${stats.get('min', 0):,.2f}
  Max: ${stats.get('max', 0):,.2f}

Confidence Intervals:
  5th percentile: ${ci.get('5%', 0):,.2f}
  25th percentile: ${ci.get('25%', 0):,.2f}
  50th percentile: ${ci.get('50%', 0):,.2f}
  75th percentile: ${ci.get('75%', 0):,.2f}
  95th percentile: ${ci.get('95%', 0):,.2f}

Probabilities:
  Positive P/L Impact: {results.get('probability_positive', 0):.1%}
  Significant Gain (>$100): {results.get('probability_significant_gain', 0):.1%}
  Significant Loss (<-$100): {results.get('probability_significant_loss', 0):.1%}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)
        text.configure(state='disabled')

    def _run_trade_grouping(self):
        """Run trade grouping analysis."""
        if not self.trades:
            messagebox.showwarning("No Data", "Please load a trade log first.")
            return

        # Dialog for grouping criteria
        dialog = tk.Toplevel(self.root)
        dialog.title("Trade Grouping Analysis")
        dialog.geometry("350x250")
        dialog.transient(self.root)
        dialog.grab_set()

        ttk.Label(dialog, text="Group Trades By:", font=('TkDefaultFont', 10, 'bold')).pack(pady=10)

        criteria_var = tk.StringVar(value="symbol")
        criteria_options = [
            ("symbol", "By Security Symbol"),
            ("month", "By Entry Month"),
            ("quarter", "By Entry Quarter"),
            ("year", "By Entry Year"),
            ("duration", "By Trade Duration"),
            ("pl_bucket", "By P/L Range"),
        ]

        for value, label in criteria_options:
            ttk.Radiobutton(dialog, text=label, variable=criteria_var, value=value).pack(anchor='w', padx=20)

        result_var = tk.BooleanVar(value=False)

        def run():
            result_var.set(True)
            dialog.destroy()

        ttk.Button(dialog, text="Run Analysis", command=run).pack(pady=15)

        self.root.wait_window(dialog)

        if not result_var.get():
            return

        progress = ProgressDialog(
            self.root,
            "Trade Grouping Analysis",
            f"Analyzing trades by {criteria_var.get()}...",
            determinate=False,
            cancellable=False
        )
        progress.show()

        try:
            progress.update(message="Initializing...")
            params = self._get_current_params()
            analyzer = VulnerabilityAnalyzer(params)

            progress.update(message=f"Grouping and analyzing trades by {criteria_var.get()}...")
            results = analyzer.run_trade_grouping_analysis(
                self.trades, self.price_data,
                grouping_criteria=criteria_var.get()
            )

            self.grouping_results = results
            progress.close()

            # Show results
            self._show_grouping_results(results)

        except Exception as e:
            progress.close()
            messagebox.showerror("Error", f"Analysis failed: {str(e)}")
            traceback.print_exc()

    def _show_grouping_results(self, results: Dict[str, Any]):
        """Display trade grouping analysis results."""
        dialog = tk.Toplevel(self.root)
        dialog.title("Trade Grouping Analysis Results")
        dialog.geometry("700x500")

        best = results.get('best_group', {})
        worst = results.get('worst_group', {})

        summary = f"""
Trade Grouping Analysis Results
{'='*50}

Grouping Criteria: {results.get('grouping_criteria', 'N/A')}
Number of Groups: {results.get('n_groups', 0)}

Best Group: {best.get('group', 'N/A')}
  Trades: {best.get('n_trades', 0)}
  P/L Difference: ${best.get('pl_difference', 0):,.2f}

Worst Group: {worst.get('group', 'N/A')}
  Trades: {worst.get('n_trades', 0)}
  P/L Difference: ${worst.get('pl_difference', 0):,.2f}

Recommendation: {results.get('recommendation', 'N/A')}

Group Summary:
{'='*50}
{'Group':<20} {'Trades':<8} {'P/L Diff':<15} {'Accuracy':<10}
{'-'*53}
"""

        text = tk.Text(dialog, wrap=tk.WORD, font=('Consolas', 10))
        text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text.insert('1.0', summary)

        for group in results.get('summary', []):
            if 'error' not in group:
                text.insert(tk.END,
                    f"{group['group']:<20} {group['n_trades']:<8} "
                    f"${group['pl_difference']:<14,.2f} {group['accuracy']:.1%}\n"
                )

        text.configure(state='disabled')


def main():
    """Main entry point."""
    root = tk.Tk()
    style = ttk.Style()
    style.theme_use('clam')

    app = VulnerabilityModelerGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
