"""
Vulnerability Score Calculator for capital contention resolution.

This module implements the vulnerability score logic that determines
which positions can be closed when a new signal arrives but no capital
is available.
"""
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional, Tuple

from ..Config.capital_contention import VulnerabilityScoreConfig, EnhancedVulnerabilityConfig
from ..Models.position import Position


@dataclass
class VulnerabilityResult:
    """Result of vulnerability score calculation for a position."""
    symbol: str
    score: float
    days_open: int
    days_past_immunity: int
    current_pl_percent: float
    is_immune: bool
    is_vulnerable: bool  # score < swap_threshold
    decay_applied: float
    decay_type: str  # 'none' (immune), 'fast' (stagnant), 'slow' (performing)


@dataclass
class SwapDecision:
    """Decision result for whether to swap a position."""
    should_swap: bool
    position_to_close: Optional[str]  # Symbol of position to close
    position_score: Optional[float]
    reason: str
    all_scores: Dict[str, VulnerabilityResult]


class VulnerabilityScoreCalculator:
    """
    Calculates vulnerability scores for open positions.

    The vulnerability score determines how "safe" a position is from
    being closed when capital is needed for a new signal.

    Score interpretation:
    - 100: Immune (within immunity period)
    - 50-99: Healthy but aging
    - 1-49: Vulnerable (can be swapped)
    - 0: Extremely vulnerable (should be closed)

    The score decays over time, with stagnant trades (low profit)
    decaying faster than performing trades.
    """

    def __init__(self, config):
        """
        Initialize the calculator.

        Args:
            config: Vulnerability score configuration (VulnerabilityScoreConfig or EnhancedVulnerabilityConfig)
        """
        # Handle both old and new config types
        if isinstance(config, EnhancedVulnerabilityConfig):
            # Convert enhanced config to simple config for backward compatibility
            self.config = config.to_simple_config()
        elif isinstance(config, VulnerabilityScoreConfig):
            self.config = config
        else:
            # Try to treat it as VulnerabilityScoreConfig
            self.config = config

    def calculate_score(self, position: Position, current_price: float,
                        current_date: datetime) -> VulnerabilityResult:
        """
        Calculate the vulnerability score for a single position.

        The algorithm:
        1. Calculate days since entry
        2. If within immunity period (e.g., 7 days), return base score (100)
        3. Calculate current P/L percentage
        4. If P/L < min_profit_threshold: apply fast decay
        5. If P/L >= min_profit_threshold: apply slow decay
        6. Clamp score to [0, base_score]

        Args:
            position: The open position to evaluate
            current_price: Current market price
            current_date: Current date

        Returns:
            VulnerabilityResult with score and analysis details
        """
        # Calculate trade age
        days_open = (current_date - position.entry_date).days

        # Immunity period check
        if days_open <= self.config.immunity_days:
            return VulnerabilityResult(
                symbol=position.symbol,
                score=self.config.base_score,
                days_open=days_open,
                days_past_immunity=0,
                current_pl_percent=self._calculate_pl_percent(position, current_price),
                is_immune=True,
                is_vulnerable=False,
                decay_applied=0.0,
                decay_type='none'
            )

        # Calculate days past immunity
        days_past_immunity = days_open - self.config.immunity_days

        # Calculate current P/L percentage
        current_pl_percent = self._calculate_pl_percent(position, current_price)

        # Determine decay rate based on performance
        if current_pl_percent < self.config.min_profit_threshold:
            # Stagnant/low performance - fast decay
            decay = days_past_immunity * self.config.decay_rate_fast
            decay_type = 'fast'
        else:
            # Performing/high profit - slow decay
            decay = days_past_immunity * self.config.decay_rate_slow
            decay_type = 'slow'

        # Calculate final score
        score = self.config.base_score - decay
        score = max(0.0, score)  # Clamp to minimum of 0

        return VulnerabilityResult(
            symbol=position.symbol,
            score=score,
            days_open=days_open,
            days_past_immunity=days_past_immunity,
            current_pl_percent=current_pl_percent,
            is_immune=False,
            is_vulnerable=score < self.config.swap_threshold,
            decay_applied=decay,
            decay_type=decay_type
        )

    def _calculate_pl_percent(self, position: Position, current_price: float) -> float:
        """
        Calculate position P/L percentage.

        Args:
            position: Position to evaluate
            current_price: Current market price

        Returns:
            P/L as decimal (e.g., 0.02 for 2%)
        """
        if position.entry_price == 0:
            return 0.0
        return (current_price - position.entry_price) / position.entry_price

    def calculate_all_scores(self, positions: Dict[str, Position],
                             current_prices: Dict[str, float],
                             current_date: datetime) -> Dict[str, VulnerabilityResult]:
        """
        Calculate vulnerability scores for all positions.

        Args:
            positions: Dict mapping symbol to Position
            current_prices: Dict mapping symbol to current price
            current_date: Current date

        Returns:
            Dict mapping symbol to VulnerabilityResult
        """
        results = {}
        for symbol, position in positions.items():
            if symbol in current_prices:
                results[symbol] = self.calculate_score(
                    position, current_prices[symbol], current_date
                )
        return results

    def find_weakest_position(self, positions: Dict[str, Position],
                              current_prices: Dict[str, float],
                              current_date: datetime) -> Optional[Tuple[str, VulnerabilityResult]]:
        """
        Find the position with the lowest vulnerability score.

        Args:
            positions: Dict mapping symbol to Position
            current_prices: Dict mapping symbol to current price
            current_date: Current date

        Returns:
            Tuple of (symbol, VulnerabilityResult) for weakest position, or None if no positions
        """
        if not positions:
            return None

        scores = self.calculate_all_scores(positions, current_prices, current_date)

        if not scores:
            return None

        # Find minimum score
        weakest_symbol = min(scores.keys(), key=lambda s: scores[s].score)
        return (weakest_symbol, scores[weakest_symbol])

    def should_swap(self, positions: Dict[str, Position],
                    current_prices: Dict[str, float],
                    current_date: datetime,
                    new_signal_symbol: str) -> SwapDecision:
        """
        Determine if a position should be swapped for a new signal.

        The swap only occurs if:
        1. There is at least one position
        2. The weakest position has a score below swap_threshold
        3. The weakest position is not immune

        Args:
            positions: Dict mapping symbol to Position
            current_prices: Dict mapping symbol to current price
            current_date: Current date
            new_signal_symbol: Symbol of the new signal requesting capital

        Returns:
            SwapDecision indicating whether to swap and which position
        """
        if not positions:
            return SwapDecision(
                should_swap=False,
                position_to_close=None,
                position_score=None,
                reason="No open positions to swap",
                all_scores={}
            )

        # Calculate all scores
        all_scores = self.calculate_all_scores(positions, current_prices, current_date)

        if not all_scores:
            return SwapDecision(
                should_swap=False,
                position_to_close=None,
                position_score=None,
                reason="Could not calculate scores (missing prices)",
                all_scores={}
            )

        # Find weakest position
        weakest_symbol = min(all_scores.keys(), key=lambda s: all_scores[s].score)
        weakest_result = all_scores[weakest_symbol]

        # Check if immune
        if weakest_result.is_immune:
            return SwapDecision(
                should_swap=False,
                position_to_close=None,
                position_score=weakest_result.score,
                reason=f"All positions are immune (weakest: {weakest_symbol} with score {weakest_result.score:.1f})",
                all_scores=all_scores
            )

        # Check if below swap threshold
        if not weakest_result.is_vulnerable:
            return SwapDecision(
                should_swap=False,
                position_to_close=None,
                position_score=weakest_result.score,
                reason=f"No vulnerable positions (weakest: {weakest_symbol} with score {weakest_result.score:.1f} >= threshold {self.config.swap_threshold})",
                all_scores=all_scores
            )

        # We can swap
        return SwapDecision(
            should_swap=True,
            position_to_close=weakest_symbol,
            position_score=weakest_result.score,
            reason=f"Swapping {weakest_symbol} (score: {weakest_result.score:.1f}) for {new_signal_symbol}",
            all_scores=all_scores
        )

    def get_score_summary(self, result: VulnerabilityResult) -> str:
        """
        Get a human-readable summary of a vulnerability score result.

        Args:
            result: VulnerabilityResult to summarize

        Returns:
            Summary string
        """
        status = "IMMUNE" if result.is_immune else ("VULNERABLE" if result.is_vulnerable else "HEALTHY")
        pl_str = f"{result.current_pl_percent * 100:.2f}%"

        return (f"{result.symbol}: Score={result.score:.1f} [{status}] | "
                f"Days={result.days_open} | P/L={pl_str} | Decay={result.decay_type}")
