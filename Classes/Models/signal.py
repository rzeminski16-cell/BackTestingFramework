"""
Signal model for strategy trading signals.
"""
from dataclasses import dataclass
from enum import Enum
from typing import Optional, Dict, Any

from .trade_direction import TradeDirection


class SignalType(Enum):
    """Types of trading signals."""
    BUY = "BUY"                    # Open new position (long or short)
    SELL = "SELL"                  # Close entire position
    PARTIAL_EXIT = "PARTIAL_EXIT"  # Close part of position
    ADJUST_STOP = "ADJUST_STOP"    # Adjust stop loss level
    PYRAMID = "PYRAMID"            # Add to existing position
    HOLD = "HOLD"                  # No action


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.

    Attributes:
        type: Signal type (BUY, SELL, PARTIAL_EXIT, ADJUST_STOP, PYRAMID, HOLD)
        size: Position size for BUY/PYRAMID (fraction of capital, 0.0-1.0) or
              fraction to exit for PARTIAL_EXIT (0.0-1.0)
        stop_loss: Stop loss price (absolute price level)
        take_profit: Take profit price (absolute price level)
        new_stop_loss: New stop loss price for ADJUST_STOP
        direction: Trade direction (LONG or SHORT) for BUY signals
        reason: Human-readable explanation of signal
        metadata: Additional strategy-specific data
    """
    type: SignalType
    size: float = 0.0
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    new_stop_loss: Optional[float] = None
    direction: TradeDirection = TradeDirection.LONG
    reason: str = ""
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        """Initialize metadata if not provided."""
        if self.metadata is None:
            self.metadata = {}

    @staticmethod
    def buy(size: float, stop_loss: Optional[float] = None,
            take_profit: Optional[float] = None, reason: str = "",
            direction: TradeDirection = TradeDirection.LONG) -> 'Signal':
        """
        Create a BUY signal to open a new position.

        Args:
            size: Position size as fraction of capital (0.0-1.0)
            stop_loss: Stop loss price (required by strategy validation)
            take_profit: Take profit price (optional)
            reason: Explanation of signal
            direction: Trade direction (LONG or SHORT)

        Returns:
            BUY signal
        """
        return Signal(
            type=SignalType.BUY,
            size=size,
            stop_loss=stop_loss,
            take_profit=take_profit,
            direction=direction,
            reason=reason
        )

    @staticmethod
    def pyramid(size: float, reason: str = "") -> 'Signal':
        """
        Create a PYRAMID signal to add to an existing position.

        Note: The stop loss will be automatically adjusted to break-even
        by the engine when pyramiding occurs.

        Args:
            size: Additional position size as fraction of capital (0.0-1.0)
            reason: Explanation of signal

        Returns:
            PYRAMID signal
        """
        return Signal(
            type=SignalType.PYRAMID,
            size=size,
            reason=reason
        )

    @staticmethod
    def sell(reason: str = "") -> 'Signal':
        """
        Create a SELL signal (close entire position).

        Args:
            reason: Explanation of signal

        Returns:
            SELL signal
        """
        return Signal(type=SignalType.SELL, reason=reason)

    @staticmethod
    def partial_exit(fraction: float, reason: str = "") -> 'Signal':
        """
        Create a PARTIAL_EXIT signal.

        Args:
            fraction: Fraction of position to exit (0.0-1.0)
            reason: Explanation of signal

        Returns:
            PARTIAL_EXIT signal
        """
        if not 0.0 < fraction <= 1.0:
            raise ValueError("Partial exit fraction must be between 0 and 1")
        return Signal(
            type=SignalType.PARTIAL_EXIT,
            size=fraction,
            reason=reason
        )

    @staticmethod
    def adjust_stop(new_stop_loss: float, reason: str = "") -> 'Signal':
        """
        Create an ADJUST_STOP signal.

        Args:
            new_stop_loss: New stop loss price
            reason: Explanation of signal

        Returns:
            ADJUST_STOP signal
        """
        return Signal(
            type=SignalType.ADJUST_STOP,
            new_stop_loss=new_stop_loss,
            reason=reason
        )

    @staticmethod
    def hold(reason: str = "") -> 'Signal':
        """
        Create a HOLD signal (no action).

        Args:
            reason: Explanation

        Returns:
            HOLD signal
        """
        return Signal(type=SignalType.HOLD, reason=reason)
