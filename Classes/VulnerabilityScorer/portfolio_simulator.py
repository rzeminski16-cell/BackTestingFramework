"""
Portfolio Simulator with Capacity Constraints for Vulnerability Analysis.

This module simulates portfolio trading with limited capacity (max simultaneous positions)
and compares different trade selection strategies:
- FIFO (First-In-First-Out): Natural baseline, takes trades in order
- VULNERABILITY: Uses vulnerability scoring to swap weak positions for new signals

Key Use Case:
Given multiple trade logs (representing all potential trade signals), simulate what
would happen with a portfolio that can only hold N positions at a time, and use
vulnerability scoring to decide which trades to keep when new signals arrive.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
import pandas as pd

from .scoring import (
    VulnerabilityScoreParams,
    VulnerabilityScoringEngine,
    DailyVulnerabilityRecord
)
from .features import FeatureError


class PortfolioSelectionMode(Enum):
    """Strategy for selecting trades when at capacity."""
    FIFO = "fifo"  # First-come-first-served, reject new signals when full
    VULNERABILITY = "vulnerability"  # Use vulnerability scoring to swap positions


@dataclass
class PortfolioPosition:
    """Represents an open position in the portfolio."""
    trade_id: str
    symbol: str
    entry_date: datetime
    entry_price: float
    position_size: float  # Capital allocated to this position
    quantity: float

    # Natural exit info from trade log
    natural_exit_date: datetime
    natural_exit_price: float
    natural_pl_pct: float
    natural_pl_dollars: float

    # Actual exit (may differ if swapped)
    actual_exit_date: Optional[datetime] = None
    actual_exit_price: Optional[float] = None
    actual_pl_pct: Optional[float] = None
    actual_pl_dollars: Optional[float] = None

    exit_reason: str = "PENDING"  # NATURAL, SWAPPED, etc.
    swapped_for_signal: Optional[str] = None  # Trade ID that replaced this

    def is_open_on(self, date: datetime) -> bool:
        """Check if position is open on given date."""
        if self.actual_exit_date:
            return self.entry_date <= date < self.actual_exit_date
        return self.entry_date <= date < self.natural_exit_date

    def close_naturally(self) -> None:
        """Close position at natural exit."""
        self.actual_exit_date = self.natural_exit_date
        self.actual_exit_price = self.natural_exit_price
        self.actual_pl_pct = self.natural_pl_pct
        self.actual_pl_dollars = self.natural_pl_dollars
        self.exit_reason = "NATURAL"

    def close_via_swap(self, exit_date: datetime, exit_price: float, swapped_for: str) -> None:
        """Close position via vulnerability swap."""
        self.actual_exit_date = exit_date
        self.actual_exit_price = exit_price
        self.actual_pl_pct = ((exit_price - self.entry_price) / self.entry_price) * 100
        self.actual_pl_dollars = (exit_price - self.entry_price) * self.quantity
        self.exit_reason = "SWAPPED"
        self.swapped_for_signal = swapped_for


@dataclass
class SignalEvent:
    """Represents a trade signal (from trade log entry)."""
    trade_id: str
    symbol: str
    signal_date: datetime
    entry_price: float
    position_size: float
    quantity: float

    # Expected outcome if taken
    natural_exit_date: datetime
    natural_exit_price: float
    natural_pl_pct: float
    natural_pl_dollars: float

    # Actual outcome
    was_taken: bool = False
    rejection_reason: Optional[str] = None
    replaced_position: Optional[str] = None  # Trade ID that was swapped out


@dataclass
class SwapDecision:
    """Record of a swap decision."""
    date: datetime
    new_signal: SignalEvent
    closed_position: PortfolioPosition
    vulnerability_score: float
    swap_threshold: float

    # Impact analysis
    foregone_pl: float  # P/L we gave up by closing early
    new_signal_pl: float  # P/L we'll get from new signal
    net_impact: float  # new_signal_pl - foregone_pl

    def to_dict(self) -> Dict[str, Any]:
        return {
            'date': self.date.strftime('%Y-%m-%d') if hasattr(self.date, 'strftime') else str(self.date),
            'new_signal_symbol': self.new_signal.symbol,
            'closed_symbol': self.closed_position.symbol,
            'vulnerability_score': self.vulnerability_score,
            'swap_threshold': self.swap_threshold,
            'foregone_pl': self.foregone_pl,
            'new_signal_pl': self.new_signal_pl,
            'net_impact': self.net_impact,
            'was_beneficial': self.net_impact > 0
        }


@dataclass
class RejectionDecision:
    """Analysis of a rejected signal - tracks opportunity cost of not swapping."""
    date: datetime
    rejected_signal: SignalEvent
    weakest_position: PortfolioPosition  # Position that would have been replaced
    weakest_score: float  # Score was above threshold, so no swap
    swap_threshold: float

    # Opportunity cost analysis (calculated at end when actual P/L known)
    rejected_signal_pl: float  # What the rejected signal would have made
    weakest_position_actual_pl: float  # What the kept position actually made
    opportunity_cost: float  # rejected_pl - position_pl (positive = missed opportunity, negative = good rejection)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'date': self.date.strftime('%Y-%m-%d') if hasattr(self.date, 'strftime') else str(self.date),
            'rejected_signal_id': self.rejected_signal.trade_id,
            'rejected_signal_symbol': self.rejected_signal.symbol,
            'rejected_signal_pl': self.rejected_signal_pl,
            'weakest_position_id': self.weakest_position.trade_id,
            'weakest_position_symbol': self.weakest_position.symbol,
            'weakest_position_pl': self.weakest_position_actual_pl,
            'weakest_score': self.weakest_score,
            'swap_threshold': self.swap_threshold,
            'score_gap': self.weakest_score - self.swap_threshold,  # How close to swapping
            'opportunity_cost': self.opportunity_cost,
            'was_good_rejection': self.opportunity_cost < 0  # Negative = we made the right call
        }


@dataclass
class PortfolioSimulationResult:
    """Results from portfolio simulation."""
    mode: PortfolioSelectionMode
    max_positions: int
    params_used: Optional[VulnerabilityScoreParams]

    # All signals
    total_signals: int
    signals_taken: int
    signals_rejected: int

    # Positions
    positions: List[PortfolioPosition]
    rejected_signals: List[SignalEvent]
    swap_decisions: List[SwapDecision]

    # Performance
    total_pl: float
    avg_pl_per_trade: float
    win_rate: float

    # Capacity metrics
    avg_utilization: float  # Average % of max_positions used
    days_at_capacity: int
    total_days: int

    # Optional fields with defaults (must come last)
    rejection_decisions: List['RejectionDecision'] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'mode': self.mode.value,
            'max_positions': self.max_positions,
            'total_signals': self.total_signals,
            'signals_taken': self.signals_taken,
            'signals_rejected': self.signals_rejected,
            'total_swaps': len(self.swap_decisions),
            'beneficial_swaps': sum(1 for s in self.swap_decisions if s.net_impact > 0),
            'total_pl': self.total_pl,
            'avg_pl_per_trade': self.avg_pl_per_trade,
            'win_rate': self.win_rate,
            'avg_utilization': self.avg_utilization,
            'capacity_utilization_pct': (self.days_at_capacity / self.total_days * 100) if self.total_days > 0 else 0
        }

    def get_summary_text(self) -> str:
        """Get human-readable summary."""
        lines = [
            f"Portfolio Simulation Results ({self.mode.value.upper()})",
            "=" * 60,
            f"Max Positions: {self.max_positions}",
            f"Total Signals: {self.total_signals}",
            f"Signals Taken: {self.signals_taken} ({self.signals_taken/self.total_signals*100:.1f}%)",
            f"Signals Rejected: {self.signals_rejected} ({self.signals_rejected/self.total_signals*100:.1f}%)",
            "",
            "Performance:",
            f"  Total P/L: ${self.total_pl:,.2f}",
            f"  Avg P/L per Trade: ${self.avg_pl_per_trade:,.2f}",
            f"  Win Rate: {self.win_rate*100:.1f}%",
            "",
            "Capacity Utilization:",
            f"  Average: {self.avg_utilization:.1f} positions ({self.avg_utilization/self.max_positions*100:.1f}%)",
            f"  Days at Capacity: {self.days_at_capacity}/{self.total_days} ({self.days_at_capacity/self.total_days*100:.1f}%)",
        ]

        if self.mode == PortfolioSelectionMode.VULNERABILITY and self.swap_decisions:
            beneficial = sum(1 for s in self.swap_decisions if s.net_impact > 0)
            lines.extend([
                "",
                "Swap Analysis:",
                f"  Total Swaps: {len(self.swap_decisions)}",
                f"  Beneficial: {beneficial} ({beneficial/len(self.swap_decisions)*100:.1f}%)",
                f"  Detrimental: {len(self.swap_decisions)-beneficial}",
                f"  Net Swap Impact: ${sum(s.net_impact for s in self.swap_decisions):,.2f}"
            ])

        return "\n".join(lines)


class PortfolioSimulator:
    """
    Simulates portfolio trading with capacity constraints.

    Compares FIFO (natural) vs Vulnerability-optimized trade selection.
    """

    def __init__(self, max_positions: int):
        """
        Initialize portfolio simulator.

        Args:
            max_positions: Maximum number of simultaneous open positions
        """
        self.max_positions = max_positions

    def simulate_fifo(
        self,
        signals: List[SignalEvent],
        price_data: Dict[str, pd.DataFrame]
    ) -> PortfolioSimulationResult:
        """
        Simulate FIFO (First-In-First-Out) portfolio.

        Takes trades in chronological order, rejects new signals when at capacity.

        Args:
            signals: List of signal events (from trade logs)
            price_data: Price data for each symbol

        Returns:
            PortfolioSimulationResult
        """
        # Sort signals by date
        sorted_signals = sorted(signals, key=lambda s: s.signal_date)

        open_positions: List[PortfolioPosition] = []
        all_positions: List[PortfolioPosition] = []
        rejected_signals: List[SignalEvent] = []

        # Get all unique dates for tracking
        all_dates = set()
        for sig in sorted_signals:
            all_dates.add(sig.signal_date)
            all_dates.add(sig.natural_exit_date)
        all_dates = sorted(all_dates)

        daily_position_counts = []

        for sig in sorted_signals:
            # Close any positions that naturally exited before this signal
            positions_to_close = [p for p in open_positions if p.natural_exit_date <= sig.signal_date]
            for pos in positions_to_close:
                pos.close_naturally()
                open_positions.remove(pos)

            # Check if we have capacity
            if len(open_positions) >= self.max_positions:
                # Reject signal - portfolio is full
                sig.was_taken = False
                sig.rejection_reason = "CAPACITY_FULL"
                rejected_signals.append(sig)
            else:
                # Take the signal
                sig.was_taken = True
                position = PortfolioPosition(
                    trade_id=sig.trade_id,
                    symbol=sig.symbol,
                    entry_date=sig.signal_date,
                    entry_price=sig.entry_price,
                    position_size=sig.position_size,
                    quantity=sig.quantity,
                    natural_exit_date=sig.natural_exit_date,
                    natural_exit_price=sig.natural_exit_price,
                    natural_pl_pct=sig.natural_pl_pct,
                    natural_pl_dollars=sig.natural_pl_dollars
                )
                open_positions.append(position)
                all_positions.append(position)

        # Close any remaining open positions
        for pos in open_positions:
            pos.close_naturally()

        # Track daily position counts for utilization
        if all_dates:
            for date in all_dates:
                count = sum(1 for p in all_positions if p.is_open_on(date))
                daily_position_counts.append(count)

        # Calculate metrics
        total_pl = sum(p.actual_pl_dollars for p in all_positions if p.actual_pl_dollars is not None)
        winning_trades = sum(1 for p in all_positions if p.actual_pl_dollars and p.actual_pl_dollars > 0)

        return PortfolioSimulationResult(
            mode=PortfolioSelectionMode.FIFO,
            max_positions=self.max_positions,
            params_used=None,
            total_signals=len(sorted_signals),
            signals_taken=len(all_positions),
            signals_rejected=len(rejected_signals),
            positions=all_positions,
            rejected_signals=rejected_signals,
            swap_decisions=[],
            total_pl=total_pl,
            avg_pl_per_trade=total_pl / len(all_positions) if all_positions else 0,
            win_rate=winning_trades / len(all_positions) if all_positions else 0,
            avg_utilization=sum(daily_position_counts) / len(daily_position_counts) if daily_position_counts else 0,
            days_at_capacity=sum(1 for c in daily_position_counts if c >= self.max_positions),
            total_days=len(daily_position_counts)
        )

    def simulate_vulnerability(
        self,
        signals: List[SignalEvent],
        price_data: Dict[str, pd.DataFrame],
        params: VulnerabilityScoreParams
    ) -> PortfolioSimulationResult:
        """
        Simulate vulnerability-optimized portfolio.

        When at capacity and a new signal arrives, evaluates all open positions
        and swaps out the weakest if its score is below threshold.

        Args:
            signals: List of signal events (from trade logs)
            price_data: Price data for each symbol
            params: Vulnerability score parameters

        Returns:
            PortfolioSimulationResult
        """
        # Sort signals by date
        sorted_signals = sorted(signals, key=lambda s: s.signal_date)

        scoring_engine = VulnerabilityScoringEngine(params)

        open_positions: List[PortfolioPosition] = []
        all_positions: List[PortfolioPosition] = []
        rejected_signals: List[SignalEvent] = []
        swap_decisions: List[SwapDecision] = []
        rejection_decisions: List[RejectionDecision] = []

        # Get all unique dates for tracking
        all_dates = set()
        for sig in sorted_signals:
            all_dates.add(sig.signal_date)
            all_dates.add(sig.natural_exit_date)
        all_dates = sorted(all_dates)

        daily_position_counts = []

        for sig in sorted_signals:
            # Close any positions that naturally exited before this signal
            positions_to_close = [p for p in open_positions if p.natural_exit_date <= sig.signal_date]
            for pos in positions_to_close:
                pos.close_naturally()
                open_positions.remove(pos)

            # Check if we have capacity
            if len(open_positions) < self.max_positions:
                # Take the signal - we have room
                sig.was_taken = True
                position = PortfolioPosition(
                    trade_id=sig.trade_id,
                    symbol=sig.symbol,
                    entry_date=sig.signal_date,
                    entry_price=sig.entry_price,
                    position_size=sig.position_size,
                    quantity=sig.quantity,
                    natural_exit_date=sig.natural_exit_date,
                    natural_exit_price=sig.natural_exit_price,
                    natural_pl_pct=sig.natural_pl_pct,
                    natural_pl_dollars=sig.natural_pl_dollars
                )
                open_positions.append(position)
                all_positions.append(position)
            else:
                # Portfolio is full - evaluate swap decision
                # Calculate vulnerability scores for all open positions
                position_scores: List[Tuple[PortfolioPosition, float, float]] = []

                for pos in open_positions:
                    symbol = pos.symbol
                    if symbol not in price_data:
                        continue

                    df = price_data[symbol]

                    # Get current price on signal date
                    mask = df['date'] == sig.signal_date
                    if not mask.any():
                        # Try to find closest date
                        mask = df['date'] <= sig.signal_date
                        if not mask.any():
                            continue
                        current_row = df[mask].iloc[-1]
                    else:
                        current_row = df[mask].iloc[0]

                    current_price = current_row['close']

                    try:
                        record = scoring_engine.calculate_daily_score(
                            trade_id=pos.trade_id,
                            symbol=pos.symbol,
                            entry_date=pos.entry_date,
                            entry_price=pos.entry_price,
                            current_date=sig.signal_date,
                            current_price=current_price,
                            price_data=df
                        )

                        position_scores.append((pos, record.vulnerability_score, current_price))

                    except FeatureError:
                        # Position is immune, assign high score
                        position_scores.append((pos, 100.0, current_price))

                if not position_scores:
                    # Couldn't score positions, reject signal
                    sig.was_taken = False
                    sig.rejection_reason = "SCORING_ERROR"
                    rejected_signals.append(sig)
                    continue

                # Find weakest position
                weakest_pos, weakest_score, current_price = min(
                    position_scores,
                    key=lambda x: x[1]
                )

                # Decide whether to swap
                if weakest_score < params.swap_threshold:
                    # Swap! Close weakest position and open new one
                    sig.was_taken = True
                    sig.replaced_position = weakest_pos.trade_id

                    # Close the weak position
                    weakest_pos.close_via_swap(sig.signal_date, current_price, sig.trade_id)
                    open_positions.remove(weakest_pos)

                    # Calculate impact
                    foregone_pl = weakest_pos.natural_pl_dollars - weakest_pos.actual_pl_dollars
                    new_signal_pl = sig.natural_pl_dollars

                    swap_decision = SwapDecision(
                        date=sig.signal_date,
                        new_signal=sig,
                        closed_position=weakest_pos,
                        vulnerability_score=weakest_score,
                        swap_threshold=params.swap_threshold,
                        foregone_pl=foregone_pl,
                        new_signal_pl=new_signal_pl,
                        net_impact=new_signal_pl - foregone_pl
                    )
                    swap_decisions.append(swap_decision)

                    # Open new position
                    new_position = PortfolioPosition(
                        trade_id=sig.trade_id,
                        symbol=sig.symbol,
                        entry_date=sig.signal_date,
                        entry_price=sig.entry_price,
                        position_size=sig.position_size,
                        quantity=sig.quantity,
                        natural_exit_date=sig.natural_exit_date,
                        natural_exit_price=sig.natural_exit_price,
                        natural_pl_pct=sig.natural_pl_pct,
                        natural_pl_dollars=sig.natural_pl_dollars
                    )
                    open_positions.append(new_position)
                    all_positions.append(new_position)
                else:
                    # Don't swap - weakest position is still strong enough
                    sig.was_taken = False
                    sig.rejection_reason = "NO_WEAK_POSITION"
                    rejected_signals.append(sig)

                    # Track rejection decision for analysis (P/L will be calculated after simulation)
                    rejection_decision = RejectionDecision(
                        date=sig.signal_date,
                        rejected_signal=sig,
                        weakest_position=weakest_pos,
                        weakest_score=weakest_score,
                        swap_threshold=params.swap_threshold,
                        rejected_signal_pl=sig.natural_pl_dollars,
                        weakest_position_actual_pl=0.0,  # Will be filled in after simulation
                        opportunity_cost=0.0  # Will be calculated after simulation
                    )
                    rejection_decisions.append(rejection_decision)

        # Close any remaining open positions
        for pos in open_positions:
            pos.close_naturally()

        # Track daily position counts for utilization
        if all_dates:
            for date in all_dates:
                count = sum(1 for p in all_positions if p.is_open_on(date))
                daily_position_counts.append(count)

        # Calculate metrics
        total_pl = sum(p.actual_pl_dollars for p in all_positions if p.actual_pl_dollars is not None)
        winning_trades = sum(1 for p in all_positions if p.actual_pl_dollars and p.actual_pl_dollars > 0)

        # Calculate actual P/L for rejection decisions
        for rejection in rejection_decisions:
            # Find the actual P/L of the position that stayed
            pos = rejection.weakest_position
            if pos.actual_pl_dollars is not None:
                rejection.weakest_position_actual_pl = pos.actual_pl_dollars
                # Opportunity cost = what we could have made - what we actually made
                rejection.opportunity_cost = rejection.rejected_signal_pl - pos.actual_pl_dollars

        return PortfolioSimulationResult(
            mode=PortfolioSelectionMode.VULNERABILITY,
            max_positions=self.max_positions,
            params_used=params,
            total_signals=len(sorted_signals),
            signals_taken=len(all_positions),
            signals_rejected=len(rejected_signals),
            positions=all_positions,
            rejected_signals=rejected_signals,
            swap_decisions=swap_decisions,
            rejection_decisions=rejection_decisions,
            total_pl=total_pl,
            avg_pl_per_trade=total_pl / len(all_positions) if all_positions else 0,
            win_rate=winning_trades / len(all_positions) if all_positions else 0,
            avg_utilization=sum(daily_position_counts) / len(daily_position_counts) if daily_position_counts else 0,
            days_at_capacity=sum(1 for c in daily_position_counts if c >= self.max_positions),
            total_days=len(daily_position_counts)
        )


def trades_to_signals(trades: List[Dict[str, Any]]) -> List[SignalEvent]:
    """
    Convert trade log entries to signal events.

    Each trade entry represents a signal that occurred on its entry date.

    Args:
        trades: List of trade dicts from trade logs

    Returns:
        List of SignalEvent objects
    """
    signals = []

    for trade in trades:
        entry_date = trade['entry_date']
        exit_date = trade['exit_date']

        # Convert pandas timestamps if needed
        if isinstance(entry_date, pd.Timestamp):
            entry_date = entry_date.to_pydatetime()
        if isinstance(exit_date, pd.Timestamp):
            exit_date = exit_date.to_pydatetime()

        signal = SignalEvent(
            trade_id=trade['trade_id'],
            symbol=trade['symbol'],
            signal_date=entry_date,
            entry_price=trade['entry_price'],
            position_size=trade.get('position_size', trade.get('entry_price', 0) * trade.get('quantity', 1)),
            quantity=trade.get('quantity', 1.0),
            natural_exit_date=exit_date,
            natural_exit_price=trade['exit_price'],
            natural_pl_pct=trade.get('pl_pct', 0.0),
            natural_pl_dollars=trade.get('pl', 0.0)
        )

        signals.append(signal)

    return signals
