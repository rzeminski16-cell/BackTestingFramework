"""
Signal Injection and Swap Simulation for Vulnerability Score Analysis.

This module simulates what would happen if vulnerability-based exits had been
used during a backtest. It injects daily buy signals and determines when
trades would have been swapped out.

Key concepts:
- Signal Injection: Simulating daily buy signals to test swap decisions
- Swap Simulation: Determining which positions would be closed for new signals
- Counterfactual Analysis: Calculating P/L if vulnerability scoring was used

The backtest runs *once*. All analysis here is computational simulation.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum
import pandas as pd

from .scoring import (
    VulnerabilityScoreParams,
    VulnerabilityScoringEngine,
    DailyVulnerabilityRecord
)
from .features import FeatureError


class SignalType(Enum):
    """Type of simulated signal."""
    BUY = "BUY"
    SELL = "SELL"
    SIMULATED_DAILY = "SIMULATED_DAILY"  # Synthetic daily buy signal
    ACTUAL_STRATEGY = "ACTUAL_STRATEGY"  # Real signal from strategy


@dataclass
class SimulatedSignal:
    """A simulated buy signal for testing swap decisions."""
    date: datetime
    signal_type: SignalType
    strength: float = 1.0  # Signal strength (0-1)
    source: str = "SIMULATED_DAILY"
    symbol: Optional[str] = None  # For actual strategy signals

    def to_dict(self) -> Dict[str, Any]:
        return {
            'date': self.date.strftime('%Y-%m-%d') if hasattr(self.date, 'strftime') else str(self.date),
            'signal_type': self.signal_type.value,
            'strength': self.strength,
            'source': self.source,
            'symbol': self.symbol
        }


@dataclass
class SwapEvent:
    """
    Record of a swap event where a position would be closed.

    Captures all the details needed to analyze the P/L impact of the swap.
    """
    date: datetime
    swapped_trade_id: str
    swapped_symbol: str
    vulnerability_score: float
    swap_reason: str
    signal_that_triggered: SimulatedSignal

    # P/L at time of swap
    entry_price: float
    swap_price: float
    pl_at_swap_pct: float
    pl_at_swap_dollars: float

    # Natural exit info (for comparison)
    natural_exit_date: datetime
    natural_exit_price: float
    natural_pl_pct: float
    natural_pl_dollars: float

    # Impact analysis
    days_early: int  # How many days before natural exit
    pl_difference_pct: float  # pl_at_swap - natural_pl
    pl_difference_dollars: float

    def to_dict(self) -> Dict[str, Any]:
        return {
            'date': self.date.strftime('%Y-%m-%d') if hasattr(self.date, 'strftime') else str(self.date),
            'swapped_trade_id': self.swapped_trade_id,
            'swapped_symbol': self.swapped_symbol,
            'vulnerability_score': self.vulnerability_score,
            'swap_reason': self.swap_reason,
            'entry_price': self.entry_price,
            'swap_price': self.swap_price,
            'pl_at_swap_pct': self.pl_at_swap_pct,
            'pl_at_swap_dollars': self.pl_at_swap_dollars,
            'natural_exit_date': self.natural_exit_date.strftime('%Y-%m-%d') if hasattr(self.natural_exit_date, 'strftime') else str(self.natural_exit_date),
            'natural_exit_price': self.natural_exit_price,
            'natural_pl_pct': self.natural_pl_pct,
            'natural_pl_dollars': self.natural_pl_dollars,
            'days_early': self.days_early,
            'pl_difference_pct': self.pl_difference_pct,
            'pl_difference_dollars': self.pl_difference_dollars
        }

    @property
    def outcome_category(self) -> str:
        """Categorize the outcome of this swap."""
        if abs(self.pl_difference_pct) < 0.5:
            return 'NEUTRAL'
        elif self.pl_difference_pct > 0:
            return 'BENEFITED'  # Swap was better than holding
        else:
            return 'HURT'  # Swap was worse than holding

    @property
    def impact_severity(self) -> str:
        """Describe the severity of the swap impact."""
        if self.natural_pl_pct < 0 and self.pl_at_swap_pct >= self.natural_pl_pct:
            return 'AVOIDED_LOSS'
        elif self.natural_pl_pct > 5 and self.pl_at_swap_pct < self.natural_pl_pct:
            return 'KILLED_WINNER'
        elif abs(self.pl_difference_pct) < 1:
            return 'MINIMAL_IMPACT'
        elif self.pl_difference_pct > 0:
            return 'IMPROVED_EXIT'
        else:
            return 'PREMATURE_EXIT'


@dataclass
class SimulationResult:
    """
    Complete result of running a swap simulation.

    Contains all swap events, daily scores, and summary statistics.
    """
    params_used: VulnerabilityScoreParams
    date_range: Tuple[datetime, datetime]
    total_trades_analyzed: int
    total_signals_injected: int

    # Results
    swap_events: List[SwapEvent]
    daily_scores: Dict[str, List[DailyVulnerabilityRecord]]  # trade_id -> daily records

    # Summary metrics
    trades_affected: int
    trades_benefited: int
    trades_hurt: int
    trades_neutral: int

    total_pl_natural: float
    total_pl_with_swaps: float
    total_pl_difference: float

    def to_dict(self) -> Dict[str, Any]:
        return {
            'params_used': self.params_used.to_dict(),
            'date_range': [
                self.date_range[0].strftime('%Y-%m-%d') if hasattr(self.date_range[0], 'strftime') else str(self.date_range[0]),
                self.date_range[1].strftime('%Y-%m-%d') if hasattr(self.date_range[1], 'strftime') else str(self.date_range[1])
            ],
            'total_trades_analyzed': self.total_trades_analyzed,
            'total_signals_injected': self.total_signals_injected,
            'swap_events': [e.to_dict() for e in self.swap_events],
            'trades_affected': self.trades_affected,
            'trades_benefited': self.trades_benefited,
            'trades_hurt': self.trades_hurt,
            'trades_neutral': self.trades_neutral,
            'total_pl_natural': self.total_pl_natural,
            'total_pl_with_swaps': self.total_pl_with_swaps,
            'total_pl_difference': self.total_pl_difference
        }

    @property
    def false_positive_rate(self) -> float:
        """
        Rate of trades that would be swapped but would have recovered.

        A false positive is when we swap out a trade that would have been profitable.
        """
        if self.trades_affected == 0:
            return 0.0
        return self.trades_hurt / self.trades_affected

    @property
    def accuracy(self) -> float:
        """
        Accuracy of vulnerability scoring decisions.

        Trades where the swap decision was correct (benefited or neutral).
        """
        if self.trades_affected == 0:
            return 1.0
        return (self.trades_benefited + self.trades_neutral) / self.trades_affected


class SignalInjector:
    """
    Generates simulated buy signals for testing swap decisions.

    For single-security backtests: Generates a daily buy signal for every trading day.
    For portfolio backtests: Can use actual strategy signals or generate synthetic ones.
    """

    def __init__(self, mode: str = "daily"):
        """
        Initialize signal injector.

        Args:
            mode: "daily" for synthetic daily signals, "actual" for real strategy signals
        """
        self.mode = mode

    def inject_daily_signals(
        self,
        start_date: datetime,
        end_date: datetime,
        trading_days: Optional[List[datetime]] = None
    ) -> List[SimulatedSignal]:
        """
        Generate daily buy signals for every trading day in range.

        Args:
            start_date: Start of date range
            end_date: End of date range
            trading_days: List of actual trading days (if None, generates every day)

        Returns:
            List of SimulatedSignal objects
        """
        signals = []

        if trading_days is not None:
            # Use actual trading days
            for day in trading_days:
                if start_date <= day <= end_date:
                    signals.append(SimulatedSignal(
                        date=day,
                        signal_type=SignalType.SIMULATED_DAILY,
                        strength=1.0,
                        source="SIMULATED_DAILY"
                    ))
        else:
            # Generate for every calendar day (weekdays only)
            current = start_date
            while current <= end_date:
                # Skip weekends
                if current.weekday() < 5:
                    signals.append(SimulatedSignal(
                        date=current,
                        signal_type=SignalType.SIMULATED_DAILY,
                        strength=1.0,
                        source="SIMULATED_DAILY"
                    ))
                current += timedelta(days=1)

        return signals

    def use_actual_signals(
        self,
        strategy_signals: List[Dict[str, Any]]
    ) -> List[SimulatedSignal]:
        """
        Convert actual strategy signals to SimulatedSignal objects.

        Args:
            strategy_signals: List of signal dicts from backtest
                             Expected format: {'date': datetime, 'symbol': str, 'type': 'BUY'}

        Returns:
            List of SimulatedSignal objects
        """
        signals = []

        for sig in strategy_signals:
            signal_type = SignalType.BUY if sig.get('type', '').upper() == 'BUY' else SignalType.SELL
            signals.append(SimulatedSignal(
                date=sig['date'],
                signal_type=signal_type,
                strength=sig.get('strength', 1.0),
                source="ACTUAL_STRATEGY",
                symbol=sig.get('symbol')
            ))

        return signals


@dataclass
class OpenPosition:
    """Represents an open position during simulation."""
    trade_id: str
    symbol: str
    entry_date: datetime
    entry_price: float
    natural_exit_date: datetime
    natural_exit_price: float
    natural_pl_pct: float
    natural_pl_dollars: float
    quantity: float


class SwapSimulator:
    """
    Simulates swap decisions based on vulnerability scores.

    This is the main simulation engine that:
    1. Takes completed backtest trades
    2. Calculates daily vulnerability scores
    3. Simulates what would happen with signal injection
    4. Records swap events and calculates P/L impact
    """

    def __init__(
        self,
        params: VulnerabilityScoreParams,
        signal_injector: Optional[SignalInjector] = None
    ):
        """
        Initialize swap simulator.

        Args:
            params: Vulnerability score parameters
            signal_injector: Signal injector (defaults to daily mode)
        """
        self.params = params
        self.scoring_engine = VulnerabilityScoringEngine(params)
        self.signal_injector = signal_injector or SignalInjector(mode="daily")

    def update_params(self, params: VulnerabilityScoreParams) -> None:
        """Update simulation parameters."""
        self.params = params
        self.scoring_engine = VulnerabilityScoringEngine(params)

    def run_simulation(
        self,
        trades: List[Dict[str, Any]],
        price_data: Dict[str, pd.DataFrame],
        signals: Optional[List[SimulatedSignal]] = None
    ) -> SimulationResult:
        """
        Run full swap simulation on completed backtest trades.

        Args:
            trades: List of trade dicts with keys:
                    - trade_id, symbol, entry_date, entry_price, exit_date, exit_price,
                      pl_pct, pl (dollars), quantity
            price_data: Dict mapping symbol to price DataFrame
            signals: List of signals to simulate (generated if None)

        Returns:
            SimulationResult with all swap events and analysis

        Raises:
            FeatureError: If required price data is missing
        """
        if not trades:
            return SimulationResult(
                params_used=self.params,
                date_range=(datetime.now(), datetime.now()),
                total_trades_analyzed=0,
                total_signals_injected=0,
                swap_events=[],
                daily_scores={},
                trades_affected=0,
                trades_benefited=0,
                trades_hurt=0,
                trades_neutral=0,
                total_pl_natural=0.0,
                total_pl_with_swaps=0.0,
                total_pl_difference=0.0
            )

        # Determine date range from trades
        all_dates = []
        for t in trades:
            entry = t['entry_date']
            exit_d = t['exit_date']
            if hasattr(entry, 'date'):
                entry = entry if isinstance(entry, datetime) else datetime.combine(entry, datetime.min.time())
            if hasattr(exit_d, 'date'):
                exit_d = exit_d if isinstance(exit_d, datetime) else datetime.combine(exit_d, datetime.min.time())
            all_dates.extend([entry, exit_d])

        start_date = min(all_dates)
        end_date = max(all_dates)

        # Get trading days from price data
        trading_days = set()
        for symbol, df in price_data.items():
            for d in df['date']:
                if isinstance(d, pd.Timestamp):
                    d = d.to_pydatetime()
                trading_days.add(d)
        trading_days = sorted(trading_days)

        # Generate signals if not provided
        if signals is None:
            signals = self.signal_injector.inject_daily_signals(
                start_date, end_date, trading_days
            )

        # Initialize tracking
        swap_events: List[SwapEvent] = []
        daily_scores: Dict[str, List[DailyVulnerabilityRecord]] = {}
        swapped_trades: set = set()  # Track which trades have been swapped

        # Convert trades to OpenPosition objects
        positions = []
        for t in trades:
            entry_date = t['entry_date']
            exit_date = t['exit_date']
            if isinstance(entry_date, pd.Timestamp):
                entry_date = entry_date.to_pydatetime()
            if isinstance(exit_date, pd.Timestamp):
                exit_date = exit_date.to_pydatetime()

            positions.append(OpenPosition(
                trade_id=t['trade_id'],
                symbol=t['symbol'],
                entry_date=entry_date,
                entry_price=t['entry_price'],
                natural_exit_date=exit_date,
                natural_exit_price=t['exit_price'],
                natural_pl_pct=t.get('pl_pct', 0.0),
                natural_pl_dollars=t.get('pl', 0.0),
                quantity=t.get('quantity', 1.0)
            ))

        # Process each signal
        for signal in signals:
            if signal.signal_type not in [SignalType.BUY, SignalType.SIMULATED_DAILY]:
                continue

            signal_date = signal.date
            if isinstance(signal_date, pd.Timestamp):
                signal_date = signal_date.to_pydatetime()

            # Find positions open on this date (not yet naturally exited or swapped)
            open_positions = [
                p for p in positions
                if p.entry_date <= signal_date < p.natural_exit_date
                and p.trade_id not in swapped_trades
            ]

            if not open_positions:
                continue

            # Calculate vulnerability scores for all open positions
            position_scores: List[Tuple[OpenPosition, DailyVulnerabilityRecord]] = []

            for pos in open_positions:
                symbol = pos.symbol
                if symbol not in price_data:
                    raise FeatureError(
                        'price_data',
                        f"No price data available for symbol '{symbol}'",
                        [symbol]
                    )

                df = price_data[symbol]

                # Get current price
                mask = df['date'] == signal_date
                if not mask.any():
                    # Try to find closest date
                    mask = df['date'] <= signal_date
                    if not mask.any():
                        continue
                    current_row = df[mask].iloc[-1]
                else:
                    current_row = df[mask].iloc[0]

                current_price = current_row['close']

                try:
                    record = self.scoring_engine.calculate_daily_score(
                        trade_id=pos.trade_id,
                        symbol=pos.symbol,
                        entry_date=pos.entry_date,
                        entry_price=pos.entry_price,
                        current_date=signal_date,
                        current_price=current_price,
                        price_data=df
                    )

                    # Store daily score
                    if pos.trade_id not in daily_scores:
                        daily_scores[pos.trade_id] = []
                    daily_scores[pos.trade_id].append(record)

                    position_scores.append((pos, record))

                except FeatureError:
                    # Position is immune due to insufficient data
                    continue

            if not position_scores:
                continue

            # Find the weakest (lowest score) position
            weakest_pos, weakest_record = min(
                position_scores,
                key=lambda x: x[1].vulnerability_score
            )

            # Check if below swap threshold
            if weakest_record.vulnerability_score < self.params.swap_threshold:
                # This position would be swapped!

                # Calculate P/L at swap vs natural exit
                pl_at_swap_pct = weakest_record.current_pl_pct
                pl_at_swap_dollars = (weakest_record.current_price - weakest_pos.entry_price) * weakest_pos.quantity

                natural_exit_date = weakest_pos.natural_exit_date
                if isinstance(natural_exit_date, pd.Timestamp):
                    natural_exit_date = natural_exit_date.to_pydatetime()

                days_early = (natural_exit_date - signal_date).days

                pl_difference_pct = pl_at_swap_pct - weakest_pos.natural_pl_pct
                pl_difference_dollars = pl_at_swap_dollars - weakest_pos.natural_pl_dollars

                # Determine swap reason
                if weakest_record.is_immune:
                    swap_reason = "IMMUNE"  # Shouldn't happen
                elif weakest_record.current_pl_pct < 2:
                    swap_reason = "STAGNANT"
                elif weakest_record.feature_raw_values.get('pl_momentum_7d', 0) < 0:
                    swap_reason = "MOMENTUM_LOSS"
                else:
                    swap_reason = "LOW_SCORE"

                swap_event = SwapEvent(
                    date=signal_date,
                    swapped_trade_id=weakest_pos.trade_id,
                    swapped_symbol=weakest_pos.symbol,
                    vulnerability_score=weakest_record.vulnerability_score,
                    swap_reason=swap_reason,
                    signal_that_triggered=signal,
                    entry_price=weakest_pos.entry_price,
                    swap_price=weakest_record.current_price,
                    pl_at_swap_pct=pl_at_swap_pct,
                    pl_at_swap_dollars=pl_at_swap_dollars,
                    natural_exit_date=weakest_pos.natural_exit_date,
                    natural_exit_price=weakest_pos.natural_exit_price,
                    natural_pl_pct=weakest_pos.natural_pl_pct,
                    natural_pl_dollars=weakest_pos.natural_pl_dollars,
                    days_early=days_early,
                    pl_difference_pct=pl_difference_pct,
                    pl_difference_dollars=pl_difference_dollars
                )

                swap_events.append(swap_event)
                swapped_trades.add(weakest_pos.trade_id)

        # Calculate summary metrics
        trades_affected = len(swap_events)
        trades_benefited = sum(1 for e in swap_events if e.outcome_category == 'BENEFITED')
        trades_hurt = sum(1 for e in swap_events if e.outcome_category == 'HURT')
        trades_neutral = sum(1 for e in swap_events if e.outcome_category == 'NEUTRAL')

        # Calculate total P/L (natural vs with swaps)
        total_pl_natural = sum(p.natural_pl_dollars for p in positions)

        # With swaps: use swap P/L for swapped trades, natural for others
        total_pl_with_swaps = 0.0
        for pos in positions:
            swap = next((e for e in swap_events if e.swapped_trade_id == pos.trade_id), None)
            if swap:
                total_pl_with_swaps += swap.pl_at_swap_dollars
            else:
                total_pl_with_swaps += pos.natural_pl_dollars

        return SimulationResult(
            params_used=self.params,
            date_range=(start_date, end_date),
            total_trades_analyzed=len(trades),
            total_signals_injected=len(signals),
            swap_events=swap_events,
            daily_scores=daily_scores,
            trades_affected=trades_affected,
            trades_benefited=trades_benefited,
            trades_hurt=trades_hurt,
            trades_neutral=trades_neutral,
            total_pl_natural=total_pl_natural,
            total_pl_with_swaps=total_pl_with_swaps,
            total_pl_difference=total_pl_with_swaps - total_pl_natural
        )

    def simulate_single_trade(
        self,
        trade: Dict[str, Any],
        price_data: pd.DataFrame
    ) -> Tuple[List[DailyVulnerabilityRecord], Optional[SwapEvent]]:
        """
        Simulate vulnerability scoring for a single trade.

        This is useful for detailed analysis of individual trades.

        Args:
            trade: Trade dict with entry/exit info
            price_data: Price DataFrame for the trade's symbol

        Returns:
            Tuple of (daily_records, first_swap_event or None)
        """
        entry_date = trade['entry_date']
        exit_date = trade['exit_date']

        if isinstance(entry_date, pd.Timestamp):
            entry_date = entry_date.to_pydatetime()
        if isinstance(exit_date, pd.Timestamp):
            exit_date = exit_date.to_pydatetime()

        # Calculate timeline
        timeline = self.scoring_engine.calculate_trade_timeline(
            trade_id=trade['trade_id'],
            symbol=trade['symbol'],
            entry_date=entry_date,
            entry_price=trade['entry_price'],
            exit_date=exit_date,
            price_data=price_data
        )

        # Find first vulnerable date
        first_vulnerable = self.scoring_engine.find_first_vulnerable_date(timeline)

        swap_event = None
        if first_vulnerable:
            # Calculate swap event details
            pl_at_swap_pct = first_vulnerable.current_pl_pct
            pl_at_swap_dollars = (first_vulnerable.current_price - trade['entry_price']) * trade.get('quantity', 1.0)

            days_early = (exit_date - first_vulnerable.date).days
            pl_difference_pct = pl_at_swap_pct - trade.get('pl_pct', 0.0)
            pl_difference_dollars = pl_at_swap_dollars - trade.get('pl', 0.0)

            swap_event = SwapEvent(
                date=first_vulnerable.date,
                swapped_trade_id=trade['trade_id'],
                swapped_symbol=trade['symbol'],
                vulnerability_score=first_vulnerable.vulnerability_score,
                swap_reason="FIRST_VULNERABLE",
                signal_that_triggered=SimulatedSignal(
                    date=first_vulnerable.date,
                    signal_type=SignalType.SIMULATED_DAILY
                ),
                entry_price=trade['entry_price'],
                swap_price=first_vulnerable.current_price,
                pl_at_swap_pct=pl_at_swap_pct,
                pl_at_swap_dollars=pl_at_swap_dollars,
                natural_exit_date=exit_date,
                natural_exit_price=trade['exit_price'],
                natural_pl_pct=trade.get('pl_pct', 0.0),
                natural_pl_dollars=trade.get('pl', 0.0),
                days_early=days_early,
                pl_difference_pct=pl_difference_pct,
                pl_difference_dollars=pl_difference_dollars
            )

        return timeline, swap_event
