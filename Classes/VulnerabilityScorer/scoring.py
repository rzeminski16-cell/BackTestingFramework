"""
Vulnerability Score Calculation Engine.

This module implements the core vulnerability score logic that determines
how "expendable" a position is. The score is a weighted, multi-component
function that produces a score from 0-100.

Score Interpretation:
- 100: Immune (within immunity period) - cannot be swapped
- 50-99: Healthy but aging
- 1-49: Vulnerable (can be swapped)
- 0: Extremely vulnerable (should be closed)

The calculation follows:
    Vulnerability_Score = Immunity_Check() OR Composite_Score()

Where:
    - Immunity_Check: If days_held <= immunity_days, return 100
    - Composite_Score: base_score + sum(feature_contributions)
"""

from dataclasses import dataclass, field
from datetime import datetime, date
from typing import Dict, List, Optional, Any, Tuple
import json
from pathlib import Path
import pandas as pd

from .features import (
    FeatureCalculator,
    FeatureWeight,
    FeatureResult,
    FeatureError,
    AVAILABLE_FEATURES,
    DEFAULT_FEATURE_WEIGHTS
)


@dataclass
class VulnerabilityScoreParams:
    """
    Complete parameter set for vulnerability score calculation.

    This is the main configuration object that controls all aspects
    of vulnerability scoring.

    Attributes:
        name: Human-readable name for this parameter set
        description: Description of this configuration
        immunity_days: Trades younger than this get score 100 (protected)
        base_score: Starting score before feature contributions
        swap_threshold: Score below which position can be swapped
        features: Dictionary of feature weights and configurations
        tiebreaker_order: Feature priority for breaking ties
    """
    name: str = "Default"
    description: str = "Default vulnerability score parameters"
    immunity_days: int = 7
    base_score: float = 100.0
    swap_threshold: float = 50.0
    features: Dict[str, FeatureWeight] = field(default_factory=lambda: DEFAULT_FEATURE_WEIGHTS.copy())
    tiebreaker_order: List[str] = field(default_factory=lambda: ['current_pl_pct', 'days_held'])

    def __post_init__(self):
        """Validate parameters after initialization."""
        if self.immunity_days < 0:
            raise ValueError("Immunity days must be non-negative")
        if self.base_score <= 0:
            raise ValueError("Base score must be positive")
        if self.swap_threshold < 0 or self.swap_threshold > self.base_score:
            raise ValueError(f"Swap threshold must be between 0 and {self.base_score}")

        # Ensure features dict contains FeatureWeight objects
        for name, weight in self.features.items():
            if isinstance(weight, dict):
                self.features[name] = FeatureWeight.from_dict(weight)
            elif not isinstance(weight, FeatureWeight):
                raise ValueError(f"Feature '{name}' must be a FeatureWeight or dict")

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'name': self.name,
            'description': self.description,
            'immunity_days': self.immunity_days,
            'base_score': self.base_score,
            'swap_threshold': self.swap_threshold,
            'features': {
                name: weight.to_dict()
                for name, weight in self.features.items()
            },
            'tiebreaker_order': self.tiebreaker_order
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'VulnerabilityScoreParams':
        """Create from dictionary."""
        features = {}
        for name, weight_data in data.get('features', {}).items():
            features[name] = FeatureWeight.from_dict(weight_data)

        return cls(
            name=data.get('name', 'Default'),
            description=data.get('description', ''),
            immunity_days=data.get('immunity_days', 7),
            base_score=data.get('base_score', 100.0),
            swap_threshold=data.get('swap_threshold', 50.0),
            features=features if features else DEFAULT_FEATURE_WEIGHTS.copy(),
            tiebreaker_order=data.get('tiebreaker_order', ['current_pl_pct', 'days_held'])
        )

    def to_json(self, filepath: Path) -> None:
        """Save parameters to JSON file."""
        with open(filepath, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)

    @classmethod
    def from_json(cls, filepath: Path) -> 'VulnerabilityScoreParams':
        """Load parameters from JSON file."""
        with open(filepath, 'r') as f:
            data = json.load(f)
        return cls.from_dict(data)

    def get_enabled_features(self) -> List[str]:
        """Get list of enabled feature names."""
        return [
            name for name, weight in self.features.items()
            if weight.enabled
        ]


@dataclass
class DailyVulnerabilityRecord:
    """
    Complete record of vulnerability score calculation for one day.

    This captures all the details needed for analysis and visualization.
    """
    trade_id: str
    symbol: str
    date: datetime
    current_price: float
    current_pl_pct: float
    vulnerability_score: float
    feature_contributions: Dict[str, float]  # Feature name -> weighted contribution
    feature_raw_values: Dict[str, float]  # Feature name -> raw value
    is_immune: bool
    would_be_swapped: bool
    days_held: int

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for export."""
        return {
            'trade_id': self.trade_id,
            'symbol': self.symbol,
            'date': self.date.strftime('%Y-%m-%d') if hasattr(self.date, 'strftime') else str(self.date),
            'current_price': self.current_price,
            'current_pl_pct': self.current_pl_pct,
            'vulnerability_score': self.vulnerability_score,
            'feature_contributions': self.feature_contributions,
            'feature_raw_values': self.feature_raw_values,
            'is_immune': self.is_immune,
            'would_be_swapped': self.would_be_swapped,
            'days_held': self.days_held
        }


class VulnerabilityScoringEngine:
    """
    Main engine for calculating vulnerability scores.

    This engine handles:
    - Daily vulnerability score calculation for positions
    - Immunity period logic
    - Feature-weighted composite scoring
    - Score clamping to valid range

    Usage:
        params = VulnerabilityScoreParams(immunity_days=7, swap_threshold=50)
        engine = VulnerabilityScoringEngine(params)

        # Calculate score for a position on a given day
        record = engine.calculate_daily_score(
            trade_id='T000001',
            symbol='AAPL',
            entry_date=datetime(2024, 1, 1),
            entry_price=150.0,
            current_date=datetime(2024, 1, 15),
            current_price=155.0,
            price_data=df
        )
    """

    def __init__(self, params: Optional[VulnerabilityScoreParams] = None):
        """
        Initialize the scoring engine.

        Args:
            params: VulnerabilityScoreParams configuration. Uses defaults if None.
        """
        self.params = params or VulnerabilityScoreParams()
        self.feature_calculator = FeatureCalculator(self.params.features)

    def update_params(self, params: VulnerabilityScoreParams) -> None:
        """
        Update the scoring parameters.

        Args:
            params: New VulnerabilityScoreParams configuration
        """
        self.params = params
        self.feature_calculator = FeatureCalculator(params.features)

    def calculate_daily_score(
        self,
        trade_id: str,
        symbol: str,
        entry_date: datetime,
        entry_price: float,
        current_date: datetime,
        current_price: float,
        price_data: pd.DataFrame
    ) -> DailyVulnerabilityRecord:
        """
        Calculate vulnerability score for a position on a given day.

        The algorithm:
        1. Calculate days since entry
        2. If within immunity period, return base_score (100)
        3. Otherwise, calculate all enabled features
        4. Compute composite score = base_score + sum(feature_contributions)
        5. Clamp score to [0, base_score]
        6. Determine if position would be swapped

        Args:
            trade_id: Unique identifier for the trade
            symbol: Security symbol
            entry_date: Trade entry date
            entry_price: Trade entry price
            current_date: Current evaluation date
            current_price: Current price
            price_data: Full price history DataFrame

        Returns:
            DailyVulnerabilityRecord with complete score details

        Raises:
            FeatureError: If required data is missing for enabled features
        """
        # Calculate days held
        days_held = self._calc_days_held(entry_date, current_date)

        # Calculate current P/L %
        current_pl_pct = self._calc_pl_pct(entry_price, current_price)

        # Check immunity period
        if days_held <= self.params.immunity_days:
            return DailyVulnerabilityRecord(
                trade_id=trade_id,
                symbol=symbol,
                date=current_date,
                current_price=current_price,
                current_pl_pct=current_pl_pct,
                vulnerability_score=self.params.base_score,
                feature_contributions={},
                feature_raw_values={'days_held': days_held, 'current_pl_pct': current_pl_pct},
                is_immune=True,
                would_be_swapped=False,
                days_held=days_held
            )

        # Calculate all enabled features
        feature_results = self.feature_calculator.calculate_all_features(
            entry_date=entry_date,
            entry_price=entry_price,
            current_date=current_date,
            current_price=current_price,
            price_data=price_data
        )

        # Extract contributions and raw values
        feature_contributions = {}
        feature_raw_values = {}

        for name, result in feature_results.items():
            if result.is_calculable:
                feature_contributions[name] = result.weighted_contribution
                feature_raw_values[name] = result.raw_value

        # Calculate composite score
        total_contribution = sum(feature_contributions.values())
        composite_score = self.params.base_score + total_contribution

        # Clamp to valid range [0, base_score]
        final_score = max(0.0, min(self.params.base_score, composite_score))

        # Determine if would be swapped
        would_be_swapped = final_score < self.params.swap_threshold

        return DailyVulnerabilityRecord(
            trade_id=trade_id,
            symbol=symbol,
            date=current_date,
            current_price=current_price,
            current_pl_pct=current_pl_pct,
            vulnerability_score=final_score,
            feature_contributions=feature_contributions,
            feature_raw_values=feature_raw_values,
            is_immune=False,
            would_be_swapped=would_be_swapped,
            days_held=days_held
        )

    def calculate_trade_timeline(
        self,
        trade_id: str,
        symbol: str,
        entry_date: datetime,
        entry_price: float,
        exit_date: datetime,
        price_data: pd.DataFrame
    ) -> List[DailyVulnerabilityRecord]:
        """
        Calculate vulnerability scores for the entire lifetime of a trade.

        This generates a daily timeline of vulnerability scores from entry to exit,
        which can be used for visualization and analysis.

        Args:
            trade_id: Unique identifier for the trade
            symbol: Security symbol
            entry_date: Trade entry date
            entry_price: Trade entry price
            exit_date: Trade exit date
            price_data: Full price history DataFrame

        Returns:
            List of DailyVulnerabilityRecord for each day from entry to exit

        Raises:
            FeatureError: If required data is missing
        """
        timeline = []

        # Filter price data to trade period
        mask = (price_data['date'] >= entry_date) & (price_data['date'] <= exit_date)
        trade_period_data = price_data[mask].copy()

        if len(trade_period_data) == 0:
            raise FeatureError(
                'timeline_calculation',
                f"No price data available for trade period {entry_date} to {exit_date}",
                ['close']
            )

        # Calculate score for each day
        for _, row in trade_period_data.iterrows():
            current_date = row['date']
            current_price = row['close']

            try:
                record = self.calculate_daily_score(
                    trade_id=trade_id,
                    symbol=symbol,
                    entry_date=entry_date,
                    entry_price=entry_price,
                    current_date=current_date,
                    current_price=current_price,
                    price_data=price_data
                )
                timeline.append(record)
            except FeatureError:
                # For early days where lookback features can't be calculated,
                # treat as immune
                days_held = self._calc_days_held(entry_date, current_date)
                current_pl_pct = self._calc_pl_pct(entry_price, current_price)

                timeline.append(DailyVulnerabilityRecord(
                    trade_id=trade_id,
                    symbol=symbol,
                    date=current_date,
                    current_price=current_price,
                    current_pl_pct=current_pl_pct,
                    vulnerability_score=self.params.base_score,
                    feature_contributions={},
                    feature_raw_values={'days_held': days_held, 'current_pl_pct': current_pl_pct},
                    is_immune=True,
                    would_be_swapped=False,
                    days_held=days_held
                ))

        return timeline

    def find_first_vulnerable_date(
        self,
        timeline: List[DailyVulnerabilityRecord]
    ) -> Optional[DailyVulnerabilityRecord]:
        """
        Find the first date where the position became vulnerable (score < threshold).

        Args:
            timeline: List of daily vulnerability records

        Returns:
            First record where would_be_swapped is True, or None if never vulnerable
        """
        for record in timeline:
            if record.would_be_swapped:
                return record
        return None

    def compare_tiebreaker(
        self,
        record_a: DailyVulnerabilityRecord,
        record_b: DailyVulnerabilityRecord
    ) -> int:
        """
        Compare two records using tiebreaker rules.

        Returns:
            -1 if record_a should be swapped first
            1 if record_b should be swapped first
            0 if equal
        """
        for feature_name in self.params.tiebreaker_order:
            value_a = record_a.feature_raw_values.get(feature_name, 0)
            value_b = record_b.feature_raw_values.get(feature_name, 0)

            if feature_name == 'current_pl_pct':
                # Sell losers first (lower P/L = swap first)
                if value_a < value_b:
                    return -1
                elif value_a > value_b:
                    return 1
            elif feature_name == 'days_held':
                # Then oldest (higher days = swap first)
                if value_a > value_b:
                    return -1
                elif value_a < value_b:
                    return 1

        return 0

    def _calc_days_held(self, entry_date: datetime, current_date: datetime) -> int:
        """Calculate days since entry."""
        if hasattr(entry_date, 'date') and callable(entry_date.date):
            entry = entry_date.date()
        else:
            entry = entry_date

        if hasattr(current_date, 'date') and callable(current_date.date):
            current = current_date.date()
        else:
            current = current_date

        return (current - entry).days

    def _calc_pl_pct(self, entry_price: float, current_price: float) -> float:
        """Calculate P/L percentage."""
        if entry_price == 0:
            return 0.0
        return ((current_price - entry_price) / entry_price) * 100


# Pre-built parameter presets
PRESET_CONSERVATIVE = VulnerabilityScoreParams(
    name="Conservative",
    description="Protects positions longer, unlikely to swap. Good for long-term holds.",
    immunity_days=14,
    base_score=100.0,
    swap_threshold=30.0,
    features={
        'days_held': FeatureWeight(enabled=True, weight=-1.0),
        'current_pl_pct': FeatureWeight(enabled=True, weight=2.0),
        'pl_momentum_7d': FeatureWeight(enabled=True, weight=1.0),
        'pl_momentum_14d': FeatureWeight(enabled=False, weight=0.0),
        'volatility_7d': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_high': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_entry': FeatureWeight(enabled=False, weight=0.0),
        'max_favorable_excursion': FeatureWeight(enabled=False, weight=0.0),
        'entropy_7d': FeatureWeight(enabled=False, weight=0.0),
    }
)

PRESET_AGGRESSIVE = VulnerabilityScoreParams(
    name="Aggressive",
    description="Swaps quickly if no progress. Good for momentum strategies.",
    immunity_days=3,
    base_score=100.0,
    swap_threshold=70.0,
    features={
        'days_held': FeatureWeight(enabled=True, weight=-3.0),
        'current_pl_pct': FeatureWeight(enabled=True, weight=0.5, stagnation_threshold=3.0),
        'pl_momentum_7d': FeatureWeight(enabled=True, weight=5.0),
        'pl_momentum_14d': FeatureWeight(enabled=False, weight=0.0),
        'volatility_7d': FeatureWeight(enabled=True, weight=-0.5),
        'distance_from_high': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_entry': FeatureWeight(enabled=False, weight=0.0),
        'max_favorable_excursion': FeatureWeight(enabled=True, weight=-1.0),
        'entropy_7d': FeatureWeight(enabled=False, weight=0.0),
    }
)

PRESET_MOMENTUM_FOCUSED = VulnerabilityScoreParams(
    name="Momentum Focused",
    description="Emphasizes recent momentum over time held. Kills stagnant trades.",
    immunity_days=7,
    base_score=100.0,
    swap_threshold=50.0,
    features={
        'days_held': FeatureWeight(enabled=True, weight=-1.0),
        'current_pl_pct': FeatureWeight(enabled=True, weight=1.0),
        'pl_momentum_7d': FeatureWeight(enabled=True, weight=5.0),
        'pl_momentum_14d': FeatureWeight(enabled=True, weight=2.0),
        'volatility_7d': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_high': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_entry': FeatureWeight(enabled=False, weight=0.0),
        'max_favorable_excursion': FeatureWeight(enabled=False, weight=0.0),
        'entropy_7d': FeatureWeight(enabled=False, weight=0.0),
    }
)

PRESET_TIME_DECAY = VulnerabilityScoreParams(
    name="Time Decay",
    description="Strongly penalizes old trades. Forces portfolio turnover.",
    immunity_days=5,
    base_score=100.0,
    swap_threshold=50.0,
    features={
        'days_held': FeatureWeight(enabled=True, weight=-4.0, decay_point=10),
        'current_pl_pct': FeatureWeight(enabled=True, weight=0.5),
        'pl_momentum_7d': FeatureWeight(enabled=True, weight=2.0),
        'pl_momentum_14d': FeatureWeight(enabled=False, weight=0.0),
        'volatility_7d': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_high': FeatureWeight(enabled=False, weight=0.0),
        'distance_from_entry': FeatureWeight(enabled=False, weight=0.0),
        'max_favorable_excursion': FeatureWeight(enabled=False, weight=0.0),
        'entropy_7d': FeatureWeight(enabled=False, weight=0.0),
    }
)

# Dictionary of all presets for easy access
VULNERABILITY_SCORE_PRESETS: Dict[str, VulnerabilityScoreParams] = {
    'default': VulnerabilityScoreParams(),
    'conservative': PRESET_CONSERVATIVE,
    'aggressive': PRESET_AGGRESSIVE,
    'momentum_focused': PRESET_MOMENTUM_FOCUSED,
    'time_decay': PRESET_TIME_DECAY,
}
