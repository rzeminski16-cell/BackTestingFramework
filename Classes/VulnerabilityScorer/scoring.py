"""
Vulnerability Score Calculation Engine.

This module implements the core vulnerability score logic that determines
how "expendable" a position is. The score is a weighted, multi-component
function that produces a score from 0-100.

Score Interpretation:
- 100: Immune (within immunity period) - cannot be swapped
- 50-99: Healthy but aging
- 1-49: Vulnerable (can be swapped)
- 0: Extremely vulnerable (should be closed)

The calculation follows:
    Vulnerability_Score = Immunity_Check() OR Composite_Score()

Where:
    - Immunity_Check: If days_held <= immunity_days, return 100
    - Composite_Score: base_score + sum(feature_contributions)
"""

from dataclasses import dataclass, field
from datetime import datetime, date
from typing import Dict, List, Optional, Any, Tuple
import json
from pathlib import Path
import pandas as pd

from .features import (
    FeatureCalculator,
    FeatureWeight,
    FeatureResult,
    FeatureError,
    AVAILABLE_FEATURES,
    DEFAULT_FEATURE_WEIGHTS
)


@dataclass
class VulnerabilityScoreParams:
    """
    Complete parameter set for vulnerability score calculation.

    This is the main configuration object that controls all aspects
    of vulnerability scoring.

    Attributes:
        name: Human-readable name for this parameter set
        description: Description of this configuration
        immunity_days: Trades younger than this get score 100 (protected)
        base_score: Starting score before feature contributions
        swap_threshold: Score below which position can be swapped
        features: Dictionary of feature weights and configurations
        tiebreaker_order: Feature priority for breaking ties
    """
    name: str = "Default"
    description: str = "Default vulnerability score parameters"
    immunity_days: int = 7
    base_score: float = 100.0
    swap_threshold: float = 50.0
    features: Dict[str, FeatureWeight] = field(default_factory=lambda: DEFAULT_FEATURE_WEIGHTS.copy())
    tiebreaker_order: List[str] = field(default_factory=lambda: ['current_pl_pct', 'days_held'])

    def __post_init__(self):
        """Validate parameters after initialization."""
        if self.immunity_days < 0:
            raise ValueError("Immunity days must be non-negative")
        if self.base_score <= 0:
            raise ValueError("Base score must be positive")
        if self.swap_threshold < 0 or self.swap_threshold > self.base_score:
            raise ValueError(f"Swap threshold must be between 0 and {self.base_score}")

        # Ensure features dict contains FeatureWeight objects
        for name, weight in self.features.items():
            if isinstance(weight, dict):
                self.features[name] = FeatureWeight.from_dict(weight)
            elif not isinstance(weight, FeatureWeight):
                raise ValueError(f"Feature '{name}' must be a FeatureWeight or dict")

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            'name': self.name,
            'description': self.description,
            'immunity_days': self.immunity_days,
            'base_score': self.base_score,
            'swap_threshold': self.swap_threshold,
            'features': {
                name: weight.to_dict()
                for name, weight in self.features.items()
            },
            'tiebreaker_order': self.tiebreaker_order
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'VulnerabilityScoreParams':
        """Create from dictionary."""
        features = {}
        for name, weight_data in data.get('features', {}).items():
            features[name] = FeatureWeight.from_dict(weight_data)

        return cls(
            name=data.get('name', 'Default'),
            description=data.get('description', ''),
            immunity_days=data.get('immunity_days', 7),
            base_score=data.get('base_score', 100.0),
            swap_threshold=data.get('swap_threshold', 50.0),
            features=features if features else DEFAULT_FEATURE_WEIGHTS.copy(),
            tiebreaker_order=data.get('tiebreaker_order', ['current_pl_pct', 'days_held'])
        )

    def to_json(self, filepath: Path) -> None:
        """Save parameters to JSON file."""
        with open(filepath, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)

    @classmethod
    def from_json(cls, filepath: Path) -> 'VulnerabilityScoreParams':
        """Load parameters from JSON file."""
        with open(filepath, 'r') as f:
            data = json.load(f)
        return cls.from_dict(data)

    def get_enabled_features(self) -> List[str]:
        """Get list of enabled feature names."""
        return [
            name for name, weight in self.features.items()
            if weight.enabled
        ]


@dataclass
class DailyVulnerabilityRecord:
    """
    Complete record of vulnerability score calculation for one day.

    This captures all the details needed for analysis and visualization.
    """
    trade_id: str
    symbol: str
    date: datetime
    current_price: float
    current_pl_pct: float
    vulnerability_score: float
    feature_contributions: Dict[str, float]  # Feature name -> weighted contribution
    feature_raw_values: Dict[str, float]  # Feature name -> raw value
    is_immune: bool
    would_be_swapped: bool
    days_held: int

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for export."""
        return {
            'trade_id': self.trade_id,
            'symbol': self.symbol,
            'date': self.date.strftime('%Y-%m-%d') if hasattr(self.date, 'strftime') else str(self.date),
            'current_price': self.current_price,
            'current_pl_pct': self.current_pl_pct,
            'vulnerability_score': self.vulnerability_score,
            'feature_contributions': self.feature_contributions,
            'feature_raw_values': self.feature_raw_values,
            'is_immune': self.is_immune,
            'would_be_swapped': self.would_be_swapped,
            'days_held': self.days_held
        }


class VulnerabilityScoringEngine:
    """
    Main engine for calculating vulnerability scores.

    This engine handles:
    - Daily vulnerability score calculation for positions
    - Immunity period logic
    - Feature-weighted composite scoring
    - Score clamping to valid range

    Usage:
        params = VulnerabilityScoreParams(immunity_days=7, swap_threshold=50)
        engine = VulnerabilityScoringEngine(params)

        # Calculate score for a position on a given day
        record = engine.calculate_daily_score(
            trade_id='T000001',
            symbol='AAPL',
            entry_date=datetime(2024, 1, 1),
            entry_price=150.0,
            current_date=datetime(2024, 1, 15),
            current_price=155.0,
            price_data=df
        )
    """

    def __init__(self, params: Optional[VulnerabilityScoreParams] = None):
        """
        Initialize the scoring engine.

        Args:
            params: VulnerabilityScoreParams configuration. Uses defaults if None.
        """
        self.params = params or VulnerabilityScoreParams()
        self.feature_calculator = FeatureCalculator(self.params.features)

    def update_params(self, params: VulnerabilityScoreParams) -> None:
        """
        Update the scoring parameters.

        Args:
            params: New VulnerabilityScoreParams configuration
        """
        self.params = params
        self.feature_calculator = FeatureCalculator(params.features)

    def calculate_daily_score(
        self,
        trade_id: str,
        symbol: str,
        entry_date: datetime,
        entry_price: float,
        current_date: datetime,
        current_price: float,
        price_data: pd.DataFrame
    ) -> DailyVulnerabilityRecord:
        """
        Calculate vulnerability score for a position on a given day.

        The algorithm:
        1. Calculate days since entry
        2. If within immunity period, return base_score (100)
        3. Otherwise, calculate all enabled features
        4. Compute composite score = base_score + sum(feature_contributions)
        5. Clamp score to [0, base_score]
        6. Determine if position would be swapped

        Args:
            trade_id: Unique identifier for the trade
            symbol: Security symbol
            entry_date: Trade entry date
            entry_price: Trade entry price
            current_date: Current evaluation date
            current_price: Current price
            price_data: Full price history DataFrame

        Returns:
            DailyVulnerabilityRecord with complete score details

        Raises:
            FeatureError: If required data is missing for enabled features
        """
        # Calculate days held
        days_held = self._calc_days_held(entry_date, current_date)

        # Calculate current P/L %
        current_pl_pct = self._calc_pl_pct(entry_price, current_price)

        # Check immunity period
        if days_held <= self.params.immunity_days:
            return DailyVulnerabilityRecord(
                trade_id=trade_id,
                symbol=symbol,
                date=current_date,
                current_price=current_price,
                current_pl_pct=current_pl_pct,
                vulnerability_score=self.params.base_score,
                feature_contributions={},
                feature_raw_values={'days_held': days_held, 'current_pl_pct': current_pl_pct},
                is_immune=True,
                would_be_swapped=False,
                days_held=days_held
            )

        # Calculate all enabled features
        feature_results = self.feature_calculator.calculate_all_features(
            entry_date=entry_date,
            entry_price=entry_price,
            current_date=current_date,
            current_price=current_price,
            price_data=price_data
        )

        # Extract contributions and raw values
        feature_contributions = {}
        feature_raw_values = {}

        for name, result in feature_results.items():
            if result.is_calculable:
                feature_contributions[name] = result.weighted_contribution
                feature_raw_values[name] = result.raw_value

        # Calculate composite score
        total_contribution = sum(feature_contributions.values())
        composite_score = self.params.base_score + total_contribution

        # Clamp to valid range [0, base_score]
        final_score = max(0.0, min(self.params.base_score, composite_score))

        # Determine if would be swapped
        would_be_swapped = final_score < self.params.swap_threshold

        return DailyVulnerabilityRecord(
            trade_id=trade_id,
            symbol=symbol,
            date=current_date,
            current_price=current_price,
            current_pl_pct=current_pl_pct,
            vulnerability_score=final_score,
            feature_contributions=feature_contributions,
            feature_raw_values=feature_raw_values,
            is_immune=False,
            would_be_swapped=would_be_swapped,
            days_held=days_held
        )

    def calculate_trade_timeline(
        self,
        trade_id: str,
        symbol: str,
        entry_date: datetime,
        entry_price: float,
        exit_date: datetime,
        price_data: pd.DataFrame
    ) -> List[DailyVulnerabilityRecord]:
        """
        Calculate vulnerability scores for the entire lifetime of a trade.

        This generates a daily timeline of vulnerability scores from entry to exit,
        which can be used for visualization and analysis.

        Args:
            trade_id: Unique identifier for the trade
            symbol: Security symbol
            entry_date: Trade entry date
            entry_price: Trade entry price
            exit_date: Trade exit date
            price_data: Full price history DataFrame

        Returns:
            List of DailyVulnerabilityRecord for each day from entry to exit

        Raises:
            FeatureError: If required data is missing
        """
        timeline = []

        # Filter price data to trade period
        mask = (price_data['date'] >= entry_date) & (price_data['date'] <= exit_date)
        trade_period_data = price_data[mask].copy()

        if len(trade_period_data) == 0:
            raise FeatureError(
                'timeline_calculation',
                f"No price data available for trade period {entry_date} to {exit_date}",
                ['close']
            )

        # Calculate score for each day
        for _, row in trade_period_data.iterrows():
            current_date = row['date']
            current_price = row['close']

            try:
                record = self.calculate_daily_score(
                    trade_id=trade_id,
                    symbol=symbol,
                    entry_date=entry_date,
                    entry_price=entry_price,
                    current_date=current_date,
                    current_price=current_price,
                    price_data=price_data
                )
                timeline.append(record)
            except FeatureError:
                # For early days where lookback features can't be calculated,
                # treat as immune
                days_held = self._calc_days_held(entry_date, current_date)
                current_pl_pct = self._calc_pl_pct(entry_price, current_price)

                timeline.append(DailyVulnerabilityRecord(
                    trade_id=trade_id,
                    symbol=symbol,
                    date=current_date,
                    current_price=current_price,
                    current_pl_pct=current_pl_pct,
                    vulnerability_score=self.params.base_score,
                    feature_contributions={},
                    feature_raw_values={'days_held': days_held, 'current_pl_pct': current_pl_pct},
                    is_immune=True,
                    would_be_swapped=False,
                    days_held=days_held
                ))

        return timeline

    def find_first_vulnerable_date(
        self,
        timeline: List[DailyVulnerabilityRecord]
    ) -> Optional[DailyVulnerabilityRecord]:
        """
        Find the first date where the position became vulnerable (score < threshold).

        Args:
            timeline: List of daily vulnerability records

        Returns:
            First record where would_be_swapped is True, or None if never vulnerable
        """
        for record in timeline:
            if record.would_be_swapped:
                return record
        return None

    def compare_tiebreaker(
        self,
        record_a: DailyVulnerabilityRecord,
        record_b: DailyVulnerabilityRecord
    ) -> int:
        """
        Compare two records using tiebreaker rules.

        Returns:
            -1 if record_a should be swapped first
            1 if record_b should be swapped first
            0 if equal
        """
        for feature_name in self.params.tiebreaker_order:
            value_a = record_a.feature_raw_values.get(feature_name, 0)
            value_b = record_b.feature_raw_values.get(feature_name, 0)

            if feature_name == 'current_pl_pct':
                # Sell losers first (lower P/L = swap first)
                if value_a < value_b:
                    return -1
                elif value_a > value_b:
                    return 1
            elif feature_name == 'days_held':
                # Then oldest (higher days = swap first)
                if value_a > value_b:
                    return -1
                elif value_a < value_b:
                    return 1

        return 0

    def _calc_days_held(self, entry_date: datetime, current_date: datetime) -> int:
        """Calculate days since entry."""
        if hasattr(entry_date, 'date') and callable(entry_date.date):
            entry = entry_date.date()
        else:
            entry = entry_date

        if hasattr(current_date, 'date') and callable(current_date.date):
            current = current_date.date()
        else:
            current = current_date

        return (current - entry).days

    def _calc_pl_pct(self, entry_price: float, current_price: float) -> float:
        """Calculate P/L percentage."""
        if entry_price == 0:
            return 0.0
        return ((current_price - entry_price) / entry_price) * 100


# Dictionary of all presets for easy access
VULNERABILITY_SCORE_PRESETS: Dict[str, VulnerabilityScoreParams] = {
    'default': VulnerabilityScoreParams(),
}


class PresetManager:
    """
    Manager for creating, saving, loading, and managing vulnerability score presets.

    Provides a unified interface for working with both built-in and custom presets.

    Usage:
        manager = PresetManager(presets_directory=Path('config/my_presets'))

        # Create a new custom preset
        params = VulnerabilityScoreParams(
            name="My Custom Preset",
            immunity_days=10,
            swap_threshold=45
        )
        manager.save_preset(params)

        # Load all presets (built-in + custom)
        all_presets = manager.get_all_presets()

        # Load a specific preset
        preset = manager.load_preset("My Custom Preset")

        # Delete a custom preset
        manager.delete_preset("My Custom Preset")
    """

    def __init__(self, presets_directory: Optional[Path] = None):
        """
        Initialize the preset manager.

        Args:
            presets_directory: Directory for storing custom presets.
                              Defaults to 'config/vulnerability_presets' in CWD.
        """
        if presets_directory is None:
            self.presets_directory = Path('config/vulnerability_presets')
        else:
            self.presets_directory = Path(presets_directory)

        # Create directory if it doesn't exist
        self.presets_directory.mkdir(parents=True, exist_ok=True)

        # Cache of loaded presets
        self._custom_presets: Dict[str, VulnerabilityScoreParams] = {}
        self._load_custom_presets()

    def _load_custom_presets(self) -> None:
        """Load all custom presets from directory."""
        self._custom_presets = {}

        for json_file in self.presets_directory.glob('*.json'):
            try:
                preset = VulnerabilityScoreParams.from_json(json_file)
                self._custom_presets[preset.name] = preset
            except (json.JSONDecodeError, KeyError, ValueError) as e:
                print(f"Warning: Failed to load preset {json_file}: {e}")

    def get_builtin_presets(self) -> Dict[str, VulnerabilityScoreParams]:
        """Get dictionary of built-in presets."""
        return VULNERABILITY_SCORE_PRESETS.copy()

    def get_custom_presets(self) -> Dict[str, VulnerabilityScoreParams]:
        """Get dictionary of custom presets."""
        return self._custom_presets.copy()

    def get_all_presets(self) -> Dict[str, VulnerabilityScoreParams]:
        """Get all presets (built-in + custom)."""
        all_presets = self.get_builtin_presets()
        all_presets.update(self._custom_presets)
        return all_presets

    def get_preset_names(self) -> List[str]:
        """Get list of all preset names."""
        return list(self.get_all_presets().keys())

    def load_preset(self, name: str) -> Optional[VulnerabilityScoreParams]:
        """
        Load a preset by name.

        Args:
            name: Name of the preset

        Returns:
            VulnerabilityScoreParams or None if not found
        """
        all_presets = self.get_all_presets()
        return all_presets.get(name)

    def save_preset(
        self,
        params: VulnerabilityScoreParams,
        overwrite: bool = False
    ) -> Path:
        """
        Save a preset to the custom presets directory.

        Args:
            params: VulnerabilityScoreParams to save
            overwrite: If True, overwrite existing preset with same name

        Returns:
            Path to the saved preset file

        Raises:
            ValueError: If preset with same name exists and overwrite=False
        """
        # Check if name conflicts with built-in preset
        if params.name in VULNERABILITY_SCORE_PRESETS and not overwrite:
            raise ValueError(
                f"Cannot overwrite built-in preset '{params.name}'. "
                f"Use a different name or set overwrite=True to create a custom version."
            )

        # Check for existing custom preset
        if params.name in self._custom_presets and not overwrite:
            raise ValueError(
                f"Preset '{params.name}' already exists. Set overwrite=True to replace."
            )

        # Generate safe filename
        safe_name = self._sanitize_filename(params.name)
        filepath = self.presets_directory / f"{safe_name}.json"

        # Save to file
        params.to_json(filepath)

        # Update cache
        self._custom_presets[params.name] = params

        return filepath

    def delete_preset(self, name: str) -> bool:
        """
        Delete a custom preset.

        Args:
            name: Name of the preset to delete

        Returns:
            True if deleted, False if not found or is built-in

        Raises:
            ValueError: If trying to delete a built-in preset
        """
        if name in VULNERABILITY_SCORE_PRESETS:
            raise ValueError(f"Cannot delete built-in preset '{name}'")

        if name not in self._custom_presets:
            return False

        # Find and delete the file
        safe_name = self._sanitize_filename(name)
        filepath = self.presets_directory / f"{safe_name}.json"

        if filepath.exists():
            filepath.unlink()

        # Remove from cache
        del self._custom_presets[name]

        return True

    def rename_preset(self, old_name: str, new_name: str) -> bool:
        """
        Rename a custom preset.

        Args:
            old_name: Current name
            new_name: New name

        Returns:
            True if renamed successfully

        Raises:
            ValueError: If preset doesn't exist or is built-in
        """
        if old_name in VULNERABILITY_SCORE_PRESETS:
            raise ValueError(f"Cannot rename built-in preset '{old_name}'")

        if old_name not in self._custom_presets:
            raise ValueError(f"Preset '{old_name}' not found")

        if new_name in self.get_all_presets():
            raise ValueError(f"Preset '{new_name}' already exists")

        # Load, rename, save, delete old
        params = self._custom_presets[old_name]
        params.name = new_name

        self.save_preset(params, overwrite=True)
        self.delete_preset(old_name)

        return True

    def duplicate_preset(
        self,
        source_name: str,
        new_name: str
    ) -> VulnerabilityScoreParams:
        """
        Create a copy of an existing preset with a new name.

        Args:
            source_name: Name of the preset to copy
            new_name: Name for the new preset

        Returns:
            The new VulnerabilityScoreParams

        Raises:
            ValueError: If source not found or new name exists
        """
        all_presets = self.get_all_presets()

        if source_name not in all_presets:
            raise ValueError(f"Source preset '{source_name}' not found")

        if new_name in all_presets:
            raise ValueError(f"Preset '{new_name}' already exists")

        # Create copy
        source = all_presets[source_name]
        new_params = VulnerabilityScoreParams.from_dict(source.to_dict())
        new_params.name = new_name
        new_params.description = f"Copy of {source_name}"

        # Save
        self.save_preset(new_params)

        return new_params

    def create_preset_from_settings(
        self,
        name: str,
        description: str = "",
        immunity_days: int = 7,
        base_score: float = 100.0,
        swap_threshold: float = 50.0,
        feature_settings: Optional[Dict[str, Dict[str, Any]]] = None
    ) -> VulnerabilityScoreParams:
        """
        Create a new preset from individual settings.

        This is a convenience method for building presets programmatically.

        Args:
            name: Name for the preset
            description: Description of the preset
            immunity_days: Immunity period in days
            base_score: Starting score
            swap_threshold: Score below which to swap
            feature_settings: Dict of feature_name -> {enabled, weight, ...}

        Returns:
            The new VulnerabilityScoreParams (not saved automatically)
        """
        features = DEFAULT_FEATURE_WEIGHTS.copy()

        if feature_settings:
            for feature_name, settings in feature_settings.items():
                if feature_name in features:
                    features[feature_name] = FeatureWeight(
                        enabled=settings.get('enabled', False),
                        weight=settings.get('weight', 0.0),
                        stagnation_threshold=settings.get('stagnation_threshold'),
                        decay_point=settings.get('decay_point')
                    )

        return VulnerabilityScoreParams(
            name=name,
            description=description,
            immunity_days=immunity_days,
            base_score=base_score,
            swap_threshold=swap_threshold,
            features=features
        )

    def export_preset(
        self,
        name: str,
        output_path: Path
    ) -> None:
        """
        Export a preset to a specific file path.

        Args:
            name: Name of the preset to export
            output_path: Destination file path
        """
        preset = self.load_preset(name)
        if preset is None:
            raise ValueError(f"Preset '{name}' not found")

        preset.to_json(output_path)

    def import_preset(
        self,
        filepath: Path,
        new_name: Optional[str] = None,
        overwrite: bool = False
    ) -> VulnerabilityScoreParams:
        """
        Import a preset from a JSON file.

        Args:
            filepath: Path to the JSON file
            new_name: Optional new name for the preset
            overwrite: If True, overwrite existing preset

        Returns:
            The imported VulnerabilityScoreParams
        """
        params = VulnerabilityScoreParams.from_json(filepath)

        if new_name:
            params.name = new_name

        self.save_preset(params, overwrite=overwrite)

        return params

    def _sanitize_filename(self, name: str) -> str:
        """Convert preset name to safe filename."""
        # Replace spaces and special characters
        safe = name.lower()
        safe = safe.replace(' ', '_')
        safe = ''.join(c for c in safe if c.isalnum() or c == '_')
        return safe

    def get_preset_info(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get summary information about a preset.

        Args:
            name: Name of the preset

        Returns:
            Dict with preset info or None if not found
        """
        preset = self.load_preset(name)
        if preset is None:
            return None

        enabled_features = preset.get_enabled_features()

        return {
            'name': preset.name,
            'description': preset.description,
            'immunity_days': preset.immunity_days,
            'base_score': preset.base_score,
            'swap_threshold': preset.swap_threshold,
            'enabled_features': enabled_features,
            'is_builtin': name in VULNERABILITY_SCORE_PRESETS,
            'total_features': len(preset.features)
        }

    def list_presets_info(self) -> List[Dict[str, Any]]:
        """Get summary info for all presets."""
        return [
            self.get_preset_info(name)
            for name in self.get_preset_names()
        ]
