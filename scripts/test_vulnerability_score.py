#!/usr/bin/env python3
"""
Vulnerability Score Testing Script

This script tests the vulnerability score functionality by:
1. Running a portfolio backtest with vulnerability score enabled on multiple securities
2. Running individual single-security backtests on the same securities
3. Generating a comprehensive comparison report showing:
   - Vulnerability swaps made in portfolio mode
   - Near-swaps (positions that were close to being swapped)
   - Trade overlap analysis between single security tests
   - Timeline visualization of when trades would have conflicted

Usage:
    python scripts/test_vulnerability_score.py [--securities SEC1,SEC2,...] [--output OUTPUT_DIR]

Example:
    python scripts/test_vulnerability_score.py --securities AAPL,MSFT,GOOGL --output reports/vuln_test
"""

import argparse
import json
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict

import pandas as pd

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from Classes.Config.config import PortfolioConfig, BacktestConfig, CommissionConfig
from Classes.Config.capital_contention import (
    CapitalContentionConfig, CapitalContentionMode, VulnerabilityScoreConfig
)
from Classes.Data.data_loader import DataLoader
from Classes.Data.security_registry import SecurityRegistry
from Classes.Data.currency_converter import CurrencyConverter
from Classes.Engine.portfolio_engine import PortfolioEngine, PortfolioBacktestResult, VulnerabilitySwap, SignalRejection
from Classes.Engine.single_security_engine import SingleSecurityEngine
from Classes.Engine.backtest_result import BacktestResult
from Classes.Engine.vulnerability_score import VulnerabilityResult
from Classes.Models.trade import Trade

# Import strategy
from strategies.alphatrend_strategy import AlphaTrendStrategy


@dataclass
class TradeOverlap:
    """Represents an overlap between trades from different securities."""
    symbol_a: str
    symbol_b: str
    trade_a_entry: datetime
    trade_a_exit: datetime
    trade_b_entry: datetime
    trade_b_exit: datetime
    overlap_start: datetime
    overlap_end: datetime
    overlap_days: int
    trade_a_pl: float
    trade_b_pl: float


@dataclass
class NearSwap:
    """Represents a situation where a swap was almost made but wasn't."""
    date: datetime
    weakest_symbol: str
    weakest_score: float
    threshold: float
    reason: str
    all_scores: Dict[str, float]
    new_signal_symbol: str


@dataclass
class VulnerabilitySnapshot:
    """Snapshot of vulnerability scores at a specific date."""
    date: datetime
    scores: Dict[str, float]  # symbol -> score
    details: Dict[str, dict]  # symbol -> {days_open, pl_percent, is_immune, decay_type}
    event: str  # What happened at this date (entry, exit, rejection, swap)


@dataclass
class VulnerabilityTestReport:
    """Complete report from vulnerability score testing."""
    # Test configuration
    securities: List[str]
    strategy_name: str
    initial_capital: float
    vulnerability_config: dict
    test_date: str

    # Portfolio results
    portfolio_total_return: float
    portfolio_total_return_pct: float
    portfolio_total_trades: int

    # Single security results
    single_results: Dict[str, dict]  # symbol -> {return, trades, etc.}
    combined_single_return: float

    # Vulnerability analysis
    swaps_made: List[dict]
    near_swaps: List[dict]
    signal_rejections: List[dict]
    vulnerability_snapshots: List[dict]  # Timeline of vulnerability scores

    # Overlap analysis
    trade_overlaps: List[dict]
    total_overlap_days: int
    max_concurrent_trades: int

    # Capital contention analysis
    capital_contention_events: int  # Times when capital was insufficient
    positions_skipped_no_capital: int  # Positions that couldn't open

    # Summary
    swap_effectiveness: str  # Analysis of whether swaps improved returns
    vulnerability_analysis_summary: str  # Why swaps did/didn't happen


class VulnerabilityScoreTester:
    """Tests vulnerability score functionality with comprehensive reporting."""

    def __init__(self, securities: List[str], output_dir: Path,
                 initial_capital: float = 20000.0,
                 start_date: Optional[datetime] = None,
                 end_date: Optional[datetime] = None):
        """
        Initialize the tester.

        Args:
            securities: List of security symbols to test
            output_dir: Directory for output reports
            initial_capital: Initial capital for backtests
            start_date: Optional start date filter
            end_date: Optional end date filter
        """
        self.securities = securities
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.initial_capital = initial_capital
        self.start_date = start_date
        self.end_date = end_date

        # Load data infrastructure
        self.data_loader = DataLoader(Path('raw_data/processed_exports'))
        self.security_registry = SecurityRegistry(Path('config/security_metadata.json'))
        self.currency_converter = CurrencyConverter(base_currency='GBP')
        try:
            self.currency_converter.load_rates_directory(Path('currency_rates/'))
        except Exception as e:
            print(f"Warning: Could not load currency rates: {e}")

        # Create strategy
        self.strategy = AlphaTrendStrategy()

        # Vulnerability config for testing
        self.vulnerability_config = VulnerabilityScoreConfig(
            immunity_days=7,
            min_profit_threshold=0.02,
            decay_rate_fast=5.0,
            decay_rate_slow=1.0,
            swap_threshold=50.0,
            base_score=100.0
        )

        # Results storage
        self.portfolio_result: Optional[PortfolioBacktestResult] = None
        self.single_results: Dict[str, BacktestResult] = {}

    def run_portfolio_backtest(self) -> PortfolioBacktestResult:
        """Run portfolio backtest with vulnerability score enabled."""
        print("\n" + "=" * 60)
        print("Running PORTFOLIO backtest with vulnerability score")
        print("=" * 60)

        # Configure with vulnerability score
        contention_config = CapitalContentionConfig(
            mode=CapitalContentionMode.VULNERABILITY_SCORE,
            vulnerability_config=self.vulnerability_config
        )

        config = PortfolioConfig(
            initial_capital=self.initial_capital,
            commission=CommissionConfig(),
            start_date=self.start_date,
            end_date=self.end_date,
            capital_contention=contention_config
        )

        # Load data for all securities
        data_dict = {}
        for symbol in self.securities:
            try:
                data = self.data_loader.load_csv(symbol, required_columns=self.strategy.required_columns())
                data_dict[symbol] = data
                print(f"  Loaded {symbol}: {len(data)} bars")
            except Exception as e:
                print(f"  WARNING: Could not load {symbol}: {e}")

        if not data_dict:
            raise ValueError("No data loaded for any security")

        # Create engine and run
        engine = PortfolioEngine(
            config=config,
            currency_converter=self.currency_converter,
            security_registry=self.security_registry
        )

        self.portfolio_result = engine.run(data_dict, self.strategy)

        print(f"\nPortfolio Result:")
        print(f"  Final Equity: ${self.portfolio_result.final_equity:,.2f}")
        print(f"  Total Return: ${self.portfolio_result.total_return:,.2f} ({self.portfolio_result.total_return_pct:.2f}%)")
        print(f"  Vulnerability Swaps: {len(self.portfolio_result.vulnerability_swaps)}")
        print(f"  Signal Rejections: {len(self.portfolio_result.signal_rejections)}")

        return self.portfolio_result

    def run_single_backtests(self) -> Dict[str, BacktestResult]:
        """Run individual backtests for each security."""
        print("\n" + "=" * 60)
        print("Running SINGLE SECURITY backtests")
        print("=" * 60)

        config = BacktestConfig(
            initial_capital=self.initial_capital,
            commission=CommissionConfig(),
            start_date=self.start_date,
            end_date=self.end_date
        )

        for symbol in self.securities:
            print(f"\n  Running {symbol}...")
            try:
                data = self.data_loader.load_csv(symbol, required_columns=self.strategy.required_columns())

                engine = SingleSecurityEngine(
                    config=config,
                    currency_converter=self.currency_converter,
                    security_registry=self.security_registry
                )

                result = engine.run(symbol, data, self.strategy)
                self.single_results[symbol] = result

                print(f"    {symbol}: {len(result.trades)} trades, Return: ${result.total_return:,.2f} ({result.total_return_pct:.2f}%)")

            except Exception as e:
                print(f"    WARNING: Could not run {symbol}: {e}")

        return self.single_results

    def find_trade_overlaps(self) -> List[TradeOverlap]:
        """Find overlapping trades between different securities."""
        overlaps = []

        # Get all trades from single backtests
        all_trades: Dict[str, List[Trade]] = {}
        for symbol, result in self.single_results.items():
            all_trades[symbol] = result.trades

        # Compare each pair of securities
        symbols = list(all_trades.keys())
        for i in range(len(symbols)):
            for j in range(i + 1, len(symbols)):
                sym_a = symbols[i]
                sym_b = symbols[j]

                for trade_a in all_trades[sym_a]:
                    for trade_b in all_trades[sym_b]:
                        # Check for overlap
                        overlap_start = max(trade_a.entry_date, trade_b.entry_date)
                        overlap_end = min(trade_a.exit_date, trade_b.exit_date)

                        if overlap_start < overlap_end:
                            overlap_days = (overlap_end - overlap_start).days
                            overlaps.append(TradeOverlap(
                                symbol_a=sym_a,
                                symbol_b=sym_b,
                                trade_a_entry=trade_a.entry_date,
                                trade_a_exit=trade_a.exit_date,
                                trade_b_entry=trade_b.entry_date,
                                trade_b_exit=trade_b.exit_date,
                                overlap_start=overlap_start,
                                overlap_end=overlap_end,
                                overlap_days=overlap_days,
                                trade_a_pl=trade_a.pl,
                                trade_b_pl=trade_b.pl
                            ))

        return overlaps

    def extract_near_swaps(self) -> List[NearSwap]:
        """Extract situations where a swap was almost made but wasn't."""
        near_swaps = []

        if not self.portfolio_result:
            return near_swaps

        # Look at signal rejections that had vulnerability decisions
        for rejection in self.portfolio_result.signal_rejections:
            if rejection.vulnerability_decision and rejection.vulnerability_decision.all_scores:
                decision = rejection.vulnerability_decision

                if not decision.should_swap:
                    # Find the weakest position
                    all_scores = decision.all_scores
                    if all_scores:
                        weakest_symbol = min(all_scores.keys(), key=lambda s: all_scores[s].score)
                        weakest_score = all_scores[weakest_symbol].score

                        # Check if it was close to threshold (within 20 points)
                        if weakest_score < self.vulnerability_config.swap_threshold + 20:
                            near_swaps.append(NearSwap(
                                date=rejection.date,
                                weakest_symbol=weakest_symbol,
                                weakest_score=weakest_score,
                                threshold=self.vulnerability_config.swap_threshold,
                                reason=decision.reason,
                                all_scores={s: all_scores[s].score for s in all_scores},
                                new_signal_symbol=rejection.symbol
                            ))

        return near_swaps

    def extract_vulnerability_snapshots(self) -> List[VulnerabilitySnapshot]:
        """
        Extract vulnerability score snapshots at key events.

        Shows scores at:
        - Trade entries
        - Trade exits
        - Signal rejections
        - Vulnerability swaps
        """
        snapshots = []

        if not self.portfolio_result:
            return snapshots

        # Get snapshots from swaps
        for swap in self.portfolio_result.vulnerability_swaps:
            if swap.all_scores:
                scores = {s: r.score for s, r in swap.all_scores.items()}
                details = {
                    s: {
                        'days_open': r.days_open,
                        'pl_percent': r.current_pl_percent * 100,
                        'is_immune': r.is_immune,
                        'decay_type': r.decay_type
                    }
                    for s, r in swap.all_scores.items()
                }
                snapshots.append(VulnerabilitySnapshot(
                    date=swap.date,
                    scores=scores,
                    details=details,
                    event=f"SWAP: Closed {swap.closed_symbol} (score {swap.closed_score:.1f}) for {swap.new_symbol}"
                ))

        # Get snapshots from rejections with vulnerability decisions
        for rejection in self.portfolio_result.signal_rejections:
            if rejection.vulnerability_decision and rejection.vulnerability_decision.all_scores:
                decision = rejection.vulnerability_decision
                all_scores = decision.all_scores
                scores = {s: r.score for s, r in all_scores.items()}
                details = {
                    s: {
                        'days_open': r.days_open,
                        'pl_percent': r.current_pl_percent * 100,
                        'is_immune': r.is_immune,
                        'decay_type': r.decay_type
                    }
                    for s, r in all_scores.items()
                }
                snapshots.append(VulnerabilitySnapshot(
                    date=rejection.date,
                    scores=scores,
                    details=details,
                    event=f"REJECTION: {rejection.symbol} signal rejected - {decision.reason}"
                ))

        # Sort by date
        snapshots.sort(key=lambda x: x.date)

        return snapshots

    def analyze_vulnerability_situation(self) -> str:
        """
        Analyze why swaps did or didn't happen and provide insights.

        This helps understand if:
        - Capital contention is actually occurring
        - Vulnerability scores are working correctly
        - Parameters need adjustment
        """
        lines = []

        if not self.portfolio_result:
            return "No portfolio result to analyze."

        num_swaps = len(self.portfolio_result.vulnerability_swaps)
        num_rejections = len(self.portfolio_result.signal_rejections)
        overlaps = self.find_trade_overlaps()

        # Get capital allocation events if available
        capital_events = getattr(self.portfolio_result, 'capital_allocation_events', [])

        lines.append("VULNERABILITY ANALYSIS")
        lines.append("-" * 40)

        # Check if capital contention occurred
        if num_rejections == 0 and num_swaps == 0:
            lines.append("")
            lines.append("NO CAPITAL CONTENTION DETECTED")
            lines.append("")
            lines.append("Possible reasons:")
            lines.append("  1. Positions do not overlap in time (trades are sequential)")
            lines.append("  2. Sufficient capital to hold all positions simultaneously")
            lines.append("  3. Position sizing is small relative to capital")
            lines.append("")

            if overlaps:
                lines.append(f"However, {len(overlaps)} trade overlaps were found in single-security tests.")
                lines.append("This means trades WOULD have overlapped with unlimited capital,")
                lines.append("but the portfolio's capital constraints meant only one position")
                lines.append("was open at a time (no contention needed).")
                lines.append("")
                lines.append("Explanation:")
                lines.append("  - In single-security tests, each security has its own $100k capital")
                lines.append("  - In portfolio mode, all securities share $100k total")
                lines.append("  - With limited capital, trades are taken sequentially")
                lines.append("  - The first signal wins, blocking others until capital is freed")
            else:
                lines.append("Trades do not overlap in time - no capital contention possible.")

        elif num_swaps == 0 and num_rejections > 0:
            lines.append("")
            lines.append(f"CAPITAL CONTENTION OCCURRED: {num_rejections} signal rejections")
            lines.append("")
            lines.append("But NO SWAPS were made. Reasons:")

            # Analyze the rejections
            immune_count = 0
            above_threshold_count = 0
            no_positions_count = 0
            other_count = 0

            for rejection in self.portfolio_result.signal_rejections:
                if rejection.vulnerability_decision:
                    reason = rejection.vulnerability_decision.reason.lower()
                    if 'immune' in reason:
                        immune_count += 1
                    elif 'threshold' in reason or '>=' in reason:
                        above_threshold_count += 1
                    elif 'no open positions' in reason or 'no positions' in reason:
                        no_positions_count += 1
                    else:
                        other_count += 1
                else:
                    if 'no positions' in rejection.reason.lower():
                        no_positions_count += 1
                    else:
                        other_count += 1

            if immune_count > 0:
                lines.append(f"  - {immune_count} rejections: All positions were IMMUNE (within {self.vulnerability_config.immunity_days} days of entry)")
            if above_threshold_count > 0:
                lines.append(f"  - {above_threshold_count} rejections: Weakest position score was ABOVE swap threshold ({self.vulnerability_config.swap_threshold})")
            if no_positions_count > 0:
                lines.append(f"  - {no_positions_count} rejections: No open positions to swap")
            if other_count > 0:
                lines.append(f"  - {other_count} rejections: Other reasons (insufficient capital, etc.)")

            lines.append("")
            lines.append("To increase swaps, consider:")
            lines.append(f"  - Decreasing immunity_days (currently {self.vulnerability_config.immunity_days} days)")
            lines.append(f"  - Increasing swap_threshold (currently {self.vulnerability_config.swap_threshold})")
            lines.append(f"  - Increasing decay_rate_fast (currently {self.vulnerability_config.decay_rate_fast}/day)")

        else:
            lines.append(f"")
            lines.append(f"SWAPS MADE: {num_swaps}")
            lines.append(f"REJECTIONS: {num_rejections}")
            lines.append("")
            lines.append("The vulnerability score system is actively managing capital.")

            if num_swaps > 0:
                lines.append("")
                lines.append("Swap details:")
                for swap in self.portfolio_result.vulnerability_swaps:
                    lines.append(f"  {swap.date.strftime('%Y-%m-%d')}: Closed {swap.closed_symbol} "
                               f"(score: {swap.closed_score:.1f}) -> Opened {swap.new_symbol}")

        # Add capital allocation events analysis
        if capital_events:
            lines.append("")
            lines.append("-" * 40)
            lines.append("")
            lines.append("CAPITAL ALLOCATION EVENTS SUMMARY")
            lines.append("")
            executed = sum(1 for e in capital_events if e.signal_type == "EXECUTED")
            rejected = sum(1 for e in capital_events if e.signal_type == "REJECTED")
            swapped_in = sum(1 for e in capital_events if e.signal_type == "SWAPPED_IN")
            swapped_out = sum(1 for e in capital_events if e.signal_type == "SWAPPED_OUT")
            lines.append(f"  Total capital events: {len(capital_events)}")
            lines.append(f"  Signals executed: {executed}")
            lines.append(f"  Signals rejected: {rejected}")
            lines.append(f"  Positions swapped in: {swapped_in}")
            lines.append(f"  Positions swapped out: {swapped_out}")

            # Show sample events with vulnerability scores
            events_with_scores = [e for e in capital_events if e.vulnerability_scores]
            if events_with_scores:
                lines.append("")
                lines.append("  Sample events with vulnerability scores:")
                for event in events_with_scores[:5]:
                    scores_str = ", ".join(f"{s}: {v:.1f}" for s, v in event.vulnerability_scores.items())
                    lines.append(f"    {event.date.strftime('%Y-%m-%d')} [{event.signal_type}] {event.symbol}: {scores_str}")
                    lines.append(f"      -> {event.outcome}")

        lines.append("")
        lines.append("-" * 40)
        lines.append("")
        lines.append("WHAT 'SIGNAL REJECTIONS' MEANS:")
        lines.append("  A signal rejection occurs when a buy signal is generated")
        lines.append("  but the portfolio cannot execute it due to:")
        lines.append("    - Insufficient available capital")
        lines.append("    - Existing positions blocking capital")
        lines.append("    - Vulnerability score too high to swap existing position")
        lines.append("")
        lines.append("WHAT 'TRADE OVERLAPS' MEANS:")
        lines.append("  Trade overlaps show periods when trades from different")
        lines.append("  securities would have been open simultaneously if each")
        lines.append("  had unlimited capital. This indicates potential capital")
        lines.append("  contention points in a shared-capital portfolio.")

        return "\n".join(lines)

    def calculate_max_concurrent_trades(self) -> int:
        """Calculate maximum number of concurrent trades from single backtests."""
        if not self.single_results:
            return 0

        # Collect all trade periods
        all_trades = []
        for symbol, result in self.single_results.items():
            for trade in result.trades:
                all_trades.append((trade.entry_date, 'entry', symbol))
                all_trades.append((trade.exit_date, 'exit', symbol))

        # Sort by date
        all_trades.sort(key=lambda x: x[0])

        # Count concurrent trades
        current_trades = 0
        max_concurrent = 0

        for date, event_type, symbol in all_trades:
            if event_type == 'entry':
                current_trades += 1
                max_concurrent = max(max_concurrent, current_trades)
            else:
                current_trades -= 1

        return max_concurrent

    def generate_report(self) -> VulnerabilityTestReport:
        """Generate comprehensive test report."""
        print("\n" + "=" * 60)
        print("Generating Report")
        print("=" * 60)

        # Calculate combined single return (if all trades could execute with infinite capital)
        combined_single_return = sum(r.total_return for r in self.single_results.values())

        # Get overlaps
        overlaps = self.find_trade_overlaps()
        total_overlap_days = sum(o.overlap_days for o in overlaps)

        # Get near swaps
        near_swaps = self.extract_near_swaps()

        # Max concurrent trades
        max_concurrent = self.calculate_max_concurrent_trades()

        # Portfolio trades
        portfolio_total_trades = sum(
            len(sr.trades) for sr in self.portfolio_result.symbol_results.values()
        ) if self.portfolio_result else 0

        # Single results summary
        single_results_summary = {}
        for symbol, result in self.single_results.items():
            single_results_summary[symbol] = {
                'total_return': result.total_return,
                'total_return_pct': result.total_return_pct,
                'num_trades': len(result.trades),
                'final_equity': result.final_equity
            }

        # Analyze swap effectiveness
        if self.portfolio_result and self.portfolio_result.vulnerability_swaps:
            swap_effectiveness = self._analyze_swap_effectiveness()
        else:
            swap_effectiveness = "No swaps were made during the backtest period."

        # Get vulnerability snapshots
        vulnerability_snapshots = self.extract_vulnerability_snapshots()

        # Get vulnerability analysis summary
        vulnerability_analysis_summary = self.analyze_vulnerability_situation()

        # Count capital contention events
        capital_contention_events = len(self.portfolio_result.signal_rejections) if self.portfolio_result else 0
        positions_skipped = sum(1 for r in (self.portfolio_result.signal_rejections if self.portfolio_result else [])
                                if r.signal_type == "BUY")

        # Build report
        report = VulnerabilityTestReport(
            securities=self.securities,
            strategy_name=type(self.strategy).__name__,
            initial_capital=self.initial_capital,
            vulnerability_config=asdict(self.vulnerability_config),
            test_date=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            portfolio_total_return=self.portfolio_result.total_return if self.portfolio_result else 0,
            portfolio_total_return_pct=self.portfolio_result.total_return_pct if self.portfolio_result else 0,
            portfolio_total_trades=portfolio_total_trades,
            single_results=single_results_summary,
            combined_single_return=combined_single_return,
            swaps_made=[self._swap_to_dict(s) for s in (self.portfolio_result.vulnerability_swaps if self.portfolio_result else [])],
            near_swaps=[self._near_swap_to_dict(ns) for ns in near_swaps],
            signal_rejections=[self._rejection_to_dict(r) for r in (self.portfolio_result.signal_rejections if self.portfolio_result else [])],
            vulnerability_snapshots=[self._snapshot_to_dict(s) for s in vulnerability_snapshots],
            trade_overlaps=[self._overlap_to_dict(o) for o in overlaps],
            total_overlap_days=total_overlap_days,
            max_concurrent_trades=max_concurrent,
            capital_contention_events=capital_contention_events,
            positions_skipped_no_capital=positions_skipped,
            swap_effectiveness=swap_effectiveness,
            vulnerability_analysis_summary=vulnerability_analysis_summary
        )

        return report

    def _analyze_swap_effectiveness(self) -> str:
        """Analyze whether swaps improved overall returns."""
        if not self.portfolio_result or not self.portfolio_result.vulnerability_swaps:
            return "No swaps to analyze."

        analysis_lines = []
        analysis_lines.append(f"Total swaps made: {len(self.portfolio_result.vulnerability_swaps)}")

        # Look at each swap's outcome
        for swap in self.portfolio_result.vulnerability_swaps:
            # Find the trades for both symbols
            closed_result = self.portfolio_result.symbol_results.get(swap.closed_symbol)
            new_result = self.portfolio_result.symbol_results.get(swap.new_symbol)

            if closed_result and new_result:
                closed_trades_after = [t for t in closed_result.trades if t.exit_date >= swap.date]
                new_trades_after = [t for t in new_result.trades if t.entry_date >= swap.date]

                closed_pl = sum(t.pl for t in closed_trades_after[:1]) if closed_trades_after else 0
                new_pl = sum(t.pl for t in new_trades_after[:1]) if new_trades_after else 0

                analysis_lines.append(
                    f"  {swap.date.strftime('%Y-%m-%d')}: Closed {swap.closed_symbol} (score: {swap.closed_score:.1f}), "
                    f"Opened {swap.new_symbol}. New trade P/L: ${new_pl:,.2f}"
                )

        # Compare portfolio vs combined single
        portfolio_return = self.portfolio_result.total_return if self.portfolio_result else 0
        combined_single = sum(r.total_return for r in self.single_results.values())

        analysis_lines.append("")
        analysis_lines.append(f"Portfolio return (with swaps): ${portfolio_return:,.2f}")
        analysis_lines.append(f"Combined single returns (no capital limit): ${combined_single:,.2f}")
        analysis_lines.append(f"Difference: ${portfolio_return - combined_single:,.2f}")

        if portfolio_return > combined_single * 0.8:
            analysis_lines.append("Assessment: Vulnerability score effectively managed capital contention.")
        else:
            analysis_lines.append("Assessment: Portfolio underperformed due to capital constraints.")

        return "\n".join(analysis_lines)

    def _swap_to_dict(self, swap: VulnerabilitySwap) -> dict:
        """Convert VulnerabilitySwap to dict for JSON serialization."""
        return {
            'date': swap.date.strftime('%Y-%m-%d'),
            'closed_symbol': swap.closed_symbol,
            'closed_score': swap.closed_score,
            'new_symbol': swap.new_symbol,
            'all_scores': {s: r.score for s, r in swap.all_scores.items()} if swap.all_scores else {}
        }

    def _near_swap_to_dict(self, near_swap: NearSwap) -> dict:
        """Convert NearSwap to dict for JSON serialization."""
        return {
            'date': near_swap.date.strftime('%Y-%m-%d'),
            'weakest_symbol': near_swap.weakest_symbol,
            'weakest_score': near_swap.weakest_score,
            'threshold': near_swap.threshold,
            'reason': near_swap.reason,
            'all_scores': near_swap.all_scores,
            'new_signal_symbol': near_swap.new_signal_symbol
        }

    def _rejection_to_dict(self, rejection: SignalRejection) -> dict:
        """Convert SignalRejection to dict for JSON serialization."""
        result = {
            'date': rejection.date.strftime('%Y-%m-%d'),
            'symbol': rejection.symbol,
            'signal_type': rejection.signal_type,
            'reason': rejection.reason,
            'available_capital': rejection.available_capital,
            'required_capital': rejection.required_capital
        }

        # Add vulnerability decision details if available
        if rejection.vulnerability_decision:
            vuln = rejection.vulnerability_decision
            result['vulnerability_decision'] = {
                'should_swap': vuln.should_swap,
                'position_to_close': vuln.position_to_close,
                'position_score': vuln.position_score,
                'reason': vuln.reason,
                'all_scores': {s: r.score for s, r in vuln.all_scores.items()} if vuln.all_scores else {}
            }

        return result

    def _overlap_to_dict(self, overlap: TradeOverlap) -> dict:
        """Convert TradeOverlap to dict for JSON serialization."""
        return {
            'symbol_a': overlap.symbol_a,
            'symbol_b': overlap.symbol_b,
            'trade_a_entry': overlap.trade_a_entry.strftime('%Y-%m-%d'),
            'trade_a_exit': overlap.trade_a_exit.strftime('%Y-%m-%d'),
            'trade_b_entry': overlap.trade_b_entry.strftime('%Y-%m-%d'),
            'trade_b_exit': overlap.trade_b_exit.strftime('%Y-%m-%d'),
            'overlap_start': overlap.overlap_start.strftime('%Y-%m-%d'),
            'overlap_end': overlap.overlap_end.strftime('%Y-%m-%d'),
            'overlap_days': overlap.overlap_days,
            'trade_a_pl': overlap.trade_a_pl,
            'trade_b_pl': overlap.trade_b_pl
        }

    def _snapshot_to_dict(self, snapshot: VulnerabilitySnapshot) -> dict:
        """Convert VulnerabilitySnapshot to dict for JSON serialization."""
        return {
            'date': snapshot.date.strftime('%Y-%m-%d'),
            'event': snapshot.event,
            'scores': snapshot.scores,
            'details': snapshot.details
        }

    def save_report(self, report: VulnerabilityTestReport):
        """Save the report to various formats."""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

        # Save JSON report
        json_path = self.output_dir / f"vulnerability_test_{timestamp}.json"
        with open(json_path, 'w') as f:
            json.dump(asdict(report), f, indent=2, default=str)
        print(f"  JSON report saved to: {json_path}")

        # Save text summary
        txt_path = self.output_dir / f"vulnerability_test_{timestamp}.txt"
        with open(txt_path, 'w') as f:
            f.write(self._format_text_report(report))
        print(f"  Text report saved to: {txt_path}")

        # Save CSV of overlaps
        if report.trade_overlaps:
            csv_path = self.output_dir / f"trade_overlaps_{timestamp}.csv"
            pd.DataFrame(report.trade_overlaps).to_csv(csv_path, index=False)
            print(f"  Overlaps CSV saved to: {csv_path}")

        # Save CSV of swaps
        if report.swaps_made:
            csv_path = self.output_dir / f"vulnerability_swaps_{timestamp}.csv"
            pd.DataFrame(report.swaps_made).to_csv(csv_path, index=False)
            print(f"  Swaps CSV saved to: {csv_path}")

    def _format_text_report(self, report: VulnerabilityTestReport) -> str:
        """Format report as readable text."""
        lines = []
        lines.append("=" * 80)
        lines.append("VULNERABILITY SCORE TEST REPORT")
        lines.append("=" * 80)
        lines.append(f"Test Date: {report.test_date}")
        lines.append(f"Strategy: {report.strategy_name}")
        lines.append(f"Securities: {', '.join(report.securities)}")
        lines.append(f"Initial Capital: ${report.initial_capital:,.2f}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("VULNERABILITY SCORE CONFIG")
        lines.append("-" * 40)
        for key, value in report.vulnerability_config.items():
            lines.append(f"  {key}: {value}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("PORTFOLIO RESULTS (With Vulnerability Score)")
        lines.append("-" * 40)
        lines.append(f"  Total Return: ${report.portfolio_total_return:,.2f} ({report.portfolio_total_return_pct:.2f}%)")
        lines.append(f"  Total Trades: {report.portfolio_total_trades}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("SINGLE SECURITY RESULTS (Independent)")
        lines.append("-" * 40)
        for symbol, data in report.single_results.items():
            lines.append(f"  {symbol}: ${data['total_return']:,.2f} ({data['total_return_pct']:.2f}%), "
                        f"{data['num_trades']} trades")
        lines.append(f"  Combined Total: ${report.combined_single_return:,.2f}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("VULNERABILITY SWAPS")
        lines.append("-" * 40)
        if report.swaps_made:
            for swap in report.swaps_made:
                lines.append(f"  {swap['date']}: {swap['closed_symbol']} (score: {swap['closed_score']:.1f}) -> {swap['new_symbol']}")
                if swap.get('all_scores'):
                    scores_str = ", ".join(f"{s}: {v:.1f}" for s, v in swap['all_scores'].items())
                    lines.append(f"    All scores: {scores_str}")
        else:
            lines.append("  No swaps were made")
        lines.append("")

        lines.append("-" * 40)
        lines.append("NEAR SWAPS (Close to threshold)")
        lines.append("-" * 40)
        if report.near_swaps:
            for ns in report.near_swaps[:10]:  # Show first 10
                lines.append(f"  {ns['date']}: {ns['weakest_symbol']} score {ns['weakest_score']:.1f} "
                            f"(threshold: {ns['threshold']:.1f})")
                lines.append(f"    New signal: {ns['new_signal_symbol']}")
                lines.append(f"    Reason: {ns['reason']}")
            if len(report.near_swaps) > 10:
                lines.append(f"  ... and {len(report.near_swaps) - 10} more")
        else:
            lines.append("  No near-swaps recorded")
        lines.append("")

        lines.append("-" * 40)
        lines.append("SIGNAL REJECTIONS")
        lines.append("-" * 40)
        lines.append(f"  Total rejections: {len(report.signal_rejections)}")
        if report.signal_rejections:
            # Group by symbol
            by_symbol = {}
            for r in report.signal_rejections:
                by_symbol[r['symbol']] = by_symbol.get(r['symbol'], 0) + 1
            for symbol, count in sorted(by_symbol.items(), key=lambda x: -x[1])[:5]:
                lines.append(f"    {symbol}: {count} rejections")
        lines.append("")

        lines.append("-" * 40)
        lines.append("TRADE OVERLAP ANALYSIS")
        lines.append("-" * 40)
        lines.append(f"  Total trade overlaps: {len(report.trade_overlaps)}")
        lines.append(f"  Total overlap days: {report.total_overlap_days}")
        lines.append(f"  Max concurrent trades: {report.max_concurrent_trades}")
        if report.trade_overlaps:
            lines.append("")
            lines.append("  Sample overlaps:")
            for overlap in report.trade_overlaps[:5]:
                lines.append(f"    {overlap['symbol_a']} vs {overlap['symbol_b']}: "
                            f"{overlap['overlap_start']} to {overlap['overlap_end']} "
                            f"({overlap['overlap_days']} days)")
        lines.append("")

        lines.append("-" * 40)
        lines.append("CAPITAL CONTENTION SUMMARY")
        lines.append("-" * 40)
        lines.append(f"  Capital contention events: {report.capital_contention_events}")
        lines.append(f"  Buy signals skipped due to insufficient capital: {report.positions_skipped_no_capital}")
        lines.append("")

        # Vulnerability score snapshots
        lines.append("-" * 40)
        lines.append("VULNERABILITY SCORE SNAPSHOTS")
        lines.append("-" * 40)
        if report.vulnerability_snapshots:
            lines.append("  Timeline of vulnerability scores at key events:")
            lines.append("")
            for snap in report.vulnerability_snapshots[:15]:  # Show first 15
                lines.append(f"  {snap['date']}: {snap['event']}")
                for sym, score in snap['scores'].items():
                    detail = snap['details'].get(sym, {})
                    immune_str = " [IMMUNE]" if detail.get('is_immune', False) else ""
                    pl_str = f"P/L: {detail.get('pl_percent', 0):.2f}%" if 'pl_percent' in detail else ""
                    days_str = f"Days: {detail.get('days_open', 0)}" if 'days_open' in detail else ""
                    decay_str = f"({detail.get('decay_type', '')} decay)" if detail.get('decay_type') else ""
                    lines.append(f"    {sym}: score={score:.1f}{immune_str} | {days_str}, {pl_str} {decay_str}")
                lines.append("")
            if len(report.vulnerability_snapshots) > 15:
                lines.append(f"  ... and {len(report.vulnerability_snapshots) - 15} more snapshots")
        else:
            lines.append("  No vulnerability score snapshots recorded.")
            lines.append("  (This likely means no capital contention occurred)")
        lines.append("")

        lines.append("-" * 40)
        lines.append("SWAP EFFECTIVENESS ANALYSIS")
        lines.append("-" * 40)
        lines.append(report.swap_effectiveness)
        lines.append("")

        lines.append("=" * 80)
        lines.append("DETAILED VULNERABILITY ANALYSIS")
        lines.append("=" * 80)
        lines.append(report.vulnerability_analysis_summary)
        lines.append("")

        lines.append("=" * 80)
        lines.append("END OF REPORT")
        lines.append("=" * 80)

        return "\n".join(lines)

    def run_full_test(self):
        """Run the complete test suite."""
        print("\n" + "=" * 80)
        print("VULNERABILITY SCORE TESTING")
        print("=" * 80)
        print(f"Securities: {', '.join(self.securities)}")
        print(f"Initial Capital: ${self.initial_capital:,.2f}")
        print(f"Output Directory: {self.output_dir}")

        # Run portfolio backtest
        self.run_portfolio_backtest()

        # Run single backtests
        self.run_single_backtests()

        # Generate and save report
        report = self.generate_report()
        self.save_report(report)

        print("\n" + "=" * 80)
        print("TESTING COMPLETE")
        print("=" * 80)

        return report


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Test vulnerability score functionality')
    parser.add_argument('--securities', type=str, default=None,
                       help='Comma-separated list of securities (default: use first 3 available)')
    parser.add_argument('--output', type=str, default='logs/vulnerability_tests',
                       help='Output directory for reports')
    parser.add_argument('--capital', type=float, default=20000.0,
                       help='Initial capital (lower values force more capital contention scenarios, default: 20000)')

    args = parser.parse_args()

    # Get securities
    if args.securities:
        securities = [s.strip() for s in args.securities.split(',')]
    else:
        # Use first 3 available securities
        data_loader = DataLoader(Path('raw_data/processed_exports'))
        available = data_loader.get_available_symbols()
        securities = available[:3] if len(available) >= 3 else available
        print(f"No securities specified, using: {', '.join(securities)}")

    if len(securities) < 2:
        print("ERROR: Need at least 2 securities for portfolio testing")
        sys.exit(1)

    # Run test
    tester = VulnerabilityScoreTester(
        securities=securities,
        output_dir=Path(args.output),
        initial_capital=args.capital
    )

    report = tester.run_full_test()

    # Print summary
    print("\n" + "-" * 40)
    print("SUMMARY")
    print("-" * 40)
    print(f"Portfolio Return: ${report.portfolio_total_return:,.2f} ({report.portfolio_total_return_pct:.2f}%)")
    print(f"Combined Single Returns: ${report.combined_single_return:,.2f}")
    print(f"Swaps Made: {len(report.swaps_made)}")
    print(f"Near Swaps: {len(report.near_swaps)}")
    print(f"Signal Rejections: {len(report.signal_rejections)}")
    print(f"Trade Overlaps: {len(report.trade_overlaps)}")


if __name__ == "__main__":
    main()
