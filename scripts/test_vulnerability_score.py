#!/usr/bin/env python3
"""
Vulnerability Score Testing Script

This script tests the vulnerability score functionality by:
1. Running a portfolio backtest with vulnerability score enabled on multiple securities
2. Running individual single-security backtests on the same securities
3. Generating a comprehensive comparison report showing:
   - Vulnerability swaps made in portfolio mode
   - Near-swaps (positions that were close to being swapped)
   - Trade overlap analysis between single security tests
   - Timeline visualization of when trades would have conflicted

Usage:
    python scripts/test_vulnerability_score.py [--securities SEC1,SEC2,...] [--output OUTPUT_DIR]

Example:
    python scripts/test_vulnerability_score.py --securities AAPL,MSFT,GOOGL --output reports/vuln_test
"""

import argparse
import json
import sys
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict

import pandas as pd

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from Classes.Config.config import PortfolioConfig, BacktestConfig, CommissionConfig
from Classes.Config.capital_contention import (
    CapitalContentionConfig, CapitalContentionMode, VulnerabilityScoreConfig
)
from Classes.Data.data_loader import DataLoader
from Classes.Data.security_registry import SecurityRegistry
from Classes.Data.currency_converter import CurrencyConverter
from Classes.Engine.portfolio_engine import PortfolioEngine, PortfolioBacktestResult, VulnerabilitySwap, SignalRejection
from Classes.Engine.single_security_engine import SingleSecurityEngine
from Classes.Engine.backtest_result import BacktestResult
from Classes.Engine.vulnerability_score import VulnerabilityResult
from Classes.Models.trade import Trade

# Import strategy
from strategies.alphatrend_strategy import AlphaTrendStrategy


@dataclass
class TradeOverlap:
    """Represents an overlap between trades from different securities."""
    symbol_a: str
    symbol_b: str
    trade_a_entry: datetime
    trade_a_exit: datetime
    trade_b_entry: datetime
    trade_b_exit: datetime
    overlap_start: datetime
    overlap_end: datetime
    overlap_days: int
    trade_a_pl: float
    trade_b_pl: float


@dataclass
class NearSwap:
    """Represents a situation where a swap was almost made but wasn't."""
    date: datetime
    weakest_symbol: str
    weakest_score: float
    threshold: float
    reason: str
    all_scores: Dict[str, float]
    new_signal_symbol: str


@dataclass
class VulnerabilityTestReport:
    """Complete report from vulnerability score testing."""
    # Test configuration
    securities: List[str]
    strategy_name: str
    initial_capital: float
    vulnerability_config: dict
    test_date: str

    # Portfolio results
    portfolio_total_return: float
    portfolio_total_return_pct: float
    portfolio_total_trades: int

    # Single security results
    single_results: Dict[str, dict]  # symbol -> {return, trades, etc.}
    combined_single_return: float

    # Vulnerability analysis
    swaps_made: List[dict]
    near_swaps: List[dict]
    signal_rejections: List[dict]

    # Overlap analysis
    trade_overlaps: List[dict]
    total_overlap_days: int
    max_concurrent_trades: int

    # Summary
    swap_effectiveness: str  # Analysis of whether swaps improved returns


class VulnerabilityScoreTester:
    """Tests vulnerability score functionality with comprehensive reporting."""

    def __init__(self, securities: List[str], output_dir: Path,
                 initial_capital: float = 100000.0,
                 start_date: Optional[datetime] = None,
                 end_date: Optional[datetime] = None):
        """
        Initialize the tester.

        Args:
            securities: List of security symbols to test
            output_dir: Directory for output reports
            initial_capital: Initial capital for backtests
            start_date: Optional start date filter
            end_date: Optional end date filter
        """
        self.securities = securities
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.initial_capital = initial_capital
        self.start_date = start_date
        self.end_date = end_date

        # Load data infrastructure
        self.data_loader = DataLoader(Path('raw_data/processed_exports'))
        self.security_registry = SecurityRegistry(Path('config/security_metadata.json'))
        self.currency_converter = CurrencyConverter(base_currency='GBP')
        try:
            self.currency_converter.load_rates_directory(Path('currency_rates/'))
        except Exception as e:
            print(f"Warning: Could not load currency rates: {e}")

        # Create strategy
        self.strategy = AlphaTrendStrategy()

        # Vulnerability config for testing
        self.vulnerability_config = VulnerabilityScoreConfig(
            immunity_days=7,
            min_profit_threshold=0.02,
            decay_rate_fast=5.0,
            decay_rate_slow=1.0,
            swap_threshold=50.0,
            base_score=100.0
        )

        # Results storage
        self.portfolio_result: Optional[PortfolioBacktestResult] = None
        self.single_results: Dict[str, BacktestResult] = {}

    def run_portfolio_backtest(self) -> PortfolioBacktestResult:
        """Run portfolio backtest with vulnerability score enabled."""
        print("\n" + "=" * 60)
        print("Running PORTFOLIO backtest with vulnerability score")
        print("=" * 60)

        # Configure with vulnerability score
        contention_config = CapitalContentionConfig(
            mode=CapitalContentionMode.VULNERABILITY_SCORE,
            vulnerability_config=self.vulnerability_config
        )

        config = PortfolioConfig(
            initial_capital=self.initial_capital,
            commission=CommissionConfig(),
            start_date=self.start_date,
            end_date=self.end_date,
            capital_contention=contention_config
        )

        # Load data for all securities
        data_dict = {}
        for symbol in self.securities:
            try:
                data = self.data_loader.load_csv(symbol, required_columns=self.strategy.required_columns())
                data_dict[symbol] = data
                print(f"  Loaded {symbol}: {len(data)} bars")
            except Exception as e:
                print(f"  WARNING: Could not load {symbol}: {e}")

        if not data_dict:
            raise ValueError("No data loaded for any security")

        # Create engine and run
        engine = PortfolioEngine(
            config=config,
            currency_converter=self.currency_converter,
            security_registry=self.security_registry
        )

        self.portfolio_result = engine.run(data_dict, self.strategy)

        print(f"\nPortfolio Result:")
        print(f"  Final Equity: ${self.portfolio_result.final_equity:,.2f}")
        print(f"  Total Return: ${self.portfolio_result.total_return:,.2f} ({self.portfolio_result.total_return_pct:.2f}%)")
        print(f"  Vulnerability Swaps: {len(self.portfolio_result.vulnerability_swaps)}")
        print(f"  Signal Rejections: {len(self.portfolio_result.signal_rejections)}")

        return self.portfolio_result

    def run_single_backtests(self) -> Dict[str, BacktestResult]:
        """Run individual backtests for each security."""
        print("\n" + "=" * 60)
        print("Running SINGLE SECURITY backtests")
        print("=" * 60)

        config = BacktestConfig(
            initial_capital=self.initial_capital,
            commission=CommissionConfig(),
            start_date=self.start_date,
            end_date=self.end_date
        )

        for symbol in self.securities:
            print(f"\n  Running {symbol}...")
            try:
                data = self.data_loader.load_csv(symbol, required_columns=self.strategy.required_columns())

                engine = SingleSecurityEngine(
                    config=config,
                    currency_converter=self.currency_converter,
                    security_registry=self.security_registry
                )

                result = engine.run(symbol, data, self.strategy)
                self.single_results[symbol] = result

                print(f"    {symbol}: {len(result.trades)} trades, Return: ${result.total_return:,.2f} ({result.total_return_pct:.2f}%)")

            except Exception as e:
                print(f"    WARNING: Could not run {symbol}: {e}")

        return self.single_results

    def find_trade_overlaps(self) -> List[TradeOverlap]:
        """Find overlapping trades between different securities."""
        overlaps = []

        # Get all trades from single backtests
        all_trades: Dict[str, List[Trade]] = {}
        for symbol, result in self.single_results.items():
            all_trades[symbol] = result.trades

        # Compare each pair of securities
        symbols = list(all_trades.keys())
        for i in range(len(symbols)):
            for j in range(i + 1, len(symbols)):
                sym_a = symbols[i]
                sym_b = symbols[j]

                for trade_a in all_trades[sym_a]:
                    for trade_b in all_trades[sym_b]:
                        # Check for overlap
                        overlap_start = max(trade_a.entry_date, trade_b.entry_date)
                        overlap_end = min(trade_a.exit_date, trade_b.exit_date)

                        if overlap_start < overlap_end:
                            overlap_days = (overlap_end - overlap_start).days
                            overlaps.append(TradeOverlap(
                                symbol_a=sym_a,
                                symbol_b=sym_b,
                                trade_a_entry=trade_a.entry_date,
                                trade_a_exit=trade_a.exit_date,
                                trade_b_entry=trade_b.entry_date,
                                trade_b_exit=trade_b.exit_date,
                                overlap_start=overlap_start,
                                overlap_end=overlap_end,
                                overlap_days=overlap_days,
                                trade_a_pl=trade_a.pl,
                                trade_b_pl=trade_b.pl
                            ))

        return overlaps

    def extract_near_swaps(self) -> List[NearSwap]:
        """Extract situations where a swap was almost made but wasn't."""
        near_swaps = []

        if not self.portfolio_result:
            return near_swaps

        # Look at signal rejections that had vulnerability decisions
        for rejection in self.portfolio_result.signal_rejections:
            if rejection.vulnerability_decision and rejection.vulnerability_decision.all_scores:
                decision = rejection.vulnerability_decision

                if not decision.should_swap:
                    # Find the weakest position
                    all_scores = decision.all_scores
                    if all_scores:
                        weakest_symbol = min(all_scores.keys(), key=lambda s: all_scores[s].score)
                        weakest_score = all_scores[weakest_symbol].score

                        # Check if it was close to threshold (within 20 points)
                        if weakest_score < self.vulnerability_config.swap_threshold + 20:
                            near_swaps.append(NearSwap(
                                date=rejection.date,
                                weakest_symbol=weakest_symbol,
                                weakest_score=weakest_score,
                                threshold=self.vulnerability_config.swap_threshold,
                                reason=decision.reason,
                                all_scores={s: all_scores[s].score for s in all_scores},
                                new_signal_symbol=rejection.symbol
                            ))

        return near_swaps

    def calculate_max_concurrent_trades(self) -> int:
        """Calculate maximum number of concurrent trades from single backtests."""
        if not self.single_results:
            return 0

        # Collect all trade periods
        all_trades = []
        for symbol, result in self.single_results.items():
            for trade in result.trades:
                all_trades.append((trade.entry_date, 'entry', symbol))
                all_trades.append((trade.exit_date, 'exit', symbol))

        # Sort by date
        all_trades.sort(key=lambda x: x[0])

        # Count concurrent trades
        current_trades = 0
        max_concurrent = 0

        for date, event_type, symbol in all_trades:
            if event_type == 'entry':
                current_trades += 1
                max_concurrent = max(max_concurrent, current_trades)
            else:
                current_trades -= 1

        return max_concurrent

    def generate_report(self) -> VulnerabilityTestReport:
        """Generate comprehensive test report."""
        print("\n" + "=" * 60)
        print("Generating Report")
        print("=" * 60)

        # Calculate combined single return (if all trades could execute with infinite capital)
        combined_single_return = sum(r.total_return for r in self.single_results.values())

        # Get overlaps
        overlaps = self.find_trade_overlaps()
        total_overlap_days = sum(o.overlap_days for o in overlaps)

        # Get near swaps
        near_swaps = self.extract_near_swaps()

        # Max concurrent trades
        max_concurrent = self.calculate_max_concurrent_trades()

        # Portfolio trades
        portfolio_total_trades = sum(
            len(sr.trades) for sr in self.portfolio_result.symbol_results.values()
        ) if self.portfolio_result else 0

        # Single results summary
        single_results_summary = {}
        for symbol, result in self.single_results.items():
            single_results_summary[symbol] = {
                'total_return': result.total_return,
                'total_return_pct': result.total_return_pct,
                'num_trades': len(result.trades),
                'final_equity': result.final_equity
            }

        # Analyze swap effectiveness
        if self.portfolio_result and self.portfolio_result.vulnerability_swaps:
            swap_effectiveness = self._analyze_swap_effectiveness()
        else:
            swap_effectiveness = "No swaps were made during the backtest period."

        # Build report
        report = VulnerabilityTestReport(
            securities=self.securities,
            strategy_name=type(self.strategy).__name__,
            initial_capital=self.initial_capital,
            vulnerability_config=asdict(self.vulnerability_config),
            test_date=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            portfolio_total_return=self.portfolio_result.total_return if self.portfolio_result else 0,
            portfolio_total_return_pct=self.portfolio_result.total_return_pct if self.portfolio_result else 0,
            portfolio_total_trades=portfolio_total_trades,
            single_results=single_results_summary,
            combined_single_return=combined_single_return,
            swaps_made=[self._swap_to_dict(s) for s in (self.portfolio_result.vulnerability_swaps if self.portfolio_result else [])],
            near_swaps=[self._near_swap_to_dict(ns) for ns in near_swaps],
            signal_rejections=[self._rejection_to_dict(r) for r in (self.portfolio_result.signal_rejections if self.portfolio_result else [])],
            trade_overlaps=[self._overlap_to_dict(o) for o in overlaps],
            total_overlap_days=total_overlap_days,
            max_concurrent_trades=max_concurrent,
            swap_effectiveness=swap_effectiveness
        )

        return report

    def _analyze_swap_effectiveness(self) -> str:
        """Analyze whether swaps improved overall returns."""
        if not self.portfolio_result or not self.portfolio_result.vulnerability_swaps:
            return "No swaps to analyze."

        analysis_lines = []
        analysis_lines.append(f"Total swaps made: {len(self.portfolio_result.vulnerability_swaps)}")

        # Look at each swap's outcome
        for swap in self.portfolio_result.vulnerability_swaps:
            # Find the trades for both symbols
            closed_result = self.portfolio_result.symbol_results.get(swap.closed_symbol)
            new_result = self.portfolio_result.symbol_results.get(swap.new_symbol)

            if closed_result and new_result:
                closed_trades_after = [t for t in closed_result.trades if t.exit_date >= swap.date]
                new_trades_after = [t for t in new_result.trades if t.entry_date >= swap.date]

                closed_pl = sum(t.pl for t in closed_trades_after[:1]) if closed_trades_after else 0
                new_pl = sum(t.pl for t in new_trades_after[:1]) if new_trades_after else 0

                analysis_lines.append(
                    f"  {swap.date.strftime('%Y-%m-%d')}: Closed {swap.closed_symbol} (score: {swap.closed_score:.1f}), "
                    f"Opened {swap.new_symbol}. New trade P/L: ${new_pl:,.2f}"
                )

        # Compare portfolio vs combined single
        portfolio_return = self.portfolio_result.total_return if self.portfolio_result else 0
        combined_single = sum(r.total_return for r in self.single_results.values())

        analysis_lines.append("")
        analysis_lines.append(f"Portfolio return (with swaps): ${portfolio_return:,.2f}")
        analysis_lines.append(f"Combined single returns (no capital limit): ${combined_single:,.2f}")
        analysis_lines.append(f"Difference: ${portfolio_return - combined_single:,.2f}")

        if portfolio_return > combined_single * 0.8:
            analysis_lines.append("Assessment: Vulnerability score effectively managed capital contention.")
        else:
            analysis_lines.append("Assessment: Portfolio underperformed due to capital constraints.")

        return "\n".join(analysis_lines)

    def _swap_to_dict(self, swap: VulnerabilitySwap) -> dict:
        """Convert VulnerabilitySwap to dict for JSON serialization."""
        return {
            'date': swap.date.strftime('%Y-%m-%d'),
            'closed_symbol': swap.closed_symbol,
            'closed_score': swap.closed_score,
            'new_symbol': swap.new_symbol,
            'all_scores': {s: r.score for s, r in swap.all_scores.items()} if swap.all_scores else {}
        }

    def _near_swap_to_dict(self, near_swap: NearSwap) -> dict:
        """Convert NearSwap to dict for JSON serialization."""
        return {
            'date': near_swap.date.strftime('%Y-%m-%d'),
            'weakest_symbol': near_swap.weakest_symbol,
            'weakest_score': near_swap.weakest_score,
            'threshold': near_swap.threshold,
            'reason': near_swap.reason,
            'all_scores': near_swap.all_scores,
            'new_signal_symbol': near_swap.new_signal_symbol
        }

    def _rejection_to_dict(self, rejection: SignalRejection) -> dict:
        """Convert SignalRejection to dict for JSON serialization."""
        return {
            'date': rejection.date.strftime('%Y-%m-%d'),
            'symbol': rejection.symbol,
            'signal_type': rejection.signal_type,
            'reason': rejection.reason,
            'available_capital': rejection.available_capital,
            'required_capital': rejection.required_capital
        }

    def _overlap_to_dict(self, overlap: TradeOverlap) -> dict:
        """Convert TradeOverlap to dict for JSON serialization."""
        return {
            'symbol_a': overlap.symbol_a,
            'symbol_b': overlap.symbol_b,
            'trade_a_entry': overlap.trade_a_entry.strftime('%Y-%m-%d'),
            'trade_a_exit': overlap.trade_a_exit.strftime('%Y-%m-%d'),
            'trade_b_entry': overlap.trade_b_entry.strftime('%Y-%m-%d'),
            'trade_b_exit': overlap.trade_b_exit.strftime('%Y-%m-%d'),
            'overlap_start': overlap.overlap_start.strftime('%Y-%m-%d'),
            'overlap_end': overlap.overlap_end.strftime('%Y-%m-%d'),
            'overlap_days': overlap.overlap_days,
            'trade_a_pl': overlap.trade_a_pl,
            'trade_b_pl': overlap.trade_b_pl
        }

    def save_report(self, report: VulnerabilityTestReport):
        """Save the report to various formats."""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

        # Save JSON report
        json_path = self.output_dir / f"vulnerability_test_{timestamp}.json"
        with open(json_path, 'w') as f:
            json.dump(asdict(report), f, indent=2, default=str)
        print(f"  JSON report saved to: {json_path}")

        # Save text summary
        txt_path = self.output_dir / f"vulnerability_test_{timestamp}.txt"
        with open(txt_path, 'w') as f:
            f.write(self._format_text_report(report))
        print(f"  Text report saved to: {txt_path}")

        # Save CSV of overlaps
        if report.trade_overlaps:
            csv_path = self.output_dir / f"trade_overlaps_{timestamp}.csv"
            pd.DataFrame(report.trade_overlaps).to_csv(csv_path, index=False)
            print(f"  Overlaps CSV saved to: {csv_path}")

        # Save CSV of swaps
        if report.swaps_made:
            csv_path = self.output_dir / f"vulnerability_swaps_{timestamp}.csv"
            pd.DataFrame(report.swaps_made).to_csv(csv_path, index=False)
            print(f"  Swaps CSV saved to: {csv_path}")

    def _format_text_report(self, report: VulnerabilityTestReport) -> str:
        """Format report as readable text."""
        lines = []
        lines.append("=" * 80)
        lines.append("VULNERABILITY SCORE TEST REPORT")
        lines.append("=" * 80)
        lines.append(f"Test Date: {report.test_date}")
        lines.append(f"Strategy: {report.strategy_name}")
        lines.append(f"Securities: {', '.join(report.securities)}")
        lines.append(f"Initial Capital: ${report.initial_capital:,.2f}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("VULNERABILITY SCORE CONFIG")
        lines.append("-" * 40)
        for key, value in report.vulnerability_config.items():
            lines.append(f"  {key}: {value}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("PORTFOLIO RESULTS (With Vulnerability Score)")
        lines.append("-" * 40)
        lines.append(f"  Total Return: ${report.portfolio_total_return:,.2f} ({report.portfolio_total_return_pct:.2f}%)")
        lines.append(f"  Total Trades: {report.portfolio_total_trades}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("SINGLE SECURITY RESULTS (Independent)")
        lines.append("-" * 40)
        for symbol, data in report.single_results.items():
            lines.append(f"  {symbol}: ${data['total_return']:,.2f} ({data['total_return_pct']:.2f}%), "
                        f"{data['num_trades']} trades")
        lines.append(f"  Combined Total: ${report.combined_single_return:,.2f}")
        lines.append("")

        lines.append("-" * 40)
        lines.append("VULNERABILITY SWAPS")
        lines.append("-" * 40)
        if report.swaps_made:
            for swap in report.swaps_made:
                lines.append(f"  {swap['date']}: {swap['closed_symbol']} (score: {swap['closed_score']:.1f}) -> {swap['new_symbol']}")
                if swap.get('all_scores'):
                    scores_str = ", ".join(f"{s}: {v:.1f}" for s, v in swap['all_scores'].items())
                    lines.append(f"    All scores: {scores_str}")
        else:
            lines.append("  No swaps were made")
        lines.append("")

        lines.append("-" * 40)
        lines.append("NEAR SWAPS (Close to threshold)")
        lines.append("-" * 40)
        if report.near_swaps:
            for ns in report.near_swaps[:10]:  # Show first 10
                lines.append(f"  {ns['date']}: {ns['weakest_symbol']} score {ns['weakest_score']:.1f} "
                            f"(threshold: {ns['threshold']:.1f})")
                lines.append(f"    New signal: {ns['new_signal_symbol']}")
                lines.append(f"    Reason: {ns['reason']}")
            if len(report.near_swaps) > 10:
                lines.append(f"  ... and {len(report.near_swaps) - 10} more")
        else:
            lines.append("  No near-swaps recorded")
        lines.append("")

        lines.append("-" * 40)
        lines.append("SIGNAL REJECTIONS")
        lines.append("-" * 40)
        lines.append(f"  Total rejections: {len(report.signal_rejections)}")
        if report.signal_rejections:
            # Group by symbol
            by_symbol = {}
            for r in report.signal_rejections:
                by_symbol[r['symbol']] = by_symbol.get(r['symbol'], 0) + 1
            for symbol, count in sorted(by_symbol.items(), key=lambda x: -x[1])[:5]:
                lines.append(f"    {symbol}: {count} rejections")
        lines.append("")

        lines.append("-" * 40)
        lines.append("TRADE OVERLAP ANALYSIS")
        lines.append("-" * 40)
        lines.append(f"  Total trade overlaps: {len(report.trade_overlaps)}")
        lines.append(f"  Total overlap days: {report.total_overlap_days}")
        lines.append(f"  Max concurrent trades: {report.max_concurrent_trades}")
        if report.trade_overlaps:
            lines.append("")
            lines.append("  Sample overlaps:")
            for overlap in report.trade_overlaps[:5]:
                lines.append(f"    {overlap['symbol_a']} vs {overlap['symbol_b']}: "
                            f"{overlap['overlap_start']} to {overlap['overlap_end']} "
                            f"({overlap['overlap_days']} days)")
        lines.append("")

        lines.append("-" * 40)
        lines.append("SWAP EFFECTIVENESS ANALYSIS")
        lines.append("-" * 40)
        lines.append(report.swap_effectiveness)
        lines.append("")

        lines.append("=" * 80)
        lines.append("END OF REPORT")
        lines.append("=" * 80)

        return "\n".join(lines)

    def run_full_test(self):
        """Run the complete test suite."""
        print("\n" + "=" * 80)
        print("VULNERABILITY SCORE TESTING")
        print("=" * 80)
        print(f"Securities: {', '.join(self.securities)}")
        print(f"Initial Capital: ${self.initial_capital:,.2f}")
        print(f"Output Directory: {self.output_dir}")

        # Run portfolio backtest
        self.run_portfolio_backtest()

        # Run single backtests
        self.run_single_backtests()

        # Generate and save report
        report = self.generate_report()
        self.save_report(report)

        print("\n" + "=" * 80)
        print("TESTING COMPLETE")
        print("=" * 80)

        return report


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Test vulnerability score functionality')
    parser.add_argument('--securities', type=str, default=None,
                       help='Comma-separated list of securities (default: use first 3 available)')
    parser.add_argument('--output', type=str, default='logs/vulnerability_tests',
                       help='Output directory for reports')
    parser.add_argument('--capital', type=float, default=100000.0,
                       help='Initial capital')

    args = parser.parse_args()

    # Get securities
    if args.securities:
        securities = [s.strip() for s in args.securities.split(',')]
    else:
        # Use first 3 available securities
        data_loader = DataLoader(Path('raw_data/processed_exports'))
        available = data_loader.get_available_symbols()
        securities = available[:3] if len(available) >= 3 else available
        print(f"No securities specified, using: {', '.join(securities)}")

    if len(securities) < 2:
        print("ERROR: Need at least 2 securities for portfolio testing")
        sys.exit(1)

    # Run test
    tester = VulnerabilityScoreTester(
        securities=securities,
        output_dir=Path(args.output),
        initial_capital=args.capital
    )

    report = tester.run_full_test()

    # Print summary
    print("\n" + "-" * 40)
    print("SUMMARY")
    print("-" * 40)
    print(f"Portfolio Return: ${report.portfolio_total_return:,.2f} ({report.portfolio_total_return_pct:.2f}%)")
    print(f"Combined Single Returns: ${report.combined_single_return:,.2f}")
    print(f"Swaps Made: {len(report.swaps_made)}")
    print(f"Near Swaps: {len(report.near_swaps)}")
    print(f"Signal Rejections: {len(report.signal_rejections)}")
    print(f"Trade Overlaps: {len(report.trade_overlaps)}")


if __name__ == "__main__":
    main()
